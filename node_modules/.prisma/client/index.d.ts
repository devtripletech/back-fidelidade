
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model telefone_comp
 * 
 */
export type telefone_comp = $Result.DefaultSelection<Prisma.$telefone_compPayload>
/**
 * Model consulta_user
 * 
 */
export type consulta_user = $Result.DefaultSelection<Prisma.$consulta_userPayload>
/**
 * Model consulta_saldo
 * 
 */
export type consulta_saldo = $Result.DefaultSelection<Prisma.$consulta_saldoPayload>
/**
 * Model consulta_insere_log
 * 
 */
export type consulta_insere_log = $Result.DefaultSelection<Prisma.$consulta_insere_logPayload>
/**
 * Model dados_fisica
 * 
 */
export type dados_fisica = $Result.DefaultSelection<Prisma.$dados_fisicaPayload>
/**
 * Model crm_cliente
 * 
 */
export type crm_cliente = $Result.DefaultSelection<Prisma.$crm_clientePayload>
/**
 * Model status_pedido
 * 
 */
export type status_pedido = $Result.DefaultSelection<Prisma.$status_pedidoPayload>
/**
 * Model pedido
 * 
 */
export type pedido = $Result.DefaultSelection<Prisma.$pedidoPayload>
/**
 * Model pedido_item
 * 
 */
export type pedido_item = $Result.DefaultSelection<Prisma.$pedido_itemPayload>
/**
 * Model lista_produto
 * 
 */
export type lista_produto = $Result.DefaultSelection<Prisma.$lista_produtoPayload>
/**
 * Model campanha_token
 * 
 */
export type campanha_token = $Result.DefaultSelection<Prisma.$campanha_tokenPayload>
/**
 * Model userempresa
 * 
 */
export type userempresa = $Result.DefaultSelection<Prisma.$userempresaPayload>
/**
 * Model lista
 * 
 */
export type lista = $Result.DefaultSelection<Prisma.$listaPayload>
/**
 * Model categoria
 * 
 */
export type categoria = $Result.DefaultSelection<Prisma.$categoriaPayload>
/**
 * Model produto
 * 
 */
export type produto = $Result.DefaultSelection<Prisma.$produtoPayload>
/**
 * Model usuario
 * 
 */
export type usuario = $Result.DefaultSelection<Prisma.$usuarioPayload>
/**
 * Model Campanha_msg
 * 
 */
export type Campanha_msg = $Result.DefaultSelection<Prisma.$Campanha_msgPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Resgate
 * 
 */
export type Resgate = $Result.DefaultSelection<Prisma.$ResgatePayload>
/**
 * Model empresa
 * 
 */
export type empresa = $Result.DefaultSelection<Prisma.$empresaPayload>
/**
 * Model campanha_formulario
 * 
 */
export type campanha_formulario = $Result.DefaultSelection<Prisma.$campanha_formularioPayload>
/**
 * Model campanha
 * 
 */
export type campanha = $Result.DefaultSelection<Prisma.$campanhaPayload>
/**
 * Model carimbo
 * 
 */
export type carimbo = $Result.DefaultSelection<Prisma.$carimboPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Telefone_comps
 * const telefone_comps = await prisma.telefone_comp.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Telefone_comps
   * const telefone_comps = await prisma.telefone_comp.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.telefone_comp`: Exposes CRUD operations for the **telefone_comp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Telefone_comps
    * const telefone_comps = await prisma.telefone_comp.findMany()
    * ```
    */
  get telefone_comp(): Prisma.telefone_compDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consulta_user`: Exposes CRUD operations for the **consulta_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consulta_users
    * const consulta_users = await prisma.consulta_user.findMany()
    * ```
    */
  get consulta_user(): Prisma.consulta_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consulta_saldo`: Exposes CRUD operations for the **consulta_saldo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consulta_saldos
    * const consulta_saldos = await prisma.consulta_saldo.findMany()
    * ```
    */
  get consulta_saldo(): Prisma.consulta_saldoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consulta_insere_log`: Exposes CRUD operations for the **consulta_insere_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consulta_insere_logs
    * const consulta_insere_logs = await prisma.consulta_insere_log.findMany()
    * ```
    */
  get consulta_insere_log(): Prisma.consulta_insere_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dados_fisica`: Exposes CRUD operations for the **dados_fisica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dados_fisicas
    * const dados_fisicas = await prisma.dados_fisica.findMany()
    * ```
    */
  get dados_fisica(): Prisma.dados_fisicaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crm_cliente`: Exposes CRUD operations for the **crm_cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crm_clientes
    * const crm_clientes = await prisma.crm_cliente.findMany()
    * ```
    */
  get crm_cliente(): Prisma.crm_clienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.status_pedido`: Exposes CRUD operations for the **status_pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Status_pedidos
    * const status_pedidos = await prisma.status_pedido.findMany()
    * ```
    */
  get status_pedido(): Prisma.status_pedidoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.pedidoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pedido_item`: Exposes CRUD operations for the **pedido_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedido_items
    * const pedido_items = await prisma.pedido_item.findMany()
    * ```
    */
  get pedido_item(): Prisma.pedido_itemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lista_produto`: Exposes CRUD operations for the **lista_produto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lista_produtos
    * const lista_produtos = await prisma.lista_produto.findMany()
    * ```
    */
  get lista_produto(): Prisma.lista_produtoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campanha_token`: Exposes CRUD operations for the **campanha_token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campanha_tokens
    * const campanha_tokens = await prisma.campanha_token.findMany()
    * ```
    */
  get campanha_token(): Prisma.campanha_tokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userempresa`: Exposes CRUD operations for the **userempresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userempresas
    * const userempresas = await prisma.userempresa.findMany()
    * ```
    */
  get userempresa(): Prisma.userempresaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lista`: Exposes CRUD operations for the **lista** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Listas
    * const listas = await prisma.lista.findMany()
    * ```
    */
  get lista(): Prisma.listaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.categoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.produto`: Exposes CRUD operations for the **produto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produtos
    * const produtos = await prisma.produto.findMany()
    * ```
    */
  get produto(): Prisma.produtoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campanha_msg`: Exposes CRUD operations for the **Campanha_msg** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campanha_msgs
    * const campanha_msgs = await prisma.campanha_msg.findMany()
    * ```
    */
  get campanha_msg(): Prisma.Campanha_msgDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resgate`: Exposes CRUD operations for the **Resgate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resgates
    * const resgates = await prisma.resgate.findMany()
    * ```
    */
  get resgate(): Prisma.ResgateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.empresa`: Exposes CRUD operations for the **empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.empresaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campanha_formulario`: Exposes CRUD operations for the **campanha_formulario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campanha_formularios
    * const campanha_formularios = await prisma.campanha_formulario.findMany()
    * ```
    */
  get campanha_formulario(): Prisma.campanha_formularioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campanha`: Exposes CRUD operations for the **campanha** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campanhas
    * const campanhas = await prisma.campanha.findMany()
    * ```
    */
  get campanha(): Prisma.campanhaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carimbo`: Exposes CRUD operations for the **carimbo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carimbos
    * const carimbos = await prisma.carimbo.findMany()
    * ```
    */
  get carimbo(): Prisma.carimboDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    telefone_comp: 'telefone_comp',
    consulta_user: 'consulta_user',
    consulta_saldo: 'consulta_saldo',
    consulta_insere_log: 'consulta_insere_log',
    dados_fisica: 'dados_fisica',
    crm_cliente: 'crm_cliente',
    status_pedido: 'status_pedido',
    pedido: 'pedido',
    pedido_item: 'pedido_item',
    lista_produto: 'lista_produto',
    campanha_token: 'campanha_token',
    userempresa: 'userempresa',
    lista: 'lista',
    categoria: 'categoria',
    produto: 'produto',
    usuario: 'usuario',
    Campanha_msg: 'Campanha_msg',
    User: 'User',
    Resgate: 'Resgate',
    empresa: 'empresa',
    campanha_formulario: 'campanha_formulario',
    campanha: 'campanha',
    carimbo: 'carimbo',
    Category: 'Category',
    Product: 'Product',
    Order: 'Order',
    Item: 'Item'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "telefone_comp" | "consulta_user" | "consulta_saldo" | "consulta_insere_log" | "dados_fisica" | "crm_cliente" | "status_pedido" | "pedido" | "pedido_item" | "lista_produto" | "campanha_token" | "userempresa" | "lista" | "categoria" | "produto" | "usuario" | "campanha_msg" | "user" | "resgate" | "empresa" | "campanha_formulario" | "campanha" | "carimbo" | "category" | "product" | "order" | "item"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      telefone_comp: {
        payload: Prisma.$telefone_compPayload<ExtArgs>
        fields: Prisma.telefone_compFieldRefs
        operations: {
          findUnique: {
            args: Prisma.telefone_compFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.telefone_compFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload>
          }
          findFirst: {
            args: Prisma.telefone_compFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.telefone_compFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload>
          }
          findMany: {
            args: Prisma.telefone_compFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload>[]
          }
          create: {
            args: Prisma.telefone_compCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload>
          }
          createMany: {
            args: Prisma.telefone_compCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.telefone_compCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload>[]
          }
          delete: {
            args: Prisma.telefone_compDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload>
          }
          update: {
            args: Prisma.telefone_compUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload>
          }
          deleteMany: {
            args: Prisma.telefone_compDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.telefone_compUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.telefone_compUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload>[]
          }
          upsert: {
            args: Prisma.telefone_compUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$telefone_compPayload>
          }
          aggregate: {
            args: Prisma.Telefone_compAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelefone_comp>
          }
          groupBy: {
            args: Prisma.telefone_compGroupByArgs<ExtArgs>
            result: $Utils.Optional<Telefone_compGroupByOutputType>[]
          }
          count: {
            args: Prisma.telefone_compCountArgs<ExtArgs>
            result: $Utils.Optional<Telefone_compCountAggregateOutputType> | number
          }
        }
      }
      consulta_user: {
        payload: Prisma.$consulta_userPayload<ExtArgs>
        fields: Prisma.consulta_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consulta_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consulta_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload>
          }
          findFirst: {
            args: Prisma.consulta_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consulta_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload>
          }
          findMany: {
            args: Prisma.consulta_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload>[]
          }
          create: {
            args: Prisma.consulta_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload>
          }
          createMany: {
            args: Prisma.consulta_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.consulta_userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload>[]
          }
          delete: {
            args: Prisma.consulta_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload>
          }
          update: {
            args: Prisma.consulta_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload>
          }
          deleteMany: {
            args: Prisma.consulta_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consulta_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.consulta_userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload>[]
          }
          upsert: {
            args: Prisma.consulta_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_userPayload>
          }
          aggregate: {
            args: Prisma.Consulta_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsulta_user>
          }
          groupBy: {
            args: Prisma.consulta_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Consulta_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.consulta_userCountArgs<ExtArgs>
            result: $Utils.Optional<Consulta_userCountAggregateOutputType> | number
          }
        }
      }
      consulta_saldo: {
        payload: Prisma.$consulta_saldoPayload<ExtArgs>
        fields: Prisma.consulta_saldoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consulta_saldoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consulta_saldoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload>
          }
          findFirst: {
            args: Prisma.consulta_saldoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consulta_saldoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload>
          }
          findMany: {
            args: Prisma.consulta_saldoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload>[]
          }
          create: {
            args: Prisma.consulta_saldoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload>
          }
          createMany: {
            args: Prisma.consulta_saldoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.consulta_saldoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload>[]
          }
          delete: {
            args: Prisma.consulta_saldoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload>
          }
          update: {
            args: Prisma.consulta_saldoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload>
          }
          deleteMany: {
            args: Prisma.consulta_saldoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consulta_saldoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.consulta_saldoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload>[]
          }
          upsert: {
            args: Prisma.consulta_saldoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_saldoPayload>
          }
          aggregate: {
            args: Prisma.Consulta_saldoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsulta_saldo>
          }
          groupBy: {
            args: Prisma.consulta_saldoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Consulta_saldoGroupByOutputType>[]
          }
          count: {
            args: Prisma.consulta_saldoCountArgs<ExtArgs>
            result: $Utils.Optional<Consulta_saldoCountAggregateOutputType> | number
          }
        }
      }
      consulta_insere_log: {
        payload: Prisma.$consulta_insere_logPayload<ExtArgs>
        fields: Prisma.consulta_insere_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consulta_insere_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consulta_insere_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload>
          }
          findFirst: {
            args: Prisma.consulta_insere_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consulta_insere_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload>
          }
          findMany: {
            args: Prisma.consulta_insere_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload>[]
          }
          create: {
            args: Prisma.consulta_insere_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload>
          }
          createMany: {
            args: Prisma.consulta_insere_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.consulta_insere_logCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload>[]
          }
          delete: {
            args: Prisma.consulta_insere_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload>
          }
          update: {
            args: Prisma.consulta_insere_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload>
          }
          deleteMany: {
            args: Prisma.consulta_insere_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consulta_insere_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.consulta_insere_logUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload>[]
          }
          upsert: {
            args: Prisma.consulta_insere_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consulta_insere_logPayload>
          }
          aggregate: {
            args: Prisma.Consulta_insere_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsulta_insere_log>
          }
          groupBy: {
            args: Prisma.consulta_insere_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Consulta_insere_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.consulta_insere_logCountArgs<ExtArgs>
            result: $Utils.Optional<Consulta_insere_logCountAggregateOutputType> | number
          }
        }
      }
      dados_fisica: {
        payload: Prisma.$dados_fisicaPayload<ExtArgs>
        fields: Prisma.dados_fisicaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dados_fisicaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dados_fisicaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload>
          }
          findFirst: {
            args: Prisma.dados_fisicaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dados_fisicaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload>
          }
          findMany: {
            args: Prisma.dados_fisicaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload>[]
          }
          create: {
            args: Prisma.dados_fisicaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload>
          }
          createMany: {
            args: Prisma.dados_fisicaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.dados_fisicaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload>[]
          }
          delete: {
            args: Prisma.dados_fisicaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload>
          }
          update: {
            args: Prisma.dados_fisicaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload>
          }
          deleteMany: {
            args: Prisma.dados_fisicaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dados_fisicaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.dados_fisicaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload>[]
          }
          upsert: {
            args: Prisma.dados_fisicaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dados_fisicaPayload>
          }
          aggregate: {
            args: Prisma.Dados_fisicaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDados_fisica>
          }
          groupBy: {
            args: Prisma.dados_fisicaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dados_fisicaGroupByOutputType>[]
          }
          count: {
            args: Prisma.dados_fisicaCountArgs<ExtArgs>
            result: $Utils.Optional<Dados_fisicaCountAggregateOutputType> | number
          }
        }
      }
      crm_cliente: {
        payload: Prisma.$crm_clientePayload<ExtArgs>
        fields: Prisma.crm_clienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crm_clienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crm_clienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload>
          }
          findFirst: {
            args: Prisma.crm_clienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crm_clienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload>
          }
          findMany: {
            args: Prisma.crm_clienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload>[]
          }
          create: {
            args: Prisma.crm_clienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload>
          }
          createMany: {
            args: Prisma.crm_clienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.crm_clienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload>[]
          }
          delete: {
            args: Prisma.crm_clienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload>
          }
          update: {
            args: Prisma.crm_clienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload>
          }
          deleteMany: {
            args: Prisma.crm_clienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.crm_clienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.crm_clienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload>[]
          }
          upsert: {
            args: Prisma.crm_clienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crm_clientePayload>
          }
          aggregate: {
            args: Prisma.Crm_clienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrm_cliente>
          }
          groupBy: {
            args: Prisma.crm_clienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<Crm_clienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.crm_clienteCountArgs<ExtArgs>
            result: $Utils.Optional<Crm_clienteCountAggregateOutputType> | number
          }
        }
      }
      status_pedido: {
        payload: Prisma.$status_pedidoPayload<ExtArgs>
        fields: Prisma.status_pedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.status_pedidoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.status_pedidoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload>
          }
          findFirst: {
            args: Prisma.status_pedidoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.status_pedidoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload>
          }
          findMany: {
            args: Prisma.status_pedidoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload>[]
          }
          create: {
            args: Prisma.status_pedidoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload>
          }
          createMany: {
            args: Prisma.status_pedidoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.status_pedidoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload>[]
          }
          delete: {
            args: Prisma.status_pedidoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload>
          }
          update: {
            args: Prisma.status_pedidoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload>
          }
          deleteMany: {
            args: Prisma.status_pedidoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.status_pedidoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.status_pedidoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload>[]
          }
          upsert: {
            args: Prisma.status_pedidoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$status_pedidoPayload>
          }
          aggregate: {
            args: Prisma.Status_pedidoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatus_pedido>
          }
          groupBy: {
            args: Prisma.status_pedidoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Status_pedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.status_pedidoCountArgs<ExtArgs>
            result: $Utils.Optional<Status_pedidoCountAggregateOutputType> | number
          }
        }
      }
      pedido: {
        payload: Prisma.$pedidoPayload<ExtArgs>
        fields: Prisma.pedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pedidoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pedidoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload>
          }
          findFirst: {
            args: Prisma.pedidoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pedidoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload>
          }
          findMany: {
            args: Prisma.pedidoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload>[]
          }
          create: {
            args: Prisma.pedidoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload>
          }
          createMany: {
            args: Prisma.pedidoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pedidoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload>[]
          }
          delete: {
            args: Prisma.pedidoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload>
          }
          update: {
            args: Prisma.pedidoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload>
          }
          deleteMany: {
            args: Prisma.pedidoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pedidoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pedidoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload>[]
          }
          upsert: {
            args: Prisma.pedidoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedidoPayload>
          }
          aggregate: {
            args: Prisma.PedidoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedido>
          }
          groupBy: {
            args: Prisma.pedidoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.pedidoCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoCountAggregateOutputType> | number
          }
        }
      }
      pedido_item: {
        payload: Prisma.$pedido_itemPayload<ExtArgs>
        fields: Prisma.pedido_itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pedido_itemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pedido_itemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload>
          }
          findFirst: {
            args: Prisma.pedido_itemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pedido_itemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload>
          }
          findMany: {
            args: Prisma.pedido_itemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload>[]
          }
          create: {
            args: Prisma.pedido_itemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload>
          }
          createMany: {
            args: Prisma.pedido_itemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pedido_itemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload>[]
          }
          delete: {
            args: Prisma.pedido_itemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload>
          }
          update: {
            args: Prisma.pedido_itemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload>
          }
          deleteMany: {
            args: Prisma.pedido_itemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pedido_itemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pedido_itemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload>[]
          }
          upsert: {
            args: Prisma.pedido_itemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pedido_itemPayload>
          }
          aggregate: {
            args: Prisma.Pedido_itemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedido_item>
          }
          groupBy: {
            args: Prisma.pedido_itemGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pedido_itemGroupByOutputType>[]
          }
          count: {
            args: Prisma.pedido_itemCountArgs<ExtArgs>
            result: $Utils.Optional<Pedido_itemCountAggregateOutputType> | number
          }
        }
      }
      lista_produto: {
        payload: Prisma.$lista_produtoPayload<ExtArgs>
        fields: Prisma.lista_produtoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lista_produtoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lista_produtoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload>
          }
          findFirst: {
            args: Prisma.lista_produtoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lista_produtoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload>
          }
          findMany: {
            args: Prisma.lista_produtoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload>[]
          }
          create: {
            args: Prisma.lista_produtoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload>
          }
          createMany: {
            args: Prisma.lista_produtoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.lista_produtoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload>[]
          }
          delete: {
            args: Prisma.lista_produtoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload>
          }
          update: {
            args: Prisma.lista_produtoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload>
          }
          deleteMany: {
            args: Prisma.lista_produtoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lista_produtoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.lista_produtoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload>[]
          }
          upsert: {
            args: Prisma.lista_produtoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lista_produtoPayload>
          }
          aggregate: {
            args: Prisma.Lista_produtoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLista_produto>
          }
          groupBy: {
            args: Prisma.lista_produtoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lista_produtoGroupByOutputType>[]
          }
          count: {
            args: Prisma.lista_produtoCountArgs<ExtArgs>
            result: $Utils.Optional<Lista_produtoCountAggregateOutputType> | number
          }
        }
      }
      campanha_token: {
        payload: Prisma.$campanha_tokenPayload<ExtArgs>
        fields: Prisma.campanha_tokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campanha_tokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campanha_tokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload>
          }
          findFirst: {
            args: Prisma.campanha_tokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campanha_tokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload>
          }
          findMany: {
            args: Prisma.campanha_tokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload>[]
          }
          create: {
            args: Prisma.campanha_tokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload>
          }
          createMany: {
            args: Prisma.campanha_tokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campanha_tokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload>[]
          }
          delete: {
            args: Prisma.campanha_tokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload>
          }
          update: {
            args: Prisma.campanha_tokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload>
          }
          deleteMany: {
            args: Prisma.campanha_tokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campanha_tokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.campanha_tokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload>[]
          }
          upsert: {
            args: Prisma.campanha_tokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_tokenPayload>
          }
          aggregate: {
            args: Prisma.Campanha_tokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampanha_token>
          }
          groupBy: {
            args: Prisma.campanha_tokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Campanha_tokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.campanha_tokenCountArgs<ExtArgs>
            result: $Utils.Optional<Campanha_tokenCountAggregateOutputType> | number
          }
        }
      }
      userempresa: {
        payload: Prisma.$userempresaPayload<ExtArgs>
        fields: Prisma.userempresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userempresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userempresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload>
          }
          findFirst: {
            args: Prisma.userempresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userempresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload>
          }
          findMany: {
            args: Prisma.userempresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload>[]
          }
          create: {
            args: Prisma.userempresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload>
          }
          createMany: {
            args: Prisma.userempresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userempresaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload>[]
          }
          delete: {
            args: Prisma.userempresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload>
          }
          update: {
            args: Prisma.userempresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload>
          }
          deleteMany: {
            args: Prisma.userempresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userempresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userempresaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload>[]
          }
          upsert: {
            args: Prisma.userempresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userempresaPayload>
          }
          aggregate: {
            args: Prisma.UserempresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserempresa>
          }
          groupBy: {
            args: Prisma.userempresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserempresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.userempresaCountArgs<ExtArgs>
            result: $Utils.Optional<UserempresaCountAggregateOutputType> | number
          }
        }
      }
      lista: {
        payload: Prisma.$listaPayload<ExtArgs>
        fields: Prisma.listaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.listaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.listaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload>
          }
          findFirst: {
            args: Prisma.listaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.listaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload>
          }
          findMany: {
            args: Prisma.listaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload>[]
          }
          create: {
            args: Prisma.listaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload>
          }
          createMany: {
            args: Prisma.listaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.listaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload>[]
          }
          delete: {
            args: Prisma.listaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload>
          }
          update: {
            args: Prisma.listaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload>
          }
          deleteMany: {
            args: Prisma.listaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.listaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.listaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload>[]
          }
          upsert: {
            args: Prisma.listaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$listaPayload>
          }
          aggregate: {
            args: Prisma.ListaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLista>
          }
          groupBy: {
            args: Prisma.listaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListaGroupByOutputType>[]
          }
          count: {
            args: Prisma.listaCountArgs<ExtArgs>
            result: $Utils.Optional<ListaCountAggregateOutputType> | number
          }
        }
      }
      categoria: {
        payload: Prisma.$categoriaPayload<ExtArgs>
        fields: Prisma.categoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          findFirst: {
            args: Prisma.categoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          findMany: {
            args: Prisma.categoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>[]
          }
          create: {
            args: Prisma.categoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          createMany: {
            args: Prisma.categoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>[]
          }
          delete: {
            args: Prisma.categoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          update: {
            args: Prisma.categoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          deleteMany: {
            args: Prisma.categoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>[]
          }
          upsert: {
            args: Prisma.categoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.categoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriaCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      produto: {
        payload: Prisma.$produtoPayload<ExtArgs>
        fields: Prisma.produtoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.produtoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.produtoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload>
          }
          findFirst: {
            args: Prisma.produtoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.produtoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload>
          }
          findMany: {
            args: Prisma.produtoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload>[]
          }
          create: {
            args: Prisma.produtoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload>
          }
          createMany: {
            args: Prisma.produtoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.produtoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload>[]
          }
          delete: {
            args: Prisma.produtoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload>
          }
          update: {
            args: Prisma.produtoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload>
          }
          deleteMany: {
            args: Prisma.produtoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.produtoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.produtoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload>[]
          }
          upsert: {
            args: Prisma.produtoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produtoPayload>
          }
          aggregate: {
            args: Prisma.ProdutoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduto>
          }
          groupBy: {
            args: Prisma.produtoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProdutoGroupByOutputType>[]
          }
          count: {
            args: Prisma.produtoCountArgs<ExtArgs>
            result: $Utils.Optional<ProdutoCountAggregateOutputType> | number
          }
        }
      }
      usuario: {
        payload: Prisma.$usuarioPayload<ExtArgs>
        fields: Prisma.usuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findFirst: {
            args: Prisma.usuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findMany: {
            args: Prisma.usuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          create: {
            args: Prisma.usuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          createMany: {
            args: Prisma.usuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          delete: {
            args: Prisma.usuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          update: {
            args: Prisma.usuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          deleteMany: {
            args: Prisma.usuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          upsert: {
            args: Prisma.usuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.usuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Campanha_msg: {
        payload: Prisma.$Campanha_msgPayload<ExtArgs>
        fields: Prisma.Campanha_msgFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Campanha_msgFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Campanha_msgFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload>
          }
          findFirst: {
            args: Prisma.Campanha_msgFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Campanha_msgFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload>
          }
          findMany: {
            args: Prisma.Campanha_msgFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload>[]
          }
          create: {
            args: Prisma.Campanha_msgCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload>
          }
          createMany: {
            args: Prisma.Campanha_msgCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Campanha_msgCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload>[]
          }
          delete: {
            args: Prisma.Campanha_msgDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload>
          }
          update: {
            args: Prisma.Campanha_msgUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload>
          }
          deleteMany: {
            args: Prisma.Campanha_msgDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Campanha_msgUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Campanha_msgUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload>[]
          }
          upsert: {
            args: Prisma.Campanha_msgUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campanha_msgPayload>
          }
          aggregate: {
            args: Prisma.Campanha_msgAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampanha_msg>
          }
          groupBy: {
            args: Prisma.Campanha_msgGroupByArgs<ExtArgs>
            result: $Utils.Optional<Campanha_msgGroupByOutputType>[]
          }
          count: {
            args: Prisma.Campanha_msgCountArgs<ExtArgs>
            result: $Utils.Optional<Campanha_msgCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Resgate: {
        payload: Prisma.$ResgatePayload<ExtArgs>
        fields: Prisma.ResgateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResgateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResgateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload>
          }
          findFirst: {
            args: Prisma.ResgateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResgateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload>
          }
          findMany: {
            args: Prisma.ResgateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload>[]
          }
          create: {
            args: Prisma.ResgateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload>
          }
          createMany: {
            args: Prisma.ResgateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResgateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload>[]
          }
          delete: {
            args: Prisma.ResgateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload>
          }
          update: {
            args: Prisma.ResgateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload>
          }
          deleteMany: {
            args: Prisma.ResgateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResgateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResgateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload>[]
          }
          upsert: {
            args: Prisma.ResgateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResgatePayload>
          }
          aggregate: {
            args: Prisma.ResgateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResgate>
          }
          groupBy: {
            args: Prisma.ResgateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResgateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResgateCountArgs<ExtArgs>
            result: $Utils.Optional<ResgateCountAggregateOutputType> | number
          }
        }
      }
      empresa: {
        payload: Prisma.$empresaPayload<ExtArgs>
        fields: Prisma.empresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.empresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.empresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          findFirst: {
            args: Prisma.empresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.empresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          findMany: {
            args: Prisma.empresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>[]
          }
          create: {
            args: Prisma.empresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          createMany: {
            args: Prisma.empresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.empresaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>[]
          }
          delete: {
            args: Prisma.empresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          update: {
            args: Prisma.empresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          deleteMany: {
            args: Prisma.empresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.empresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.empresaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>[]
          }
          upsert: {
            args: Prisma.empresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.empresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.empresaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      campanha_formulario: {
        payload: Prisma.$campanha_formularioPayload<ExtArgs>
        fields: Prisma.campanha_formularioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campanha_formularioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campanha_formularioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload>
          }
          findFirst: {
            args: Prisma.campanha_formularioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campanha_formularioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload>
          }
          findMany: {
            args: Prisma.campanha_formularioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload>[]
          }
          create: {
            args: Prisma.campanha_formularioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload>
          }
          createMany: {
            args: Prisma.campanha_formularioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campanha_formularioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload>[]
          }
          delete: {
            args: Prisma.campanha_formularioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload>
          }
          update: {
            args: Prisma.campanha_formularioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload>
          }
          deleteMany: {
            args: Prisma.campanha_formularioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campanha_formularioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.campanha_formularioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload>[]
          }
          upsert: {
            args: Prisma.campanha_formularioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanha_formularioPayload>
          }
          aggregate: {
            args: Prisma.Campanha_formularioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampanha_formulario>
          }
          groupBy: {
            args: Prisma.campanha_formularioGroupByArgs<ExtArgs>
            result: $Utils.Optional<Campanha_formularioGroupByOutputType>[]
          }
          count: {
            args: Prisma.campanha_formularioCountArgs<ExtArgs>
            result: $Utils.Optional<Campanha_formularioCountAggregateOutputType> | number
          }
        }
      }
      campanha: {
        payload: Prisma.$campanhaPayload<ExtArgs>
        fields: Prisma.campanhaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campanhaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campanhaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload>
          }
          findFirst: {
            args: Prisma.campanhaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campanhaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload>
          }
          findMany: {
            args: Prisma.campanhaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload>[]
          }
          create: {
            args: Prisma.campanhaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload>
          }
          createMany: {
            args: Prisma.campanhaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campanhaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload>[]
          }
          delete: {
            args: Prisma.campanhaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload>
          }
          update: {
            args: Prisma.campanhaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload>
          }
          deleteMany: {
            args: Prisma.campanhaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campanhaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.campanhaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload>[]
          }
          upsert: {
            args: Prisma.campanhaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campanhaPayload>
          }
          aggregate: {
            args: Prisma.CampanhaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampanha>
          }
          groupBy: {
            args: Prisma.campanhaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampanhaGroupByOutputType>[]
          }
          count: {
            args: Prisma.campanhaCountArgs<ExtArgs>
            result: $Utils.Optional<CampanhaCountAggregateOutputType> | number
          }
        }
      }
      carimbo: {
        payload: Prisma.$carimboPayload<ExtArgs>
        fields: Prisma.carimboFieldRefs
        operations: {
          findUnique: {
            args: Prisma.carimboFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.carimboFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload>
          }
          findFirst: {
            args: Prisma.carimboFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.carimboFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload>
          }
          findMany: {
            args: Prisma.carimboFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload>[]
          }
          create: {
            args: Prisma.carimboCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload>
          }
          createMany: {
            args: Prisma.carimboCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.carimboCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload>[]
          }
          delete: {
            args: Prisma.carimboDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload>
          }
          update: {
            args: Prisma.carimboUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload>
          }
          deleteMany: {
            args: Prisma.carimboDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.carimboUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.carimboUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload>[]
          }
          upsert: {
            args: Prisma.carimboUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$carimboPayload>
          }
          aggregate: {
            args: Prisma.CarimboAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarimbo>
          }
          groupBy: {
            args: Prisma.carimboGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarimboGroupByOutputType>[]
          }
          count: {
            args: Prisma.carimboCountArgs<ExtArgs>
            result: $Utils.Optional<CarimboCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    telefone_comp?: telefone_compOmit
    consulta_user?: consulta_userOmit
    consulta_saldo?: consulta_saldoOmit
    consulta_insere_log?: consulta_insere_logOmit
    dados_fisica?: dados_fisicaOmit
    crm_cliente?: crm_clienteOmit
    status_pedido?: status_pedidoOmit
    pedido?: pedidoOmit
    pedido_item?: pedido_itemOmit
    lista_produto?: lista_produtoOmit
    campanha_token?: campanha_tokenOmit
    userempresa?: userempresaOmit
    lista?: listaOmit
    categoria?: categoriaOmit
    produto?: produtoOmit
    usuario?: usuarioOmit
    campanha_msg?: Campanha_msgOmit
    user?: UserOmit
    resgate?: ResgateOmit
    empresa?: empresaOmit
    campanha_formulario?: campanha_formularioOmit
    campanha?: campanhaOmit
    carimbo?: carimboOmit
    category?: CategoryOmit
    product?: ProductOmit
    order?: OrderOmit
    item?: ItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    produtos: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produtos?: boolean | CategoriaCountOutputTypeCountProdutosArgs
  }

  // Custom InputTypes
  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountProdutosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produtoWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    usuario: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UserCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    items: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ProductCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model telefone_comp
   */

  export type AggregateTelefone_comp = {
    _count: Telefone_compCountAggregateOutputType | null
    _avg: Telefone_compAvgAggregateOutputType | null
    _sum: Telefone_compSumAggregateOutputType | null
    _min: Telefone_compMinAggregateOutputType | null
    _max: Telefone_compMaxAggregateOutputType | null
  }

  export type Telefone_compAvgAggregateOutputType = {
    id_telefone_comp: number | null
    id_dados_fisica: number | null
  }

  export type Telefone_compSumAggregateOutputType = {
    id_telefone_comp: number | null
    id_dados_fisica: number | null
  }

  export type Telefone_compMinAggregateOutputType = {
    id_telefone_comp: number | null
    id_dados_fisica: number | null
    ddd: string | null
    telefone: string | null
  }

  export type Telefone_compMaxAggregateOutputType = {
    id_telefone_comp: number | null
    id_dados_fisica: number | null
    ddd: string | null
    telefone: string | null
  }

  export type Telefone_compCountAggregateOutputType = {
    id_telefone_comp: number
    id_dados_fisica: number
    ddd: number
    telefone: number
    _all: number
  }


  export type Telefone_compAvgAggregateInputType = {
    id_telefone_comp?: true
    id_dados_fisica?: true
  }

  export type Telefone_compSumAggregateInputType = {
    id_telefone_comp?: true
    id_dados_fisica?: true
  }

  export type Telefone_compMinAggregateInputType = {
    id_telefone_comp?: true
    id_dados_fisica?: true
    ddd?: true
    telefone?: true
  }

  export type Telefone_compMaxAggregateInputType = {
    id_telefone_comp?: true
    id_dados_fisica?: true
    ddd?: true
    telefone?: true
  }

  export type Telefone_compCountAggregateInputType = {
    id_telefone_comp?: true
    id_dados_fisica?: true
    ddd?: true
    telefone?: true
    _all?: true
  }

  export type Telefone_compAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which telefone_comp to aggregate.
     */
    where?: telefone_compWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefone_comps to fetch.
     */
    orderBy?: telefone_compOrderByWithRelationInput | telefone_compOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: telefone_compWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefone_comps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefone_comps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned telefone_comps
    **/
    _count?: true | Telefone_compCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Telefone_compAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Telefone_compSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Telefone_compMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Telefone_compMaxAggregateInputType
  }

  export type GetTelefone_compAggregateType<T extends Telefone_compAggregateArgs> = {
        [P in keyof T & keyof AggregateTelefone_comp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelefone_comp[P]>
      : GetScalarType<T[P], AggregateTelefone_comp[P]>
  }




  export type telefone_compGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: telefone_compWhereInput
    orderBy?: telefone_compOrderByWithAggregationInput | telefone_compOrderByWithAggregationInput[]
    by: Telefone_compScalarFieldEnum[] | Telefone_compScalarFieldEnum
    having?: telefone_compScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Telefone_compCountAggregateInputType | true
    _avg?: Telefone_compAvgAggregateInputType
    _sum?: Telefone_compSumAggregateInputType
    _min?: Telefone_compMinAggregateInputType
    _max?: Telefone_compMaxAggregateInputType
  }

  export type Telefone_compGroupByOutputType = {
    id_telefone_comp: number
    id_dados_fisica: number
    ddd: string
    telefone: string
    _count: Telefone_compCountAggregateOutputType | null
    _avg: Telefone_compAvgAggregateOutputType | null
    _sum: Telefone_compSumAggregateOutputType | null
    _min: Telefone_compMinAggregateOutputType | null
    _max: Telefone_compMaxAggregateOutputType | null
  }

  type GetTelefone_compGroupByPayload<T extends telefone_compGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Telefone_compGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Telefone_compGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Telefone_compGroupByOutputType[P]>
            : GetScalarType<T[P], Telefone_compGroupByOutputType[P]>
        }
      >
    >


  export type telefone_compSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_telefone_comp?: boolean
    id_dados_fisica?: boolean
    ddd?: boolean
    telefone?: boolean
  }, ExtArgs["result"]["telefone_comp"]>

  export type telefone_compSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_telefone_comp?: boolean
    id_dados_fisica?: boolean
    ddd?: boolean
    telefone?: boolean
  }, ExtArgs["result"]["telefone_comp"]>

  export type telefone_compSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_telefone_comp?: boolean
    id_dados_fisica?: boolean
    ddd?: boolean
    telefone?: boolean
  }, ExtArgs["result"]["telefone_comp"]>

  export type telefone_compSelectScalar = {
    id_telefone_comp?: boolean
    id_dados_fisica?: boolean
    ddd?: boolean
    telefone?: boolean
  }

  export type telefone_compOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_telefone_comp" | "id_dados_fisica" | "ddd" | "telefone", ExtArgs["result"]["telefone_comp"]>

  export type $telefone_compPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "telefone_comp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_telefone_comp: number
      id_dados_fisica: number
      ddd: string
      telefone: string
    }, ExtArgs["result"]["telefone_comp"]>
    composites: {}
  }

  type telefone_compGetPayload<S extends boolean | null | undefined | telefone_compDefaultArgs> = $Result.GetResult<Prisma.$telefone_compPayload, S>

  type telefone_compCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<telefone_compFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Telefone_compCountAggregateInputType | true
    }

  export interface telefone_compDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['telefone_comp'], meta: { name: 'telefone_comp' } }
    /**
     * Find zero or one Telefone_comp that matches the filter.
     * @param {telefone_compFindUniqueArgs} args - Arguments to find a Telefone_comp
     * @example
     * // Get one Telefone_comp
     * const telefone_comp = await prisma.telefone_comp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends telefone_compFindUniqueArgs>(args: SelectSubset<T, telefone_compFindUniqueArgs<ExtArgs>>): Prisma__telefone_compClient<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Telefone_comp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {telefone_compFindUniqueOrThrowArgs} args - Arguments to find a Telefone_comp
     * @example
     * // Get one Telefone_comp
     * const telefone_comp = await prisma.telefone_comp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends telefone_compFindUniqueOrThrowArgs>(args: SelectSubset<T, telefone_compFindUniqueOrThrowArgs<ExtArgs>>): Prisma__telefone_compClient<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Telefone_comp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefone_compFindFirstArgs} args - Arguments to find a Telefone_comp
     * @example
     * // Get one Telefone_comp
     * const telefone_comp = await prisma.telefone_comp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends telefone_compFindFirstArgs>(args?: SelectSubset<T, telefone_compFindFirstArgs<ExtArgs>>): Prisma__telefone_compClient<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Telefone_comp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefone_compFindFirstOrThrowArgs} args - Arguments to find a Telefone_comp
     * @example
     * // Get one Telefone_comp
     * const telefone_comp = await prisma.telefone_comp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends telefone_compFindFirstOrThrowArgs>(args?: SelectSubset<T, telefone_compFindFirstOrThrowArgs<ExtArgs>>): Prisma__telefone_compClient<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Telefone_comps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefone_compFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Telefone_comps
     * const telefone_comps = await prisma.telefone_comp.findMany()
     * 
     * // Get first 10 Telefone_comps
     * const telefone_comps = await prisma.telefone_comp.findMany({ take: 10 })
     * 
     * // Only select the `id_telefone_comp`
     * const telefone_compWithId_telefone_compOnly = await prisma.telefone_comp.findMany({ select: { id_telefone_comp: true } })
     * 
     */
    findMany<T extends telefone_compFindManyArgs>(args?: SelectSubset<T, telefone_compFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Telefone_comp.
     * @param {telefone_compCreateArgs} args - Arguments to create a Telefone_comp.
     * @example
     * // Create one Telefone_comp
     * const Telefone_comp = await prisma.telefone_comp.create({
     *   data: {
     *     // ... data to create a Telefone_comp
     *   }
     * })
     * 
     */
    create<T extends telefone_compCreateArgs>(args: SelectSubset<T, telefone_compCreateArgs<ExtArgs>>): Prisma__telefone_compClient<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Telefone_comps.
     * @param {telefone_compCreateManyArgs} args - Arguments to create many Telefone_comps.
     * @example
     * // Create many Telefone_comps
     * const telefone_comp = await prisma.telefone_comp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends telefone_compCreateManyArgs>(args?: SelectSubset<T, telefone_compCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Telefone_comps and returns the data saved in the database.
     * @param {telefone_compCreateManyAndReturnArgs} args - Arguments to create many Telefone_comps.
     * @example
     * // Create many Telefone_comps
     * const telefone_comp = await prisma.telefone_comp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Telefone_comps and only return the `id_telefone_comp`
     * const telefone_compWithId_telefone_compOnly = await prisma.telefone_comp.createManyAndReturn({
     *   select: { id_telefone_comp: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends telefone_compCreateManyAndReturnArgs>(args?: SelectSubset<T, telefone_compCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Telefone_comp.
     * @param {telefone_compDeleteArgs} args - Arguments to delete one Telefone_comp.
     * @example
     * // Delete one Telefone_comp
     * const Telefone_comp = await prisma.telefone_comp.delete({
     *   where: {
     *     // ... filter to delete one Telefone_comp
     *   }
     * })
     * 
     */
    delete<T extends telefone_compDeleteArgs>(args: SelectSubset<T, telefone_compDeleteArgs<ExtArgs>>): Prisma__telefone_compClient<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Telefone_comp.
     * @param {telefone_compUpdateArgs} args - Arguments to update one Telefone_comp.
     * @example
     * // Update one Telefone_comp
     * const telefone_comp = await prisma.telefone_comp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends telefone_compUpdateArgs>(args: SelectSubset<T, telefone_compUpdateArgs<ExtArgs>>): Prisma__telefone_compClient<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Telefone_comps.
     * @param {telefone_compDeleteManyArgs} args - Arguments to filter Telefone_comps to delete.
     * @example
     * // Delete a few Telefone_comps
     * const { count } = await prisma.telefone_comp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends telefone_compDeleteManyArgs>(args?: SelectSubset<T, telefone_compDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Telefone_comps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefone_compUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Telefone_comps
     * const telefone_comp = await prisma.telefone_comp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends telefone_compUpdateManyArgs>(args: SelectSubset<T, telefone_compUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Telefone_comps and returns the data updated in the database.
     * @param {telefone_compUpdateManyAndReturnArgs} args - Arguments to update many Telefone_comps.
     * @example
     * // Update many Telefone_comps
     * const telefone_comp = await prisma.telefone_comp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Telefone_comps and only return the `id_telefone_comp`
     * const telefone_compWithId_telefone_compOnly = await prisma.telefone_comp.updateManyAndReturn({
     *   select: { id_telefone_comp: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends telefone_compUpdateManyAndReturnArgs>(args: SelectSubset<T, telefone_compUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Telefone_comp.
     * @param {telefone_compUpsertArgs} args - Arguments to update or create a Telefone_comp.
     * @example
     * // Update or create a Telefone_comp
     * const telefone_comp = await prisma.telefone_comp.upsert({
     *   create: {
     *     // ... data to create a Telefone_comp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Telefone_comp we want to update
     *   }
     * })
     */
    upsert<T extends telefone_compUpsertArgs>(args: SelectSubset<T, telefone_compUpsertArgs<ExtArgs>>): Prisma__telefone_compClient<$Result.GetResult<Prisma.$telefone_compPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Telefone_comps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefone_compCountArgs} args - Arguments to filter Telefone_comps to count.
     * @example
     * // Count the number of Telefone_comps
     * const count = await prisma.telefone_comp.count({
     *   where: {
     *     // ... the filter for the Telefone_comps we want to count
     *   }
     * })
    **/
    count<T extends telefone_compCountArgs>(
      args?: Subset<T, telefone_compCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Telefone_compCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Telefone_comp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Telefone_compAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Telefone_compAggregateArgs>(args: Subset<T, Telefone_compAggregateArgs>): Prisma.PrismaPromise<GetTelefone_compAggregateType<T>>

    /**
     * Group by Telefone_comp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefone_compGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends telefone_compGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: telefone_compGroupByArgs['orderBy'] }
        : { orderBy?: telefone_compGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, telefone_compGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelefone_compGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the telefone_comp model
   */
  readonly fields: telefone_compFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for telefone_comp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__telefone_compClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the telefone_comp model
   */
  interface telefone_compFieldRefs {
    readonly id_telefone_comp: FieldRef<"telefone_comp", 'Int'>
    readonly id_dados_fisica: FieldRef<"telefone_comp", 'Int'>
    readonly ddd: FieldRef<"telefone_comp", 'String'>
    readonly telefone: FieldRef<"telefone_comp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * telefone_comp findUnique
   */
  export type telefone_compFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * Filter, which telefone_comp to fetch.
     */
    where: telefone_compWhereUniqueInput
  }

  /**
   * telefone_comp findUniqueOrThrow
   */
  export type telefone_compFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * Filter, which telefone_comp to fetch.
     */
    where: telefone_compWhereUniqueInput
  }

  /**
   * telefone_comp findFirst
   */
  export type telefone_compFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * Filter, which telefone_comp to fetch.
     */
    where?: telefone_compWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefone_comps to fetch.
     */
    orderBy?: telefone_compOrderByWithRelationInput | telefone_compOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for telefone_comps.
     */
    cursor?: telefone_compWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefone_comps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefone_comps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of telefone_comps.
     */
    distinct?: Telefone_compScalarFieldEnum | Telefone_compScalarFieldEnum[]
  }

  /**
   * telefone_comp findFirstOrThrow
   */
  export type telefone_compFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * Filter, which telefone_comp to fetch.
     */
    where?: telefone_compWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefone_comps to fetch.
     */
    orderBy?: telefone_compOrderByWithRelationInput | telefone_compOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for telefone_comps.
     */
    cursor?: telefone_compWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefone_comps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefone_comps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of telefone_comps.
     */
    distinct?: Telefone_compScalarFieldEnum | Telefone_compScalarFieldEnum[]
  }

  /**
   * telefone_comp findMany
   */
  export type telefone_compFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * Filter, which telefone_comps to fetch.
     */
    where?: telefone_compWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of telefone_comps to fetch.
     */
    orderBy?: telefone_compOrderByWithRelationInput | telefone_compOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing telefone_comps.
     */
    cursor?: telefone_compWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` telefone_comps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` telefone_comps.
     */
    skip?: number
    distinct?: Telefone_compScalarFieldEnum | Telefone_compScalarFieldEnum[]
  }

  /**
   * telefone_comp create
   */
  export type telefone_compCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * The data needed to create a telefone_comp.
     */
    data: XOR<telefone_compCreateInput, telefone_compUncheckedCreateInput>
  }

  /**
   * telefone_comp createMany
   */
  export type telefone_compCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many telefone_comps.
     */
    data: telefone_compCreateManyInput | telefone_compCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * telefone_comp createManyAndReturn
   */
  export type telefone_compCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * The data used to create many telefone_comps.
     */
    data: telefone_compCreateManyInput | telefone_compCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * telefone_comp update
   */
  export type telefone_compUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * The data needed to update a telefone_comp.
     */
    data: XOR<telefone_compUpdateInput, telefone_compUncheckedUpdateInput>
    /**
     * Choose, which telefone_comp to update.
     */
    where: telefone_compWhereUniqueInput
  }

  /**
   * telefone_comp updateMany
   */
  export type telefone_compUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update telefone_comps.
     */
    data: XOR<telefone_compUpdateManyMutationInput, telefone_compUncheckedUpdateManyInput>
    /**
     * Filter which telefone_comps to update
     */
    where?: telefone_compWhereInput
    /**
     * Limit how many telefone_comps to update.
     */
    limit?: number
  }

  /**
   * telefone_comp updateManyAndReturn
   */
  export type telefone_compUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * The data used to update telefone_comps.
     */
    data: XOR<telefone_compUpdateManyMutationInput, telefone_compUncheckedUpdateManyInput>
    /**
     * Filter which telefone_comps to update
     */
    where?: telefone_compWhereInput
    /**
     * Limit how many telefone_comps to update.
     */
    limit?: number
  }

  /**
   * telefone_comp upsert
   */
  export type telefone_compUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * The filter to search for the telefone_comp to update in case it exists.
     */
    where: telefone_compWhereUniqueInput
    /**
     * In case the telefone_comp found by the `where` argument doesn't exist, create a new telefone_comp with this data.
     */
    create: XOR<telefone_compCreateInput, telefone_compUncheckedCreateInput>
    /**
     * In case the telefone_comp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<telefone_compUpdateInput, telefone_compUncheckedUpdateInput>
  }

  /**
   * telefone_comp delete
   */
  export type telefone_compDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
    /**
     * Filter which telefone_comp to delete.
     */
    where: telefone_compWhereUniqueInput
  }

  /**
   * telefone_comp deleteMany
   */
  export type telefone_compDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which telefone_comps to delete
     */
    where?: telefone_compWhereInput
    /**
     * Limit how many telefone_comps to delete.
     */
    limit?: number
  }

  /**
   * telefone_comp without action
   */
  export type telefone_compDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the telefone_comp
     */
    select?: telefone_compSelect<ExtArgs> | null
    /**
     * Omit specific fields from the telefone_comp
     */
    omit?: telefone_compOmit<ExtArgs> | null
  }


  /**
   * Model consulta_user
   */

  export type AggregateConsulta_user = {
    _count: Consulta_userCountAggregateOutputType | null
    _avg: Consulta_userAvgAggregateOutputType | null
    _sum: Consulta_userSumAggregateOutputType | null
    _min: Consulta_userMinAggregateOutputType | null
    _max: Consulta_userMaxAggregateOutputType | null
  }

  export type Consulta_userAvgAggregateOutputType = {
    id_consulta_user: number | null
    id_user: number | null
    id_dados_fisica: number | null
  }

  export type Consulta_userSumAggregateOutputType = {
    id_consulta_user: number | null
    id_user: number | null
    id_dados_fisica: number | null
  }

  export type Consulta_userMinAggregateOutputType = {
    id_consulta_user: number | null
    id_user: number | null
    data_cadastrou: Date | null
    id_dados_fisica: number | null
  }

  export type Consulta_userMaxAggregateOutputType = {
    id_consulta_user: number | null
    id_user: number | null
    data_cadastrou: Date | null
    id_dados_fisica: number | null
  }

  export type Consulta_userCountAggregateOutputType = {
    id_consulta_user: number
    id_user: number
    data_cadastrou: number
    id_dados_fisica: number
    _all: number
  }


  export type Consulta_userAvgAggregateInputType = {
    id_consulta_user?: true
    id_user?: true
    id_dados_fisica?: true
  }

  export type Consulta_userSumAggregateInputType = {
    id_consulta_user?: true
    id_user?: true
    id_dados_fisica?: true
  }

  export type Consulta_userMinAggregateInputType = {
    id_consulta_user?: true
    id_user?: true
    data_cadastrou?: true
    id_dados_fisica?: true
  }

  export type Consulta_userMaxAggregateInputType = {
    id_consulta_user?: true
    id_user?: true
    data_cadastrou?: true
    id_dados_fisica?: true
  }

  export type Consulta_userCountAggregateInputType = {
    id_consulta_user?: true
    id_user?: true
    data_cadastrou?: true
    id_dados_fisica?: true
    _all?: true
  }

  export type Consulta_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consulta_user to aggregate.
     */
    where?: consulta_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_users to fetch.
     */
    orderBy?: consulta_userOrderByWithRelationInput | consulta_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consulta_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consulta_users
    **/
    _count?: true | Consulta_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Consulta_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Consulta_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Consulta_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Consulta_userMaxAggregateInputType
  }

  export type GetConsulta_userAggregateType<T extends Consulta_userAggregateArgs> = {
        [P in keyof T & keyof AggregateConsulta_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsulta_user[P]>
      : GetScalarType<T[P], AggregateConsulta_user[P]>
  }




  export type consulta_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consulta_userWhereInput
    orderBy?: consulta_userOrderByWithAggregationInput | consulta_userOrderByWithAggregationInput[]
    by: Consulta_userScalarFieldEnum[] | Consulta_userScalarFieldEnum
    having?: consulta_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Consulta_userCountAggregateInputType | true
    _avg?: Consulta_userAvgAggregateInputType
    _sum?: Consulta_userSumAggregateInputType
    _min?: Consulta_userMinAggregateInputType
    _max?: Consulta_userMaxAggregateInputType
  }

  export type Consulta_userGroupByOutputType = {
    id_consulta_user: number
    id_user: number
    data_cadastrou: Date | null
    id_dados_fisica: number
    _count: Consulta_userCountAggregateOutputType | null
    _avg: Consulta_userAvgAggregateOutputType | null
    _sum: Consulta_userSumAggregateOutputType | null
    _min: Consulta_userMinAggregateOutputType | null
    _max: Consulta_userMaxAggregateOutputType | null
  }

  type GetConsulta_userGroupByPayload<T extends consulta_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Consulta_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Consulta_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Consulta_userGroupByOutputType[P]>
            : GetScalarType<T[P], Consulta_userGroupByOutputType[P]>
        }
      >
    >


  export type consulta_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta_user?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    id_dados_fisica?: boolean
  }, ExtArgs["result"]["consulta_user"]>

  export type consulta_userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta_user?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    id_dados_fisica?: boolean
  }, ExtArgs["result"]["consulta_user"]>

  export type consulta_userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta_user?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    id_dados_fisica?: boolean
  }, ExtArgs["result"]["consulta_user"]>

  export type consulta_userSelectScalar = {
    id_consulta_user?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    id_dados_fisica?: boolean
  }

  export type consulta_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_consulta_user" | "id_user" | "data_cadastrou" | "id_dados_fisica", ExtArgs["result"]["consulta_user"]>

  export type $consulta_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consulta_user"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_consulta_user: number
      id_user: number
      data_cadastrou: Date | null
      id_dados_fisica: number
    }, ExtArgs["result"]["consulta_user"]>
    composites: {}
  }

  type consulta_userGetPayload<S extends boolean | null | undefined | consulta_userDefaultArgs> = $Result.GetResult<Prisma.$consulta_userPayload, S>

  type consulta_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consulta_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Consulta_userCountAggregateInputType | true
    }

  export interface consulta_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consulta_user'], meta: { name: 'consulta_user' } }
    /**
     * Find zero or one Consulta_user that matches the filter.
     * @param {consulta_userFindUniqueArgs} args - Arguments to find a Consulta_user
     * @example
     * // Get one Consulta_user
     * const consulta_user = await prisma.consulta_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consulta_userFindUniqueArgs>(args: SelectSubset<T, consulta_userFindUniqueArgs<ExtArgs>>): Prisma__consulta_userClient<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consulta_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consulta_userFindUniqueOrThrowArgs} args - Arguments to find a Consulta_user
     * @example
     * // Get one Consulta_user
     * const consulta_user = await prisma.consulta_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consulta_userFindUniqueOrThrowArgs>(args: SelectSubset<T, consulta_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consulta_userClient<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consulta_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_userFindFirstArgs} args - Arguments to find a Consulta_user
     * @example
     * // Get one Consulta_user
     * const consulta_user = await prisma.consulta_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consulta_userFindFirstArgs>(args?: SelectSubset<T, consulta_userFindFirstArgs<ExtArgs>>): Prisma__consulta_userClient<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consulta_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_userFindFirstOrThrowArgs} args - Arguments to find a Consulta_user
     * @example
     * // Get one Consulta_user
     * const consulta_user = await prisma.consulta_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consulta_userFindFirstOrThrowArgs>(args?: SelectSubset<T, consulta_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__consulta_userClient<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consulta_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consulta_users
     * const consulta_users = await prisma.consulta_user.findMany()
     * 
     * // Get first 10 Consulta_users
     * const consulta_users = await prisma.consulta_user.findMany({ take: 10 })
     * 
     * // Only select the `id_consulta_user`
     * const consulta_userWithId_consulta_userOnly = await prisma.consulta_user.findMany({ select: { id_consulta_user: true } })
     * 
     */
    findMany<T extends consulta_userFindManyArgs>(args?: SelectSubset<T, consulta_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consulta_user.
     * @param {consulta_userCreateArgs} args - Arguments to create a Consulta_user.
     * @example
     * // Create one Consulta_user
     * const Consulta_user = await prisma.consulta_user.create({
     *   data: {
     *     // ... data to create a Consulta_user
     *   }
     * })
     * 
     */
    create<T extends consulta_userCreateArgs>(args: SelectSubset<T, consulta_userCreateArgs<ExtArgs>>): Prisma__consulta_userClient<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consulta_users.
     * @param {consulta_userCreateManyArgs} args - Arguments to create many Consulta_users.
     * @example
     * // Create many Consulta_users
     * const consulta_user = await prisma.consulta_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consulta_userCreateManyArgs>(args?: SelectSubset<T, consulta_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consulta_users and returns the data saved in the database.
     * @param {consulta_userCreateManyAndReturnArgs} args - Arguments to create many Consulta_users.
     * @example
     * // Create many Consulta_users
     * const consulta_user = await prisma.consulta_user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consulta_users and only return the `id_consulta_user`
     * const consulta_userWithId_consulta_userOnly = await prisma.consulta_user.createManyAndReturn({
     *   select: { id_consulta_user: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends consulta_userCreateManyAndReturnArgs>(args?: SelectSubset<T, consulta_userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consulta_user.
     * @param {consulta_userDeleteArgs} args - Arguments to delete one Consulta_user.
     * @example
     * // Delete one Consulta_user
     * const Consulta_user = await prisma.consulta_user.delete({
     *   where: {
     *     // ... filter to delete one Consulta_user
     *   }
     * })
     * 
     */
    delete<T extends consulta_userDeleteArgs>(args: SelectSubset<T, consulta_userDeleteArgs<ExtArgs>>): Prisma__consulta_userClient<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consulta_user.
     * @param {consulta_userUpdateArgs} args - Arguments to update one Consulta_user.
     * @example
     * // Update one Consulta_user
     * const consulta_user = await prisma.consulta_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consulta_userUpdateArgs>(args: SelectSubset<T, consulta_userUpdateArgs<ExtArgs>>): Prisma__consulta_userClient<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consulta_users.
     * @param {consulta_userDeleteManyArgs} args - Arguments to filter Consulta_users to delete.
     * @example
     * // Delete a few Consulta_users
     * const { count } = await prisma.consulta_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consulta_userDeleteManyArgs>(args?: SelectSubset<T, consulta_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consulta_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consulta_users
     * const consulta_user = await prisma.consulta_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consulta_userUpdateManyArgs>(args: SelectSubset<T, consulta_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consulta_users and returns the data updated in the database.
     * @param {consulta_userUpdateManyAndReturnArgs} args - Arguments to update many Consulta_users.
     * @example
     * // Update many Consulta_users
     * const consulta_user = await prisma.consulta_user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consulta_users and only return the `id_consulta_user`
     * const consulta_userWithId_consulta_userOnly = await prisma.consulta_user.updateManyAndReturn({
     *   select: { id_consulta_user: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends consulta_userUpdateManyAndReturnArgs>(args: SelectSubset<T, consulta_userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consulta_user.
     * @param {consulta_userUpsertArgs} args - Arguments to update or create a Consulta_user.
     * @example
     * // Update or create a Consulta_user
     * const consulta_user = await prisma.consulta_user.upsert({
     *   create: {
     *     // ... data to create a Consulta_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consulta_user we want to update
     *   }
     * })
     */
    upsert<T extends consulta_userUpsertArgs>(args: SelectSubset<T, consulta_userUpsertArgs<ExtArgs>>): Prisma__consulta_userClient<$Result.GetResult<Prisma.$consulta_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consulta_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_userCountArgs} args - Arguments to filter Consulta_users to count.
     * @example
     * // Count the number of Consulta_users
     * const count = await prisma.consulta_user.count({
     *   where: {
     *     // ... the filter for the Consulta_users we want to count
     *   }
     * })
    **/
    count<T extends consulta_userCountArgs>(
      args?: Subset<T, consulta_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Consulta_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consulta_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Consulta_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Consulta_userAggregateArgs>(args: Subset<T, Consulta_userAggregateArgs>): Prisma.PrismaPromise<GetConsulta_userAggregateType<T>>

    /**
     * Group by Consulta_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consulta_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consulta_userGroupByArgs['orderBy'] }
        : { orderBy?: consulta_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consulta_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsulta_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consulta_user model
   */
  readonly fields: consulta_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consulta_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consulta_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consulta_user model
   */
  interface consulta_userFieldRefs {
    readonly id_consulta_user: FieldRef<"consulta_user", 'Int'>
    readonly id_user: FieldRef<"consulta_user", 'Int'>
    readonly data_cadastrou: FieldRef<"consulta_user", 'DateTime'>
    readonly id_dados_fisica: FieldRef<"consulta_user", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * consulta_user findUnique
   */
  export type consulta_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * Filter, which consulta_user to fetch.
     */
    where: consulta_userWhereUniqueInput
  }

  /**
   * consulta_user findUniqueOrThrow
   */
  export type consulta_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * Filter, which consulta_user to fetch.
     */
    where: consulta_userWhereUniqueInput
  }

  /**
   * consulta_user findFirst
   */
  export type consulta_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * Filter, which consulta_user to fetch.
     */
    where?: consulta_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_users to fetch.
     */
    orderBy?: consulta_userOrderByWithRelationInput | consulta_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consulta_users.
     */
    cursor?: consulta_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consulta_users.
     */
    distinct?: Consulta_userScalarFieldEnum | Consulta_userScalarFieldEnum[]
  }

  /**
   * consulta_user findFirstOrThrow
   */
  export type consulta_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * Filter, which consulta_user to fetch.
     */
    where?: consulta_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_users to fetch.
     */
    orderBy?: consulta_userOrderByWithRelationInput | consulta_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consulta_users.
     */
    cursor?: consulta_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consulta_users.
     */
    distinct?: Consulta_userScalarFieldEnum | Consulta_userScalarFieldEnum[]
  }

  /**
   * consulta_user findMany
   */
  export type consulta_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * Filter, which consulta_users to fetch.
     */
    where?: consulta_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_users to fetch.
     */
    orderBy?: consulta_userOrderByWithRelationInput | consulta_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consulta_users.
     */
    cursor?: consulta_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_users.
     */
    skip?: number
    distinct?: Consulta_userScalarFieldEnum | Consulta_userScalarFieldEnum[]
  }

  /**
   * consulta_user create
   */
  export type consulta_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * The data needed to create a consulta_user.
     */
    data: XOR<consulta_userCreateInput, consulta_userUncheckedCreateInput>
  }

  /**
   * consulta_user createMany
   */
  export type consulta_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consulta_users.
     */
    data: consulta_userCreateManyInput | consulta_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consulta_user createManyAndReturn
   */
  export type consulta_userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * The data used to create many consulta_users.
     */
    data: consulta_userCreateManyInput | consulta_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consulta_user update
   */
  export type consulta_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * The data needed to update a consulta_user.
     */
    data: XOR<consulta_userUpdateInput, consulta_userUncheckedUpdateInput>
    /**
     * Choose, which consulta_user to update.
     */
    where: consulta_userWhereUniqueInput
  }

  /**
   * consulta_user updateMany
   */
  export type consulta_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consulta_users.
     */
    data: XOR<consulta_userUpdateManyMutationInput, consulta_userUncheckedUpdateManyInput>
    /**
     * Filter which consulta_users to update
     */
    where?: consulta_userWhereInput
    /**
     * Limit how many consulta_users to update.
     */
    limit?: number
  }

  /**
   * consulta_user updateManyAndReturn
   */
  export type consulta_userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * The data used to update consulta_users.
     */
    data: XOR<consulta_userUpdateManyMutationInput, consulta_userUncheckedUpdateManyInput>
    /**
     * Filter which consulta_users to update
     */
    where?: consulta_userWhereInput
    /**
     * Limit how many consulta_users to update.
     */
    limit?: number
  }

  /**
   * consulta_user upsert
   */
  export type consulta_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * The filter to search for the consulta_user to update in case it exists.
     */
    where: consulta_userWhereUniqueInput
    /**
     * In case the consulta_user found by the `where` argument doesn't exist, create a new consulta_user with this data.
     */
    create: XOR<consulta_userCreateInput, consulta_userUncheckedCreateInput>
    /**
     * In case the consulta_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consulta_userUpdateInput, consulta_userUncheckedUpdateInput>
  }

  /**
   * consulta_user delete
   */
  export type consulta_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
    /**
     * Filter which consulta_user to delete.
     */
    where: consulta_userWhereUniqueInput
  }

  /**
   * consulta_user deleteMany
   */
  export type consulta_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consulta_users to delete
     */
    where?: consulta_userWhereInput
    /**
     * Limit how many consulta_users to delete.
     */
    limit?: number
  }

  /**
   * consulta_user without action
   */
  export type consulta_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_user
     */
    select?: consulta_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_user
     */
    omit?: consulta_userOmit<ExtArgs> | null
  }


  /**
   * Model consulta_saldo
   */

  export type AggregateConsulta_saldo = {
    _count: Consulta_saldoCountAggregateOutputType | null
    _avg: Consulta_saldoAvgAggregateOutputType | null
    _sum: Consulta_saldoSumAggregateOutputType | null
    _min: Consulta_saldoMinAggregateOutputType | null
    _max: Consulta_saldoMaxAggregateOutputType | null
  }

  export type Consulta_saldoAvgAggregateOutputType = {
    id_consulta_sado: number | null
    id_user: number | null
    saldo: number | null
    saldo_contratado: number | null
  }

  export type Consulta_saldoSumAggregateOutputType = {
    id_consulta_sado: number | null
    id_user: number | null
    saldo: number | null
    saldo_contratado: number | null
  }

  export type Consulta_saldoMinAggregateOutputType = {
    id_consulta_sado: number | null
    id_user: number | null
    data_cadastrou: Date | null
    saldo: number | null
    saldo_contratado: number | null
    data_atualizou: Date | null
  }

  export type Consulta_saldoMaxAggregateOutputType = {
    id_consulta_sado: number | null
    id_user: number | null
    data_cadastrou: Date | null
    saldo: number | null
    saldo_contratado: number | null
    data_atualizou: Date | null
  }

  export type Consulta_saldoCountAggregateOutputType = {
    id_consulta_sado: number
    id_user: number
    data_cadastrou: number
    saldo: number
    saldo_contratado: number
    data_atualizou: number
    _all: number
  }


  export type Consulta_saldoAvgAggregateInputType = {
    id_consulta_sado?: true
    id_user?: true
    saldo?: true
    saldo_contratado?: true
  }

  export type Consulta_saldoSumAggregateInputType = {
    id_consulta_sado?: true
    id_user?: true
    saldo?: true
    saldo_contratado?: true
  }

  export type Consulta_saldoMinAggregateInputType = {
    id_consulta_sado?: true
    id_user?: true
    data_cadastrou?: true
    saldo?: true
    saldo_contratado?: true
    data_atualizou?: true
  }

  export type Consulta_saldoMaxAggregateInputType = {
    id_consulta_sado?: true
    id_user?: true
    data_cadastrou?: true
    saldo?: true
    saldo_contratado?: true
    data_atualizou?: true
  }

  export type Consulta_saldoCountAggregateInputType = {
    id_consulta_sado?: true
    id_user?: true
    data_cadastrou?: true
    saldo?: true
    saldo_contratado?: true
    data_atualizou?: true
    _all?: true
  }

  export type Consulta_saldoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consulta_saldo to aggregate.
     */
    where?: consulta_saldoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_saldos to fetch.
     */
    orderBy?: consulta_saldoOrderByWithRelationInput | consulta_saldoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consulta_saldoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_saldos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_saldos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consulta_saldos
    **/
    _count?: true | Consulta_saldoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Consulta_saldoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Consulta_saldoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Consulta_saldoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Consulta_saldoMaxAggregateInputType
  }

  export type GetConsulta_saldoAggregateType<T extends Consulta_saldoAggregateArgs> = {
        [P in keyof T & keyof AggregateConsulta_saldo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsulta_saldo[P]>
      : GetScalarType<T[P], AggregateConsulta_saldo[P]>
  }




  export type consulta_saldoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consulta_saldoWhereInput
    orderBy?: consulta_saldoOrderByWithAggregationInput | consulta_saldoOrderByWithAggregationInput[]
    by: Consulta_saldoScalarFieldEnum[] | Consulta_saldoScalarFieldEnum
    having?: consulta_saldoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Consulta_saldoCountAggregateInputType | true
    _avg?: Consulta_saldoAvgAggregateInputType
    _sum?: Consulta_saldoSumAggregateInputType
    _min?: Consulta_saldoMinAggregateInputType
    _max?: Consulta_saldoMaxAggregateInputType
  }

  export type Consulta_saldoGroupByOutputType = {
    id_consulta_sado: number
    id_user: number
    data_cadastrou: Date
    saldo: number
    saldo_contratado: number
    data_atualizou: Date
    _count: Consulta_saldoCountAggregateOutputType | null
    _avg: Consulta_saldoAvgAggregateOutputType | null
    _sum: Consulta_saldoSumAggregateOutputType | null
    _min: Consulta_saldoMinAggregateOutputType | null
    _max: Consulta_saldoMaxAggregateOutputType | null
  }

  type GetConsulta_saldoGroupByPayload<T extends consulta_saldoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Consulta_saldoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Consulta_saldoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Consulta_saldoGroupByOutputType[P]>
            : GetScalarType<T[P], Consulta_saldoGroupByOutputType[P]>
        }
      >
    >


  export type consulta_saldoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta_sado?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    saldo?: boolean
    saldo_contratado?: boolean
    data_atualizou?: boolean
  }, ExtArgs["result"]["consulta_saldo"]>

  export type consulta_saldoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta_sado?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    saldo?: boolean
    saldo_contratado?: boolean
    data_atualizou?: boolean
  }, ExtArgs["result"]["consulta_saldo"]>

  export type consulta_saldoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta_sado?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    saldo?: boolean
    saldo_contratado?: boolean
    data_atualizou?: boolean
  }, ExtArgs["result"]["consulta_saldo"]>

  export type consulta_saldoSelectScalar = {
    id_consulta_sado?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    saldo?: boolean
    saldo_contratado?: boolean
    data_atualizou?: boolean
  }

  export type consulta_saldoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_consulta_sado" | "id_user" | "data_cadastrou" | "saldo" | "saldo_contratado" | "data_atualizou", ExtArgs["result"]["consulta_saldo"]>

  export type $consulta_saldoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consulta_saldo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_consulta_sado: number
      id_user: number
      data_cadastrou: Date
      saldo: number
      saldo_contratado: number
      data_atualizou: Date
    }, ExtArgs["result"]["consulta_saldo"]>
    composites: {}
  }

  type consulta_saldoGetPayload<S extends boolean | null | undefined | consulta_saldoDefaultArgs> = $Result.GetResult<Prisma.$consulta_saldoPayload, S>

  type consulta_saldoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consulta_saldoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Consulta_saldoCountAggregateInputType | true
    }

  export interface consulta_saldoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consulta_saldo'], meta: { name: 'consulta_saldo' } }
    /**
     * Find zero or one Consulta_saldo that matches the filter.
     * @param {consulta_saldoFindUniqueArgs} args - Arguments to find a Consulta_saldo
     * @example
     * // Get one Consulta_saldo
     * const consulta_saldo = await prisma.consulta_saldo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consulta_saldoFindUniqueArgs>(args: SelectSubset<T, consulta_saldoFindUniqueArgs<ExtArgs>>): Prisma__consulta_saldoClient<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consulta_saldo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consulta_saldoFindUniqueOrThrowArgs} args - Arguments to find a Consulta_saldo
     * @example
     * // Get one Consulta_saldo
     * const consulta_saldo = await prisma.consulta_saldo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consulta_saldoFindUniqueOrThrowArgs>(args: SelectSubset<T, consulta_saldoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consulta_saldoClient<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consulta_saldo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_saldoFindFirstArgs} args - Arguments to find a Consulta_saldo
     * @example
     * // Get one Consulta_saldo
     * const consulta_saldo = await prisma.consulta_saldo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consulta_saldoFindFirstArgs>(args?: SelectSubset<T, consulta_saldoFindFirstArgs<ExtArgs>>): Prisma__consulta_saldoClient<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consulta_saldo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_saldoFindFirstOrThrowArgs} args - Arguments to find a Consulta_saldo
     * @example
     * // Get one Consulta_saldo
     * const consulta_saldo = await prisma.consulta_saldo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consulta_saldoFindFirstOrThrowArgs>(args?: SelectSubset<T, consulta_saldoFindFirstOrThrowArgs<ExtArgs>>): Prisma__consulta_saldoClient<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consulta_saldos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_saldoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consulta_saldos
     * const consulta_saldos = await prisma.consulta_saldo.findMany()
     * 
     * // Get first 10 Consulta_saldos
     * const consulta_saldos = await prisma.consulta_saldo.findMany({ take: 10 })
     * 
     * // Only select the `id_consulta_sado`
     * const consulta_saldoWithId_consulta_sadoOnly = await prisma.consulta_saldo.findMany({ select: { id_consulta_sado: true } })
     * 
     */
    findMany<T extends consulta_saldoFindManyArgs>(args?: SelectSubset<T, consulta_saldoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consulta_saldo.
     * @param {consulta_saldoCreateArgs} args - Arguments to create a Consulta_saldo.
     * @example
     * // Create one Consulta_saldo
     * const Consulta_saldo = await prisma.consulta_saldo.create({
     *   data: {
     *     // ... data to create a Consulta_saldo
     *   }
     * })
     * 
     */
    create<T extends consulta_saldoCreateArgs>(args: SelectSubset<T, consulta_saldoCreateArgs<ExtArgs>>): Prisma__consulta_saldoClient<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consulta_saldos.
     * @param {consulta_saldoCreateManyArgs} args - Arguments to create many Consulta_saldos.
     * @example
     * // Create many Consulta_saldos
     * const consulta_saldo = await prisma.consulta_saldo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consulta_saldoCreateManyArgs>(args?: SelectSubset<T, consulta_saldoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consulta_saldos and returns the data saved in the database.
     * @param {consulta_saldoCreateManyAndReturnArgs} args - Arguments to create many Consulta_saldos.
     * @example
     * // Create many Consulta_saldos
     * const consulta_saldo = await prisma.consulta_saldo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consulta_saldos and only return the `id_consulta_sado`
     * const consulta_saldoWithId_consulta_sadoOnly = await prisma.consulta_saldo.createManyAndReturn({
     *   select: { id_consulta_sado: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends consulta_saldoCreateManyAndReturnArgs>(args?: SelectSubset<T, consulta_saldoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consulta_saldo.
     * @param {consulta_saldoDeleteArgs} args - Arguments to delete one Consulta_saldo.
     * @example
     * // Delete one Consulta_saldo
     * const Consulta_saldo = await prisma.consulta_saldo.delete({
     *   where: {
     *     // ... filter to delete one Consulta_saldo
     *   }
     * })
     * 
     */
    delete<T extends consulta_saldoDeleteArgs>(args: SelectSubset<T, consulta_saldoDeleteArgs<ExtArgs>>): Prisma__consulta_saldoClient<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consulta_saldo.
     * @param {consulta_saldoUpdateArgs} args - Arguments to update one Consulta_saldo.
     * @example
     * // Update one Consulta_saldo
     * const consulta_saldo = await prisma.consulta_saldo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consulta_saldoUpdateArgs>(args: SelectSubset<T, consulta_saldoUpdateArgs<ExtArgs>>): Prisma__consulta_saldoClient<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consulta_saldos.
     * @param {consulta_saldoDeleteManyArgs} args - Arguments to filter Consulta_saldos to delete.
     * @example
     * // Delete a few Consulta_saldos
     * const { count } = await prisma.consulta_saldo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consulta_saldoDeleteManyArgs>(args?: SelectSubset<T, consulta_saldoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consulta_saldos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_saldoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consulta_saldos
     * const consulta_saldo = await prisma.consulta_saldo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consulta_saldoUpdateManyArgs>(args: SelectSubset<T, consulta_saldoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consulta_saldos and returns the data updated in the database.
     * @param {consulta_saldoUpdateManyAndReturnArgs} args - Arguments to update many Consulta_saldos.
     * @example
     * // Update many Consulta_saldos
     * const consulta_saldo = await prisma.consulta_saldo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consulta_saldos and only return the `id_consulta_sado`
     * const consulta_saldoWithId_consulta_sadoOnly = await prisma.consulta_saldo.updateManyAndReturn({
     *   select: { id_consulta_sado: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends consulta_saldoUpdateManyAndReturnArgs>(args: SelectSubset<T, consulta_saldoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consulta_saldo.
     * @param {consulta_saldoUpsertArgs} args - Arguments to update or create a Consulta_saldo.
     * @example
     * // Update or create a Consulta_saldo
     * const consulta_saldo = await prisma.consulta_saldo.upsert({
     *   create: {
     *     // ... data to create a Consulta_saldo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consulta_saldo we want to update
     *   }
     * })
     */
    upsert<T extends consulta_saldoUpsertArgs>(args: SelectSubset<T, consulta_saldoUpsertArgs<ExtArgs>>): Prisma__consulta_saldoClient<$Result.GetResult<Prisma.$consulta_saldoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consulta_saldos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_saldoCountArgs} args - Arguments to filter Consulta_saldos to count.
     * @example
     * // Count the number of Consulta_saldos
     * const count = await prisma.consulta_saldo.count({
     *   where: {
     *     // ... the filter for the Consulta_saldos we want to count
     *   }
     * })
    **/
    count<T extends consulta_saldoCountArgs>(
      args?: Subset<T, consulta_saldoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Consulta_saldoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consulta_saldo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Consulta_saldoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Consulta_saldoAggregateArgs>(args: Subset<T, Consulta_saldoAggregateArgs>): Prisma.PrismaPromise<GetConsulta_saldoAggregateType<T>>

    /**
     * Group by Consulta_saldo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_saldoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consulta_saldoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consulta_saldoGroupByArgs['orderBy'] }
        : { orderBy?: consulta_saldoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consulta_saldoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsulta_saldoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consulta_saldo model
   */
  readonly fields: consulta_saldoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consulta_saldo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consulta_saldoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consulta_saldo model
   */
  interface consulta_saldoFieldRefs {
    readonly id_consulta_sado: FieldRef<"consulta_saldo", 'Int'>
    readonly id_user: FieldRef<"consulta_saldo", 'Int'>
    readonly data_cadastrou: FieldRef<"consulta_saldo", 'DateTime'>
    readonly saldo: FieldRef<"consulta_saldo", 'Int'>
    readonly saldo_contratado: FieldRef<"consulta_saldo", 'Int'>
    readonly data_atualizou: FieldRef<"consulta_saldo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * consulta_saldo findUnique
   */
  export type consulta_saldoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * Filter, which consulta_saldo to fetch.
     */
    where: consulta_saldoWhereUniqueInput
  }

  /**
   * consulta_saldo findUniqueOrThrow
   */
  export type consulta_saldoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * Filter, which consulta_saldo to fetch.
     */
    where: consulta_saldoWhereUniqueInput
  }

  /**
   * consulta_saldo findFirst
   */
  export type consulta_saldoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * Filter, which consulta_saldo to fetch.
     */
    where?: consulta_saldoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_saldos to fetch.
     */
    orderBy?: consulta_saldoOrderByWithRelationInput | consulta_saldoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consulta_saldos.
     */
    cursor?: consulta_saldoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_saldos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_saldos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consulta_saldos.
     */
    distinct?: Consulta_saldoScalarFieldEnum | Consulta_saldoScalarFieldEnum[]
  }

  /**
   * consulta_saldo findFirstOrThrow
   */
  export type consulta_saldoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * Filter, which consulta_saldo to fetch.
     */
    where?: consulta_saldoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_saldos to fetch.
     */
    orderBy?: consulta_saldoOrderByWithRelationInput | consulta_saldoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consulta_saldos.
     */
    cursor?: consulta_saldoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_saldos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_saldos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consulta_saldos.
     */
    distinct?: Consulta_saldoScalarFieldEnum | Consulta_saldoScalarFieldEnum[]
  }

  /**
   * consulta_saldo findMany
   */
  export type consulta_saldoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * Filter, which consulta_saldos to fetch.
     */
    where?: consulta_saldoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_saldos to fetch.
     */
    orderBy?: consulta_saldoOrderByWithRelationInput | consulta_saldoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consulta_saldos.
     */
    cursor?: consulta_saldoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_saldos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_saldos.
     */
    skip?: number
    distinct?: Consulta_saldoScalarFieldEnum | Consulta_saldoScalarFieldEnum[]
  }

  /**
   * consulta_saldo create
   */
  export type consulta_saldoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * The data needed to create a consulta_saldo.
     */
    data: XOR<consulta_saldoCreateInput, consulta_saldoUncheckedCreateInput>
  }

  /**
   * consulta_saldo createMany
   */
  export type consulta_saldoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consulta_saldos.
     */
    data: consulta_saldoCreateManyInput | consulta_saldoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consulta_saldo createManyAndReturn
   */
  export type consulta_saldoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * The data used to create many consulta_saldos.
     */
    data: consulta_saldoCreateManyInput | consulta_saldoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consulta_saldo update
   */
  export type consulta_saldoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * The data needed to update a consulta_saldo.
     */
    data: XOR<consulta_saldoUpdateInput, consulta_saldoUncheckedUpdateInput>
    /**
     * Choose, which consulta_saldo to update.
     */
    where: consulta_saldoWhereUniqueInput
  }

  /**
   * consulta_saldo updateMany
   */
  export type consulta_saldoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consulta_saldos.
     */
    data: XOR<consulta_saldoUpdateManyMutationInput, consulta_saldoUncheckedUpdateManyInput>
    /**
     * Filter which consulta_saldos to update
     */
    where?: consulta_saldoWhereInput
    /**
     * Limit how many consulta_saldos to update.
     */
    limit?: number
  }

  /**
   * consulta_saldo updateManyAndReturn
   */
  export type consulta_saldoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * The data used to update consulta_saldos.
     */
    data: XOR<consulta_saldoUpdateManyMutationInput, consulta_saldoUncheckedUpdateManyInput>
    /**
     * Filter which consulta_saldos to update
     */
    where?: consulta_saldoWhereInput
    /**
     * Limit how many consulta_saldos to update.
     */
    limit?: number
  }

  /**
   * consulta_saldo upsert
   */
  export type consulta_saldoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * The filter to search for the consulta_saldo to update in case it exists.
     */
    where: consulta_saldoWhereUniqueInput
    /**
     * In case the consulta_saldo found by the `where` argument doesn't exist, create a new consulta_saldo with this data.
     */
    create: XOR<consulta_saldoCreateInput, consulta_saldoUncheckedCreateInput>
    /**
     * In case the consulta_saldo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consulta_saldoUpdateInput, consulta_saldoUncheckedUpdateInput>
  }

  /**
   * consulta_saldo delete
   */
  export type consulta_saldoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
    /**
     * Filter which consulta_saldo to delete.
     */
    where: consulta_saldoWhereUniqueInput
  }

  /**
   * consulta_saldo deleteMany
   */
  export type consulta_saldoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consulta_saldos to delete
     */
    where?: consulta_saldoWhereInput
    /**
     * Limit how many consulta_saldos to delete.
     */
    limit?: number
  }

  /**
   * consulta_saldo without action
   */
  export type consulta_saldoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_saldo
     */
    select?: consulta_saldoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_saldo
     */
    omit?: consulta_saldoOmit<ExtArgs> | null
  }


  /**
   * Model consulta_insere_log
   */

  export type AggregateConsulta_insere_log = {
    _count: Consulta_insere_logCountAggregateOutputType | null
    _avg: Consulta_insere_logAvgAggregateOutputType | null
    _sum: Consulta_insere_logSumAggregateOutputType | null
    _min: Consulta_insere_logMinAggregateOutputType | null
    _max: Consulta_insere_logMaxAggregateOutputType | null
  }

  export type Consulta_insere_logAvgAggregateOutputType = {
    id_consulta_insere: number | null
    id_user: number | null
    debito: number | null
    fonte_propria: number | null
    id_dados_fisica: number | null
  }

  export type Consulta_insere_logSumAggregateOutputType = {
    id_consulta_insere: number | null
    id_user: number | null
    debito: number | null
    fonte_propria: number | null
    id_dados_fisica: number | null
  }

  export type Consulta_insere_logMinAggregateOutputType = {
    id_consulta_insere: number | null
    id_user: number | null
    data_cadastrou: Date | null
    debito: number | null
    fonte_propria: number | null
    consulta: string | null
    id_dados_fisica: number | null
  }

  export type Consulta_insere_logMaxAggregateOutputType = {
    id_consulta_insere: number | null
    id_user: number | null
    data_cadastrou: Date | null
    debito: number | null
    fonte_propria: number | null
    consulta: string | null
    id_dados_fisica: number | null
  }

  export type Consulta_insere_logCountAggregateOutputType = {
    id_consulta_insere: number
    id_user: number
    data_cadastrou: number
    debito: number
    fonte_propria: number
    consulta: number
    id_dados_fisica: number
    _all: number
  }


  export type Consulta_insere_logAvgAggregateInputType = {
    id_consulta_insere?: true
    id_user?: true
    debito?: true
    fonte_propria?: true
    id_dados_fisica?: true
  }

  export type Consulta_insere_logSumAggregateInputType = {
    id_consulta_insere?: true
    id_user?: true
    debito?: true
    fonte_propria?: true
    id_dados_fisica?: true
  }

  export type Consulta_insere_logMinAggregateInputType = {
    id_consulta_insere?: true
    id_user?: true
    data_cadastrou?: true
    debito?: true
    fonte_propria?: true
    consulta?: true
    id_dados_fisica?: true
  }

  export type Consulta_insere_logMaxAggregateInputType = {
    id_consulta_insere?: true
    id_user?: true
    data_cadastrou?: true
    debito?: true
    fonte_propria?: true
    consulta?: true
    id_dados_fisica?: true
  }

  export type Consulta_insere_logCountAggregateInputType = {
    id_consulta_insere?: true
    id_user?: true
    data_cadastrou?: true
    debito?: true
    fonte_propria?: true
    consulta?: true
    id_dados_fisica?: true
    _all?: true
  }

  export type Consulta_insere_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consulta_insere_log to aggregate.
     */
    where?: consulta_insere_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_insere_logs to fetch.
     */
    orderBy?: consulta_insere_logOrderByWithRelationInput | consulta_insere_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consulta_insere_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_insere_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_insere_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consulta_insere_logs
    **/
    _count?: true | Consulta_insere_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Consulta_insere_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Consulta_insere_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Consulta_insere_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Consulta_insere_logMaxAggregateInputType
  }

  export type GetConsulta_insere_logAggregateType<T extends Consulta_insere_logAggregateArgs> = {
        [P in keyof T & keyof AggregateConsulta_insere_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsulta_insere_log[P]>
      : GetScalarType<T[P], AggregateConsulta_insere_log[P]>
  }




  export type consulta_insere_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consulta_insere_logWhereInput
    orderBy?: consulta_insere_logOrderByWithAggregationInput | consulta_insere_logOrderByWithAggregationInput[]
    by: Consulta_insere_logScalarFieldEnum[] | Consulta_insere_logScalarFieldEnum
    having?: consulta_insere_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Consulta_insere_logCountAggregateInputType | true
    _avg?: Consulta_insere_logAvgAggregateInputType
    _sum?: Consulta_insere_logSumAggregateInputType
    _min?: Consulta_insere_logMinAggregateInputType
    _max?: Consulta_insere_logMaxAggregateInputType
  }

  export type Consulta_insere_logGroupByOutputType = {
    id_consulta_insere: number
    id_user: number
    data_cadastrou: Date | null
    debito: number
    fonte_propria: number
    consulta: string
    id_dados_fisica: number
    _count: Consulta_insere_logCountAggregateOutputType | null
    _avg: Consulta_insere_logAvgAggregateOutputType | null
    _sum: Consulta_insere_logSumAggregateOutputType | null
    _min: Consulta_insere_logMinAggregateOutputType | null
    _max: Consulta_insere_logMaxAggregateOutputType | null
  }

  type GetConsulta_insere_logGroupByPayload<T extends consulta_insere_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Consulta_insere_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Consulta_insere_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Consulta_insere_logGroupByOutputType[P]>
            : GetScalarType<T[P], Consulta_insere_logGroupByOutputType[P]>
        }
      >
    >


  export type consulta_insere_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta_insere?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    debito?: boolean
    fonte_propria?: boolean
    consulta?: boolean
    id_dados_fisica?: boolean
  }, ExtArgs["result"]["consulta_insere_log"]>

  export type consulta_insere_logSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta_insere?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    debito?: boolean
    fonte_propria?: boolean
    consulta?: boolean
    id_dados_fisica?: boolean
  }, ExtArgs["result"]["consulta_insere_log"]>

  export type consulta_insere_logSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_consulta_insere?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    debito?: boolean
    fonte_propria?: boolean
    consulta?: boolean
    id_dados_fisica?: boolean
  }, ExtArgs["result"]["consulta_insere_log"]>

  export type consulta_insere_logSelectScalar = {
    id_consulta_insere?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    debito?: boolean
    fonte_propria?: boolean
    consulta?: boolean
    id_dados_fisica?: boolean
  }

  export type consulta_insere_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_consulta_insere" | "id_user" | "data_cadastrou" | "debito" | "fonte_propria" | "consulta" | "id_dados_fisica", ExtArgs["result"]["consulta_insere_log"]>

  export type $consulta_insere_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consulta_insere_log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_consulta_insere: number
      id_user: number
      data_cadastrou: Date | null
      debito: number
      fonte_propria: number
      consulta: string
      id_dados_fisica: number
    }, ExtArgs["result"]["consulta_insere_log"]>
    composites: {}
  }

  type consulta_insere_logGetPayload<S extends boolean | null | undefined | consulta_insere_logDefaultArgs> = $Result.GetResult<Prisma.$consulta_insere_logPayload, S>

  type consulta_insere_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consulta_insere_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Consulta_insere_logCountAggregateInputType | true
    }

  export interface consulta_insere_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consulta_insere_log'], meta: { name: 'consulta_insere_log' } }
    /**
     * Find zero or one Consulta_insere_log that matches the filter.
     * @param {consulta_insere_logFindUniqueArgs} args - Arguments to find a Consulta_insere_log
     * @example
     * // Get one Consulta_insere_log
     * const consulta_insere_log = await prisma.consulta_insere_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consulta_insere_logFindUniqueArgs>(args: SelectSubset<T, consulta_insere_logFindUniqueArgs<ExtArgs>>): Prisma__consulta_insere_logClient<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consulta_insere_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consulta_insere_logFindUniqueOrThrowArgs} args - Arguments to find a Consulta_insere_log
     * @example
     * // Get one Consulta_insere_log
     * const consulta_insere_log = await prisma.consulta_insere_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consulta_insere_logFindUniqueOrThrowArgs>(args: SelectSubset<T, consulta_insere_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consulta_insere_logClient<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consulta_insere_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_insere_logFindFirstArgs} args - Arguments to find a Consulta_insere_log
     * @example
     * // Get one Consulta_insere_log
     * const consulta_insere_log = await prisma.consulta_insere_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consulta_insere_logFindFirstArgs>(args?: SelectSubset<T, consulta_insere_logFindFirstArgs<ExtArgs>>): Prisma__consulta_insere_logClient<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consulta_insere_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_insere_logFindFirstOrThrowArgs} args - Arguments to find a Consulta_insere_log
     * @example
     * // Get one Consulta_insere_log
     * const consulta_insere_log = await prisma.consulta_insere_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consulta_insere_logFindFirstOrThrowArgs>(args?: SelectSubset<T, consulta_insere_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__consulta_insere_logClient<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consulta_insere_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_insere_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consulta_insere_logs
     * const consulta_insere_logs = await prisma.consulta_insere_log.findMany()
     * 
     * // Get first 10 Consulta_insere_logs
     * const consulta_insere_logs = await prisma.consulta_insere_log.findMany({ take: 10 })
     * 
     * // Only select the `id_consulta_insere`
     * const consulta_insere_logWithId_consulta_insereOnly = await prisma.consulta_insere_log.findMany({ select: { id_consulta_insere: true } })
     * 
     */
    findMany<T extends consulta_insere_logFindManyArgs>(args?: SelectSubset<T, consulta_insere_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consulta_insere_log.
     * @param {consulta_insere_logCreateArgs} args - Arguments to create a Consulta_insere_log.
     * @example
     * // Create one Consulta_insere_log
     * const Consulta_insere_log = await prisma.consulta_insere_log.create({
     *   data: {
     *     // ... data to create a Consulta_insere_log
     *   }
     * })
     * 
     */
    create<T extends consulta_insere_logCreateArgs>(args: SelectSubset<T, consulta_insere_logCreateArgs<ExtArgs>>): Prisma__consulta_insere_logClient<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consulta_insere_logs.
     * @param {consulta_insere_logCreateManyArgs} args - Arguments to create many Consulta_insere_logs.
     * @example
     * // Create many Consulta_insere_logs
     * const consulta_insere_log = await prisma.consulta_insere_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consulta_insere_logCreateManyArgs>(args?: SelectSubset<T, consulta_insere_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consulta_insere_logs and returns the data saved in the database.
     * @param {consulta_insere_logCreateManyAndReturnArgs} args - Arguments to create many Consulta_insere_logs.
     * @example
     * // Create many Consulta_insere_logs
     * const consulta_insere_log = await prisma.consulta_insere_log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consulta_insere_logs and only return the `id_consulta_insere`
     * const consulta_insere_logWithId_consulta_insereOnly = await prisma.consulta_insere_log.createManyAndReturn({
     *   select: { id_consulta_insere: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends consulta_insere_logCreateManyAndReturnArgs>(args?: SelectSubset<T, consulta_insere_logCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consulta_insere_log.
     * @param {consulta_insere_logDeleteArgs} args - Arguments to delete one Consulta_insere_log.
     * @example
     * // Delete one Consulta_insere_log
     * const Consulta_insere_log = await prisma.consulta_insere_log.delete({
     *   where: {
     *     // ... filter to delete one Consulta_insere_log
     *   }
     * })
     * 
     */
    delete<T extends consulta_insere_logDeleteArgs>(args: SelectSubset<T, consulta_insere_logDeleteArgs<ExtArgs>>): Prisma__consulta_insere_logClient<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consulta_insere_log.
     * @param {consulta_insere_logUpdateArgs} args - Arguments to update one Consulta_insere_log.
     * @example
     * // Update one Consulta_insere_log
     * const consulta_insere_log = await prisma.consulta_insere_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consulta_insere_logUpdateArgs>(args: SelectSubset<T, consulta_insere_logUpdateArgs<ExtArgs>>): Prisma__consulta_insere_logClient<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consulta_insere_logs.
     * @param {consulta_insere_logDeleteManyArgs} args - Arguments to filter Consulta_insere_logs to delete.
     * @example
     * // Delete a few Consulta_insere_logs
     * const { count } = await prisma.consulta_insere_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consulta_insere_logDeleteManyArgs>(args?: SelectSubset<T, consulta_insere_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consulta_insere_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_insere_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consulta_insere_logs
     * const consulta_insere_log = await prisma.consulta_insere_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consulta_insere_logUpdateManyArgs>(args: SelectSubset<T, consulta_insere_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consulta_insere_logs and returns the data updated in the database.
     * @param {consulta_insere_logUpdateManyAndReturnArgs} args - Arguments to update many Consulta_insere_logs.
     * @example
     * // Update many Consulta_insere_logs
     * const consulta_insere_log = await prisma.consulta_insere_log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consulta_insere_logs and only return the `id_consulta_insere`
     * const consulta_insere_logWithId_consulta_insereOnly = await prisma.consulta_insere_log.updateManyAndReturn({
     *   select: { id_consulta_insere: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends consulta_insere_logUpdateManyAndReturnArgs>(args: SelectSubset<T, consulta_insere_logUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consulta_insere_log.
     * @param {consulta_insere_logUpsertArgs} args - Arguments to update or create a Consulta_insere_log.
     * @example
     * // Update or create a Consulta_insere_log
     * const consulta_insere_log = await prisma.consulta_insere_log.upsert({
     *   create: {
     *     // ... data to create a Consulta_insere_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consulta_insere_log we want to update
     *   }
     * })
     */
    upsert<T extends consulta_insere_logUpsertArgs>(args: SelectSubset<T, consulta_insere_logUpsertArgs<ExtArgs>>): Prisma__consulta_insere_logClient<$Result.GetResult<Prisma.$consulta_insere_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consulta_insere_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_insere_logCountArgs} args - Arguments to filter Consulta_insere_logs to count.
     * @example
     * // Count the number of Consulta_insere_logs
     * const count = await prisma.consulta_insere_log.count({
     *   where: {
     *     // ... the filter for the Consulta_insere_logs we want to count
     *   }
     * })
    **/
    count<T extends consulta_insere_logCountArgs>(
      args?: Subset<T, consulta_insere_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Consulta_insere_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consulta_insere_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Consulta_insere_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Consulta_insere_logAggregateArgs>(args: Subset<T, Consulta_insere_logAggregateArgs>): Prisma.PrismaPromise<GetConsulta_insere_logAggregateType<T>>

    /**
     * Group by Consulta_insere_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consulta_insere_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consulta_insere_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consulta_insere_logGroupByArgs['orderBy'] }
        : { orderBy?: consulta_insere_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consulta_insere_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsulta_insere_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consulta_insere_log model
   */
  readonly fields: consulta_insere_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consulta_insere_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consulta_insere_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consulta_insere_log model
   */
  interface consulta_insere_logFieldRefs {
    readonly id_consulta_insere: FieldRef<"consulta_insere_log", 'Int'>
    readonly id_user: FieldRef<"consulta_insere_log", 'Int'>
    readonly data_cadastrou: FieldRef<"consulta_insere_log", 'DateTime'>
    readonly debito: FieldRef<"consulta_insere_log", 'Int'>
    readonly fonte_propria: FieldRef<"consulta_insere_log", 'Int'>
    readonly consulta: FieldRef<"consulta_insere_log", 'String'>
    readonly id_dados_fisica: FieldRef<"consulta_insere_log", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * consulta_insere_log findUnique
   */
  export type consulta_insere_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * Filter, which consulta_insere_log to fetch.
     */
    where: consulta_insere_logWhereUniqueInput
  }

  /**
   * consulta_insere_log findUniqueOrThrow
   */
  export type consulta_insere_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * Filter, which consulta_insere_log to fetch.
     */
    where: consulta_insere_logWhereUniqueInput
  }

  /**
   * consulta_insere_log findFirst
   */
  export type consulta_insere_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * Filter, which consulta_insere_log to fetch.
     */
    where?: consulta_insere_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_insere_logs to fetch.
     */
    orderBy?: consulta_insere_logOrderByWithRelationInput | consulta_insere_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consulta_insere_logs.
     */
    cursor?: consulta_insere_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_insere_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_insere_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consulta_insere_logs.
     */
    distinct?: Consulta_insere_logScalarFieldEnum | Consulta_insere_logScalarFieldEnum[]
  }

  /**
   * consulta_insere_log findFirstOrThrow
   */
  export type consulta_insere_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * Filter, which consulta_insere_log to fetch.
     */
    where?: consulta_insere_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_insere_logs to fetch.
     */
    orderBy?: consulta_insere_logOrderByWithRelationInput | consulta_insere_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consulta_insere_logs.
     */
    cursor?: consulta_insere_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_insere_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_insere_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consulta_insere_logs.
     */
    distinct?: Consulta_insere_logScalarFieldEnum | Consulta_insere_logScalarFieldEnum[]
  }

  /**
   * consulta_insere_log findMany
   */
  export type consulta_insere_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * Filter, which consulta_insere_logs to fetch.
     */
    where?: consulta_insere_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consulta_insere_logs to fetch.
     */
    orderBy?: consulta_insere_logOrderByWithRelationInput | consulta_insere_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consulta_insere_logs.
     */
    cursor?: consulta_insere_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consulta_insere_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consulta_insere_logs.
     */
    skip?: number
    distinct?: Consulta_insere_logScalarFieldEnum | Consulta_insere_logScalarFieldEnum[]
  }

  /**
   * consulta_insere_log create
   */
  export type consulta_insere_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * The data needed to create a consulta_insere_log.
     */
    data: XOR<consulta_insere_logCreateInput, consulta_insere_logUncheckedCreateInput>
  }

  /**
   * consulta_insere_log createMany
   */
  export type consulta_insere_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consulta_insere_logs.
     */
    data: consulta_insere_logCreateManyInput | consulta_insere_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consulta_insere_log createManyAndReturn
   */
  export type consulta_insere_logCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * The data used to create many consulta_insere_logs.
     */
    data: consulta_insere_logCreateManyInput | consulta_insere_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consulta_insere_log update
   */
  export type consulta_insere_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * The data needed to update a consulta_insere_log.
     */
    data: XOR<consulta_insere_logUpdateInput, consulta_insere_logUncheckedUpdateInput>
    /**
     * Choose, which consulta_insere_log to update.
     */
    where: consulta_insere_logWhereUniqueInput
  }

  /**
   * consulta_insere_log updateMany
   */
  export type consulta_insere_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consulta_insere_logs.
     */
    data: XOR<consulta_insere_logUpdateManyMutationInput, consulta_insere_logUncheckedUpdateManyInput>
    /**
     * Filter which consulta_insere_logs to update
     */
    where?: consulta_insere_logWhereInput
    /**
     * Limit how many consulta_insere_logs to update.
     */
    limit?: number
  }

  /**
   * consulta_insere_log updateManyAndReturn
   */
  export type consulta_insere_logUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * The data used to update consulta_insere_logs.
     */
    data: XOR<consulta_insere_logUpdateManyMutationInput, consulta_insere_logUncheckedUpdateManyInput>
    /**
     * Filter which consulta_insere_logs to update
     */
    where?: consulta_insere_logWhereInput
    /**
     * Limit how many consulta_insere_logs to update.
     */
    limit?: number
  }

  /**
   * consulta_insere_log upsert
   */
  export type consulta_insere_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * The filter to search for the consulta_insere_log to update in case it exists.
     */
    where: consulta_insere_logWhereUniqueInput
    /**
     * In case the consulta_insere_log found by the `where` argument doesn't exist, create a new consulta_insere_log with this data.
     */
    create: XOR<consulta_insere_logCreateInput, consulta_insere_logUncheckedCreateInput>
    /**
     * In case the consulta_insere_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consulta_insere_logUpdateInput, consulta_insere_logUncheckedUpdateInput>
  }

  /**
   * consulta_insere_log delete
   */
  export type consulta_insere_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
    /**
     * Filter which consulta_insere_log to delete.
     */
    where: consulta_insere_logWhereUniqueInput
  }

  /**
   * consulta_insere_log deleteMany
   */
  export type consulta_insere_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consulta_insere_logs to delete
     */
    where?: consulta_insere_logWhereInput
    /**
     * Limit how many consulta_insere_logs to delete.
     */
    limit?: number
  }

  /**
   * consulta_insere_log without action
   */
  export type consulta_insere_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consulta_insere_log
     */
    select?: consulta_insere_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consulta_insere_log
     */
    omit?: consulta_insere_logOmit<ExtArgs> | null
  }


  /**
   * Model dados_fisica
   */

  export type AggregateDados_fisica = {
    _count: Dados_fisicaCountAggregateOutputType | null
    _avg: Dados_fisicaAvgAggregateOutputType | null
    _sum: Dados_fisicaSumAggregateOutputType | null
    _min: Dados_fisicaMinAggregateOutputType | null
    _max: Dados_fisicaMaxAggregateOutputType | null
  }

  export type Dados_fisicaAvgAggregateOutputType = {
    id: number | null
    celular_ddd: number | null
  }

  export type Dados_fisicaSumAggregateOutputType = {
    id: number | null
    celular_ddd: number | null
  }

  export type Dados_fisicaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    cpf: string | null
    tipo_end: string | null
    rua: string | null
    numero: string | null
    cidade: string | null
    uf: string | null
    cep: string | null
    morto: boolean | null
    celular_ddd: number | null
    celular_number: string | null
    connect_whats: Date | null
    rg: string | null
    bairro: string | null
    nome_mae: string | null
    data_aniversaio: Date | null
  }

  export type Dados_fisicaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    cpf: string | null
    tipo_end: string | null
    rua: string | null
    numero: string | null
    cidade: string | null
    uf: string | null
    cep: string | null
    morto: boolean | null
    celular_ddd: number | null
    celular_number: string | null
    connect_whats: Date | null
    rg: string | null
    bairro: string | null
    nome_mae: string | null
    data_aniversaio: Date | null
  }

  export type Dados_fisicaCountAggregateOutputType = {
    id: number
    nome: number
    cpf: number
    tipo_end: number
    rua: number
    numero: number
    cidade: number
    uf: number
    cep: number
    morto: number
    celular_ddd: number
    celular_number: number
    connect_whats: number
    rg: number
    bairro: number
    nome_mae: number
    data_aniversaio: number
    _all: number
  }


  export type Dados_fisicaAvgAggregateInputType = {
    id?: true
    celular_ddd?: true
  }

  export type Dados_fisicaSumAggregateInputType = {
    id?: true
    celular_ddd?: true
  }

  export type Dados_fisicaMinAggregateInputType = {
    id?: true
    nome?: true
    cpf?: true
    tipo_end?: true
    rua?: true
    numero?: true
    cidade?: true
    uf?: true
    cep?: true
    morto?: true
    celular_ddd?: true
    celular_number?: true
    connect_whats?: true
    rg?: true
    bairro?: true
    nome_mae?: true
    data_aniversaio?: true
  }

  export type Dados_fisicaMaxAggregateInputType = {
    id?: true
    nome?: true
    cpf?: true
    tipo_end?: true
    rua?: true
    numero?: true
    cidade?: true
    uf?: true
    cep?: true
    morto?: true
    celular_ddd?: true
    celular_number?: true
    connect_whats?: true
    rg?: true
    bairro?: true
    nome_mae?: true
    data_aniversaio?: true
  }

  export type Dados_fisicaCountAggregateInputType = {
    id?: true
    nome?: true
    cpf?: true
    tipo_end?: true
    rua?: true
    numero?: true
    cidade?: true
    uf?: true
    cep?: true
    morto?: true
    celular_ddd?: true
    celular_number?: true
    connect_whats?: true
    rg?: true
    bairro?: true
    nome_mae?: true
    data_aniversaio?: true
    _all?: true
  }

  export type Dados_fisicaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dados_fisica to aggregate.
     */
    where?: dados_fisicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dados_fisicas to fetch.
     */
    orderBy?: dados_fisicaOrderByWithRelationInput | dados_fisicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dados_fisicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dados_fisicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dados_fisicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dados_fisicas
    **/
    _count?: true | Dados_fisicaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Dados_fisicaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Dados_fisicaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dados_fisicaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dados_fisicaMaxAggregateInputType
  }

  export type GetDados_fisicaAggregateType<T extends Dados_fisicaAggregateArgs> = {
        [P in keyof T & keyof AggregateDados_fisica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDados_fisica[P]>
      : GetScalarType<T[P], AggregateDados_fisica[P]>
  }




  export type dados_fisicaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dados_fisicaWhereInput
    orderBy?: dados_fisicaOrderByWithAggregationInput | dados_fisicaOrderByWithAggregationInput[]
    by: Dados_fisicaScalarFieldEnum[] | Dados_fisicaScalarFieldEnum
    having?: dados_fisicaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dados_fisicaCountAggregateInputType | true
    _avg?: Dados_fisicaAvgAggregateInputType
    _sum?: Dados_fisicaSumAggregateInputType
    _min?: Dados_fisicaMinAggregateInputType
    _max?: Dados_fisicaMaxAggregateInputType
  }

  export type Dados_fisicaGroupByOutputType = {
    id: number
    nome: string
    cpf: string
    tipo_end: string | null
    rua: string | null
    numero: string | null
    cidade: string | null
    uf: string | null
    cep: string | null
    morto: boolean
    celular_ddd: number | null
    celular_number: string | null
    connect_whats: Date | null
    rg: string | null
    bairro: string | null
    nome_mae: string | null
    data_aniversaio: Date | null
    _count: Dados_fisicaCountAggregateOutputType | null
    _avg: Dados_fisicaAvgAggregateOutputType | null
    _sum: Dados_fisicaSumAggregateOutputType | null
    _min: Dados_fisicaMinAggregateOutputType | null
    _max: Dados_fisicaMaxAggregateOutputType | null
  }

  type GetDados_fisicaGroupByPayload<T extends dados_fisicaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dados_fisicaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dados_fisicaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dados_fisicaGroupByOutputType[P]>
            : GetScalarType<T[P], Dados_fisicaGroupByOutputType[P]>
        }
      >
    >


  export type dados_fisicaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cpf?: boolean
    tipo_end?: boolean
    rua?: boolean
    numero?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    morto?: boolean
    celular_ddd?: boolean
    celular_number?: boolean
    connect_whats?: boolean
    rg?: boolean
    bairro?: boolean
    nome_mae?: boolean
    data_aniversaio?: boolean
  }, ExtArgs["result"]["dados_fisica"]>

  export type dados_fisicaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cpf?: boolean
    tipo_end?: boolean
    rua?: boolean
    numero?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    morto?: boolean
    celular_ddd?: boolean
    celular_number?: boolean
    connect_whats?: boolean
    rg?: boolean
    bairro?: boolean
    nome_mae?: boolean
    data_aniversaio?: boolean
  }, ExtArgs["result"]["dados_fisica"]>

  export type dados_fisicaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cpf?: boolean
    tipo_end?: boolean
    rua?: boolean
    numero?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    morto?: boolean
    celular_ddd?: boolean
    celular_number?: boolean
    connect_whats?: boolean
    rg?: boolean
    bairro?: boolean
    nome_mae?: boolean
    data_aniversaio?: boolean
  }, ExtArgs["result"]["dados_fisica"]>

  export type dados_fisicaSelectScalar = {
    id?: boolean
    nome?: boolean
    cpf?: boolean
    tipo_end?: boolean
    rua?: boolean
    numero?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    morto?: boolean
    celular_ddd?: boolean
    celular_number?: boolean
    connect_whats?: boolean
    rg?: boolean
    bairro?: boolean
    nome_mae?: boolean
    data_aniversaio?: boolean
  }

  export type dados_fisicaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "cpf" | "tipo_end" | "rua" | "numero" | "cidade" | "uf" | "cep" | "morto" | "celular_ddd" | "celular_number" | "connect_whats" | "rg" | "bairro" | "nome_mae" | "data_aniversaio", ExtArgs["result"]["dados_fisica"]>

  export type $dados_fisicaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dados_fisica"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      cpf: string
      tipo_end: string | null
      rua: string | null
      numero: string | null
      cidade: string | null
      uf: string | null
      cep: string | null
      morto: boolean
      celular_ddd: number | null
      celular_number: string | null
      connect_whats: Date | null
      rg: string | null
      bairro: string | null
      nome_mae: string | null
      data_aniversaio: Date | null
    }, ExtArgs["result"]["dados_fisica"]>
    composites: {}
  }

  type dados_fisicaGetPayload<S extends boolean | null | undefined | dados_fisicaDefaultArgs> = $Result.GetResult<Prisma.$dados_fisicaPayload, S>

  type dados_fisicaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<dados_fisicaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Dados_fisicaCountAggregateInputType | true
    }

  export interface dados_fisicaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dados_fisica'], meta: { name: 'dados_fisica' } }
    /**
     * Find zero or one Dados_fisica that matches the filter.
     * @param {dados_fisicaFindUniqueArgs} args - Arguments to find a Dados_fisica
     * @example
     * // Get one Dados_fisica
     * const dados_fisica = await prisma.dados_fisica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dados_fisicaFindUniqueArgs>(args: SelectSubset<T, dados_fisicaFindUniqueArgs<ExtArgs>>): Prisma__dados_fisicaClient<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dados_fisica that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {dados_fisicaFindUniqueOrThrowArgs} args - Arguments to find a Dados_fisica
     * @example
     * // Get one Dados_fisica
     * const dados_fisica = await prisma.dados_fisica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dados_fisicaFindUniqueOrThrowArgs>(args: SelectSubset<T, dados_fisicaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dados_fisicaClient<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dados_fisica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dados_fisicaFindFirstArgs} args - Arguments to find a Dados_fisica
     * @example
     * // Get one Dados_fisica
     * const dados_fisica = await prisma.dados_fisica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dados_fisicaFindFirstArgs>(args?: SelectSubset<T, dados_fisicaFindFirstArgs<ExtArgs>>): Prisma__dados_fisicaClient<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dados_fisica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dados_fisicaFindFirstOrThrowArgs} args - Arguments to find a Dados_fisica
     * @example
     * // Get one Dados_fisica
     * const dados_fisica = await prisma.dados_fisica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dados_fisicaFindFirstOrThrowArgs>(args?: SelectSubset<T, dados_fisicaFindFirstOrThrowArgs<ExtArgs>>): Prisma__dados_fisicaClient<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dados_fisicas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dados_fisicaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dados_fisicas
     * const dados_fisicas = await prisma.dados_fisica.findMany()
     * 
     * // Get first 10 Dados_fisicas
     * const dados_fisicas = await prisma.dados_fisica.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dados_fisicaWithIdOnly = await prisma.dados_fisica.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dados_fisicaFindManyArgs>(args?: SelectSubset<T, dados_fisicaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dados_fisica.
     * @param {dados_fisicaCreateArgs} args - Arguments to create a Dados_fisica.
     * @example
     * // Create one Dados_fisica
     * const Dados_fisica = await prisma.dados_fisica.create({
     *   data: {
     *     // ... data to create a Dados_fisica
     *   }
     * })
     * 
     */
    create<T extends dados_fisicaCreateArgs>(args: SelectSubset<T, dados_fisicaCreateArgs<ExtArgs>>): Prisma__dados_fisicaClient<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dados_fisicas.
     * @param {dados_fisicaCreateManyArgs} args - Arguments to create many Dados_fisicas.
     * @example
     * // Create many Dados_fisicas
     * const dados_fisica = await prisma.dados_fisica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dados_fisicaCreateManyArgs>(args?: SelectSubset<T, dados_fisicaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dados_fisicas and returns the data saved in the database.
     * @param {dados_fisicaCreateManyAndReturnArgs} args - Arguments to create many Dados_fisicas.
     * @example
     * // Create many Dados_fisicas
     * const dados_fisica = await prisma.dados_fisica.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dados_fisicas and only return the `id`
     * const dados_fisicaWithIdOnly = await prisma.dados_fisica.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends dados_fisicaCreateManyAndReturnArgs>(args?: SelectSubset<T, dados_fisicaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dados_fisica.
     * @param {dados_fisicaDeleteArgs} args - Arguments to delete one Dados_fisica.
     * @example
     * // Delete one Dados_fisica
     * const Dados_fisica = await prisma.dados_fisica.delete({
     *   where: {
     *     // ... filter to delete one Dados_fisica
     *   }
     * })
     * 
     */
    delete<T extends dados_fisicaDeleteArgs>(args: SelectSubset<T, dados_fisicaDeleteArgs<ExtArgs>>): Prisma__dados_fisicaClient<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dados_fisica.
     * @param {dados_fisicaUpdateArgs} args - Arguments to update one Dados_fisica.
     * @example
     * // Update one Dados_fisica
     * const dados_fisica = await prisma.dados_fisica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dados_fisicaUpdateArgs>(args: SelectSubset<T, dados_fisicaUpdateArgs<ExtArgs>>): Prisma__dados_fisicaClient<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dados_fisicas.
     * @param {dados_fisicaDeleteManyArgs} args - Arguments to filter Dados_fisicas to delete.
     * @example
     * // Delete a few Dados_fisicas
     * const { count } = await prisma.dados_fisica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dados_fisicaDeleteManyArgs>(args?: SelectSubset<T, dados_fisicaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dados_fisicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dados_fisicaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dados_fisicas
     * const dados_fisica = await prisma.dados_fisica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dados_fisicaUpdateManyArgs>(args: SelectSubset<T, dados_fisicaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dados_fisicas and returns the data updated in the database.
     * @param {dados_fisicaUpdateManyAndReturnArgs} args - Arguments to update many Dados_fisicas.
     * @example
     * // Update many Dados_fisicas
     * const dados_fisica = await prisma.dados_fisica.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dados_fisicas and only return the `id`
     * const dados_fisicaWithIdOnly = await prisma.dados_fisica.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends dados_fisicaUpdateManyAndReturnArgs>(args: SelectSubset<T, dados_fisicaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dados_fisica.
     * @param {dados_fisicaUpsertArgs} args - Arguments to update or create a Dados_fisica.
     * @example
     * // Update or create a Dados_fisica
     * const dados_fisica = await prisma.dados_fisica.upsert({
     *   create: {
     *     // ... data to create a Dados_fisica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dados_fisica we want to update
     *   }
     * })
     */
    upsert<T extends dados_fisicaUpsertArgs>(args: SelectSubset<T, dados_fisicaUpsertArgs<ExtArgs>>): Prisma__dados_fisicaClient<$Result.GetResult<Prisma.$dados_fisicaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dados_fisicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dados_fisicaCountArgs} args - Arguments to filter Dados_fisicas to count.
     * @example
     * // Count the number of Dados_fisicas
     * const count = await prisma.dados_fisica.count({
     *   where: {
     *     // ... the filter for the Dados_fisicas we want to count
     *   }
     * })
    **/
    count<T extends dados_fisicaCountArgs>(
      args?: Subset<T, dados_fisicaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dados_fisicaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dados_fisica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dados_fisicaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dados_fisicaAggregateArgs>(args: Subset<T, Dados_fisicaAggregateArgs>): Prisma.PrismaPromise<GetDados_fisicaAggregateType<T>>

    /**
     * Group by Dados_fisica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dados_fisicaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dados_fisicaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dados_fisicaGroupByArgs['orderBy'] }
        : { orderBy?: dados_fisicaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dados_fisicaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDados_fisicaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dados_fisica model
   */
  readonly fields: dados_fisicaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dados_fisica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dados_fisicaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dados_fisica model
   */
  interface dados_fisicaFieldRefs {
    readonly id: FieldRef<"dados_fisica", 'Int'>
    readonly nome: FieldRef<"dados_fisica", 'String'>
    readonly cpf: FieldRef<"dados_fisica", 'String'>
    readonly tipo_end: FieldRef<"dados_fisica", 'String'>
    readonly rua: FieldRef<"dados_fisica", 'String'>
    readonly numero: FieldRef<"dados_fisica", 'String'>
    readonly cidade: FieldRef<"dados_fisica", 'String'>
    readonly uf: FieldRef<"dados_fisica", 'String'>
    readonly cep: FieldRef<"dados_fisica", 'String'>
    readonly morto: FieldRef<"dados_fisica", 'Boolean'>
    readonly celular_ddd: FieldRef<"dados_fisica", 'Int'>
    readonly celular_number: FieldRef<"dados_fisica", 'String'>
    readonly connect_whats: FieldRef<"dados_fisica", 'DateTime'>
    readonly rg: FieldRef<"dados_fisica", 'String'>
    readonly bairro: FieldRef<"dados_fisica", 'String'>
    readonly nome_mae: FieldRef<"dados_fisica", 'String'>
    readonly data_aniversaio: FieldRef<"dados_fisica", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dados_fisica findUnique
   */
  export type dados_fisicaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * Filter, which dados_fisica to fetch.
     */
    where: dados_fisicaWhereUniqueInput
  }

  /**
   * dados_fisica findUniqueOrThrow
   */
  export type dados_fisicaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * Filter, which dados_fisica to fetch.
     */
    where: dados_fisicaWhereUniqueInput
  }

  /**
   * dados_fisica findFirst
   */
  export type dados_fisicaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * Filter, which dados_fisica to fetch.
     */
    where?: dados_fisicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dados_fisicas to fetch.
     */
    orderBy?: dados_fisicaOrderByWithRelationInput | dados_fisicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dados_fisicas.
     */
    cursor?: dados_fisicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dados_fisicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dados_fisicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dados_fisicas.
     */
    distinct?: Dados_fisicaScalarFieldEnum | Dados_fisicaScalarFieldEnum[]
  }

  /**
   * dados_fisica findFirstOrThrow
   */
  export type dados_fisicaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * Filter, which dados_fisica to fetch.
     */
    where?: dados_fisicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dados_fisicas to fetch.
     */
    orderBy?: dados_fisicaOrderByWithRelationInput | dados_fisicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dados_fisicas.
     */
    cursor?: dados_fisicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dados_fisicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dados_fisicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dados_fisicas.
     */
    distinct?: Dados_fisicaScalarFieldEnum | Dados_fisicaScalarFieldEnum[]
  }

  /**
   * dados_fisica findMany
   */
  export type dados_fisicaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * Filter, which dados_fisicas to fetch.
     */
    where?: dados_fisicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dados_fisicas to fetch.
     */
    orderBy?: dados_fisicaOrderByWithRelationInput | dados_fisicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dados_fisicas.
     */
    cursor?: dados_fisicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dados_fisicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dados_fisicas.
     */
    skip?: number
    distinct?: Dados_fisicaScalarFieldEnum | Dados_fisicaScalarFieldEnum[]
  }

  /**
   * dados_fisica create
   */
  export type dados_fisicaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * The data needed to create a dados_fisica.
     */
    data: XOR<dados_fisicaCreateInput, dados_fisicaUncheckedCreateInput>
  }

  /**
   * dados_fisica createMany
   */
  export type dados_fisicaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dados_fisicas.
     */
    data: dados_fisicaCreateManyInput | dados_fisicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dados_fisica createManyAndReturn
   */
  export type dados_fisicaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * The data used to create many dados_fisicas.
     */
    data: dados_fisicaCreateManyInput | dados_fisicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dados_fisica update
   */
  export type dados_fisicaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * The data needed to update a dados_fisica.
     */
    data: XOR<dados_fisicaUpdateInput, dados_fisicaUncheckedUpdateInput>
    /**
     * Choose, which dados_fisica to update.
     */
    where: dados_fisicaWhereUniqueInput
  }

  /**
   * dados_fisica updateMany
   */
  export type dados_fisicaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dados_fisicas.
     */
    data: XOR<dados_fisicaUpdateManyMutationInput, dados_fisicaUncheckedUpdateManyInput>
    /**
     * Filter which dados_fisicas to update
     */
    where?: dados_fisicaWhereInput
    /**
     * Limit how many dados_fisicas to update.
     */
    limit?: number
  }

  /**
   * dados_fisica updateManyAndReturn
   */
  export type dados_fisicaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * The data used to update dados_fisicas.
     */
    data: XOR<dados_fisicaUpdateManyMutationInput, dados_fisicaUncheckedUpdateManyInput>
    /**
     * Filter which dados_fisicas to update
     */
    where?: dados_fisicaWhereInput
    /**
     * Limit how many dados_fisicas to update.
     */
    limit?: number
  }

  /**
   * dados_fisica upsert
   */
  export type dados_fisicaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * The filter to search for the dados_fisica to update in case it exists.
     */
    where: dados_fisicaWhereUniqueInput
    /**
     * In case the dados_fisica found by the `where` argument doesn't exist, create a new dados_fisica with this data.
     */
    create: XOR<dados_fisicaCreateInput, dados_fisicaUncheckedCreateInput>
    /**
     * In case the dados_fisica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dados_fisicaUpdateInput, dados_fisicaUncheckedUpdateInput>
  }

  /**
   * dados_fisica delete
   */
  export type dados_fisicaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
    /**
     * Filter which dados_fisica to delete.
     */
    where: dados_fisicaWhereUniqueInput
  }

  /**
   * dados_fisica deleteMany
   */
  export type dados_fisicaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dados_fisicas to delete
     */
    where?: dados_fisicaWhereInput
    /**
     * Limit how many dados_fisicas to delete.
     */
    limit?: number
  }

  /**
   * dados_fisica without action
   */
  export type dados_fisicaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dados_fisica
     */
    select?: dados_fisicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dados_fisica
     */
    omit?: dados_fisicaOmit<ExtArgs> | null
  }


  /**
   * Model crm_cliente
   */

  export type AggregateCrm_cliente = {
    _count: Crm_clienteCountAggregateOutputType | null
    _avg: Crm_clienteAvgAggregateOutputType | null
    _sum: Crm_clienteSumAggregateOutputType | null
    _min: Crm_clienteMinAggregateOutputType | null
    _max: Crm_clienteMaxAggregateOutputType | null
  }

  export type Crm_clienteAvgAggregateOutputType = {
    VALOR_PAGO: Decimal | null
    VALOR_TIKET: Decimal | null
  }

  export type Crm_clienteSumAggregateOutputType = {
    VALOR_PAGO: Decimal | null
    VALOR_TIKET: Decimal | null
  }

  export type Crm_clienteMinAggregateOutputType = {
    CODIGO_CLIENTE: string | null
    CPF: string | null
    DATA_VENDA: Date | null
    TICKET: string | null
    CODIGO_FILIAL: string | null
    VALOR_PAGO: Decimal | null
    VALOR_TIKET: Decimal | null
    ULTIMA_COMPRA: Date | null
    NOME_SOCIAL: string | null
    CLIENTE_VAREJO: string | null
    ANIVERSARIO: Date | null
    EMAIL: string | null
    DDD_CELULAR: string | null
    CELULAR: string | null
    DATA_CADASTROU: string | null
  }

  export type Crm_clienteMaxAggregateOutputType = {
    CODIGO_CLIENTE: string | null
    CPF: string | null
    DATA_VENDA: Date | null
    TICKET: string | null
    CODIGO_FILIAL: string | null
    VALOR_PAGO: Decimal | null
    VALOR_TIKET: Decimal | null
    ULTIMA_COMPRA: Date | null
    NOME_SOCIAL: string | null
    CLIENTE_VAREJO: string | null
    ANIVERSARIO: Date | null
    EMAIL: string | null
    DDD_CELULAR: string | null
    CELULAR: string | null
    DATA_CADASTROU: string | null
  }

  export type Crm_clienteCountAggregateOutputType = {
    CODIGO_CLIENTE: number
    CPF: number
    DATA_VENDA: number
    TICKET: number
    CODIGO_FILIAL: number
    VALOR_PAGO: number
    VALOR_TIKET: number
    ULTIMA_COMPRA: number
    NOME_SOCIAL: number
    CLIENTE_VAREJO: number
    ANIVERSARIO: number
    EMAIL: number
    DDD_CELULAR: number
    CELULAR: number
    DATA_CADASTROU: number
    _all: number
  }


  export type Crm_clienteAvgAggregateInputType = {
    VALOR_PAGO?: true
    VALOR_TIKET?: true
  }

  export type Crm_clienteSumAggregateInputType = {
    VALOR_PAGO?: true
    VALOR_TIKET?: true
  }

  export type Crm_clienteMinAggregateInputType = {
    CODIGO_CLIENTE?: true
    CPF?: true
    DATA_VENDA?: true
    TICKET?: true
    CODIGO_FILIAL?: true
    VALOR_PAGO?: true
    VALOR_TIKET?: true
    ULTIMA_COMPRA?: true
    NOME_SOCIAL?: true
    CLIENTE_VAREJO?: true
    ANIVERSARIO?: true
    EMAIL?: true
    DDD_CELULAR?: true
    CELULAR?: true
    DATA_CADASTROU?: true
  }

  export type Crm_clienteMaxAggregateInputType = {
    CODIGO_CLIENTE?: true
    CPF?: true
    DATA_VENDA?: true
    TICKET?: true
    CODIGO_FILIAL?: true
    VALOR_PAGO?: true
    VALOR_TIKET?: true
    ULTIMA_COMPRA?: true
    NOME_SOCIAL?: true
    CLIENTE_VAREJO?: true
    ANIVERSARIO?: true
    EMAIL?: true
    DDD_CELULAR?: true
    CELULAR?: true
    DATA_CADASTROU?: true
  }

  export type Crm_clienteCountAggregateInputType = {
    CODIGO_CLIENTE?: true
    CPF?: true
    DATA_VENDA?: true
    TICKET?: true
    CODIGO_FILIAL?: true
    VALOR_PAGO?: true
    VALOR_TIKET?: true
    ULTIMA_COMPRA?: true
    NOME_SOCIAL?: true
    CLIENTE_VAREJO?: true
    ANIVERSARIO?: true
    EMAIL?: true
    DDD_CELULAR?: true
    CELULAR?: true
    DATA_CADASTROU?: true
    _all?: true
  }

  export type Crm_clienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crm_cliente to aggregate.
     */
    where?: crm_clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crm_clientes to fetch.
     */
    orderBy?: crm_clienteOrderByWithRelationInput | crm_clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crm_clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crm_clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crm_clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crm_clientes
    **/
    _count?: true | Crm_clienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Crm_clienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Crm_clienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Crm_clienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Crm_clienteMaxAggregateInputType
  }

  export type GetCrm_clienteAggregateType<T extends Crm_clienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCrm_cliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrm_cliente[P]>
      : GetScalarType<T[P], AggregateCrm_cliente[P]>
  }




  export type crm_clienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: crm_clienteWhereInput
    orderBy?: crm_clienteOrderByWithAggregationInput | crm_clienteOrderByWithAggregationInput[]
    by: Crm_clienteScalarFieldEnum[] | Crm_clienteScalarFieldEnum
    having?: crm_clienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Crm_clienteCountAggregateInputType | true
    _avg?: Crm_clienteAvgAggregateInputType
    _sum?: Crm_clienteSumAggregateInputType
    _min?: Crm_clienteMinAggregateInputType
    _max?: Crm_clienteMaxAggregateInputType
  }

  export type Crm_clienteGroupByOutputType = {
    CODIGO_CLIENTE: string
    CPF: string
    DATA_VENDA: Date
    TICKET: string
    CODIGO_FILIAL: string
    VALOR_PAGO: Decimal
    VALOR_TIKET: Decimal
    ULTIMA_COMPRA: Date
    NOME_SOCIAL: string
    CLIENTE_VAREJO: string
    ANIVERSARIO: Date
    EMAIL: string
    DDD_CELULAR: string
    CELULAR: string
    DATA_CADASTROU: string
    _count: Crm_clienteCountAggregateOutputType | null
    _avg: Crm_clienteAvgAggregateOutputType | null
    _sum: Crm_clienteSumAggregateOutputType | null
    _min: Crm_clienteMinAggregateOutputType | null
    _max: Crm_clienteMaxAggregateOutputType | null
  }

  type GetCrm_clienteGroupByPayload<T extends crm_clienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Crm_clienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Crm_clienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Crm_clienteGroupByOutputType[P]>
            : GetScalarType<T[P], Crm_clienteGroupByOutputType[P]>
        }
      >
    >


  export type crm_clienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CODIGO_CLIENTE?: boolean
    CPF?: boolean
    DATA_VENDA?: boolean
    TICKET?: boolean
    CODIGO_FILIAL?: boolean
    VALOR_PAGO?: boolean
    VALOR_TIKET?: boolean
    ULTIMA_COMPRA?: boolean
    NOME_SOCIAL?: boolean
    CLIENTE_VAREJO?: boolean
    ANIVERSARIO?: boolean
    EMAIL?: boolean
    DDD_CELULAR?: boolean
    CELULAR?: boolean
    DATA_CADASTROU?: boolean
  }, ExtArgs["result"]["crm_cliente"]>

  export type crm_clienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CODIGO_CLIENTE?: boolean
    CPF?: boolean
    DATA_VENDA?: boolean
    TICKET?: boolean
    CODIGO_FILIAL?: boolean
    VALOR_PAGO?: boolean
    VALOR_TIKET?: boolean
    ULTIMA_COMPRA?: boolean
    NOME_SOCIAL?: boolean
    CLIENTE_VAREJO?: boolean
    ANIVERSARIO?: boolean
    EMAIL?: boolean
    DDD_CELULAR?: boolean
    CELULAR?: boolean
    DATA_CADASTROU?: boolean
  }, ExtArgs["result"]["crm_cliente"]>

  export type crm_clienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CODIGO_CLIENTE?: boolean
    CPF?: boolean
    DATA_VENDA?: boolean
    TICKET?: boolean
    CODIGO_FILIAL?: boolean
    VALOR_PAGO?: boolean
    VALOR_TIKET?: boolean
    ULTIMA_COMPRA?: boolean
    NOME_SOCIAL?: boolean
    CLIENTE_VAREJO?: boolean
    ANIVERSARIO?: boolean
    EMAIL?: boolean
    DDD_CELULAR?: boolean
    CELULAR?: boolean
    DATA_CADASTROU?: boolean
  }, ExtArgs["result"]["crm_cliente"]>

  export type crm_clienteSelectScalar = {
    CODIGO_CLIENTE?: boolean
    CPF?: boolean
    DATA_VENDA?: boolean
    TICKET?: boolean
    CODIGO_FILIAL?: boolean
    VALOR_PAGO?: boolean
    VALOR_TIKET?: boolean
    ULTIMA_COMPRA?: boolean
    NOME_SOCIAL?: boolean
    CLIENTE_VAREJO?: boolean
    ANIVERSARIO?: boolean
    EMAIL?: boolean
    DDD_CELULAR?: boolean
    CELULAR?: boolean
    DATA_CADASTROU?: boolean
  }

  export type crm_clienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"CODIGO_CLIENTE" | "CPF" | "DATA_VENDA" | "TICKET" | "CODIGO_FILIAL" | "VALOR_PAGO" | "VALOR_TIKET" | "ULTIMA_COMPRA" | "NOME_SOCIAL" | "CLIENTE_VAREJO" | "ANIVERSARIO" | "EMAIL" | "DDD_CELULAR" | "CELULAR" | "DATA_CADASTROU", ExtArgs["result"]["crm_cliente"]>

  export type $crm_clientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "crm_cliente"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CODIGO_CLIENTE: string
      CPF: string
      DATA_VENDA: Date
      TICKET: string
      CODIGO_FILIAL: string
      VALOR_PAGO: Prisma.Decimal
      VALOR_TIKET: Prisma.Decimal
      ULTIMA_COMPRA: Date
      NOME_SOCIAL: string
      CLIENTE_VAREJO: string
      ANIVERSARIO: Date
      EMAIL: string
      DDD_CELULAR: string
      CELULAR: string
      DATA_CADASTROU: string
    }, ExtArgs["result"]["crm_cliente"]>
    composites: {}
  }

  type crm_clienteGetPayload<S extends boolean | null | undefined | crm_clienteDefaultArgs> = $Result.GetResult<Prisma.$crm_clientePayload, S>

  type crm_clienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<crm_clienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Crm_clienteCountAggregateInputType | true
    }

  export interface crm_clienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crm_cliente'], meta: { name: 'crm_cliente' } }
    /**
     * Find zero or one Crm_cliente that matches the filter.
     * @param {crm_clienteFindUniqueArgs} args - Arguments to find a Crm_cliente
     * @example
     * // Get one Crm_cliente
     * const crm_cliente = await prisma.crm_cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends crm_clienteFindUniqueArgs>(args: SelectSubset<T, crm_clienteFindUniqueArgs<ExtArgs>>): Prisma__crm_clienteClient<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Crm_cliente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {crm_clienteFindUniqueOrThrowArgs} args - Arguments to find a Crm_cliente
     * @example
     * // Get one Crm_cliente
     * const crm_cliente = await prisma.crm_cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends crm_clienteFindUniqueOrThrowArgs>(args: SelectSubset<T, crm_clienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__crm_clienteClient<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crm_cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crm_clienteFindFirstArgs} args - Arguments to find a Crm_cliente
     * @example
     * // Get one Crm_cliente
     * const crm_cliente = await prisma.crm_cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends crm_clienteFindFirstArgs>(args?: SelectSubset<T, crm_clienteFindFirstArgs<ExtArgs>>): Prisma__crm_clienteClient<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crm_cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crm_clienteFindFirstOrThrowArgs} args - Arguments to find a Crm_cliente
     * @example
     * // Get one Crm_cliente
     * const crm_cliente = await prisma.crm_cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends crm_clienteFindFirstOrThrowArgs>(args?: SelectSubset<T, crm_clienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__crm_clienteClient<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crm_clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crm_clienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crm_clientes
     * const crm_clientes = await prisma.crm_cliente.findMany()
     * 
     * // Get first 10 Crm_clientes
     * const crm_clientes = await prisma.crm_cliente.findMany({ take: 10 })
     * 
     * // Only select the `CODIGO_CLIENTE`
     * const crm_clienteWithCODIGO_CLIENTEOnly = await prisma.crm_cliente.findMany({ select: { CODIGO_CLIENTE: true } })
     * 
     */
    findMany<T extends crm_clienteFindManyArgs>(args?: SelectSubset<T, crm_clienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Crm_cliente.
     * @param {crm_clienteCreateArgs} args - Arguments to create a Crm_cliente.
     * @example
     * // Create one Crm_cliente
     * const Crm_cliente = await prisma.crm_cliente.create({
     *   data: {
     *     // ... data to create a Crm_cliente
     *   }
     * })
     * 
     */
    create<T extends crm_clienteCreateArgs>(args: SelectSubset<T, crm_clienteCreateArgs<ExtArgs>>): Prisma__crm_clienteClient<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Crm_clientes.
     * @param {crm_clienteCreateManyArgs} args - Arguments to create many Crm_clientes.
     * @example
     * // Create many Crm_clientes
     * const crm_cliente = await prisma.crm_cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends crm_clienteCreateManyArgs>(args?: SelectSubset<T, crm_clienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crm_clientes and returns the data saved in the database.
     * @param {crm_clienteCreateManyAndReturnArgs} args - Arguments to create many Crm_clientes.
     * @example
     * // Create many Crm_clientes
     * const crm_cliente = await prisma.crm_cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crm_clientes and only return the `CODIGO_CLIENTE`
     * const crm_clienteWithCODIGO_CLIENTEOnly = await prisma.crm_cliente.createManyAndReturn({
     *   select: { CODIGO_CLIENTE: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends crm_clienteCreateManyAndReturnArgs>(args?: SelectSubset<T, crm_clienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Crm_cliente.
     * @param {crm_clienteDeleteArgs} args - Arguments to delete one Crm_cliente.
     * @example
     * // Delete one Crm_cliente
     * const Crm_cliente = await prisma.crm_cliente.delete({
     *   where: {
     *     // ... filter to delete one Crm_cliente
     *   }
     * })
     * 
     */
    delete<T extends crm_clienteDeleteArgs>(args: SelectSubset<T, crm_clienteDeleteArgs<ExtArgs>>): Prisma__crm_clienteClient<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Crm_cliente.
     * @param {crm_clienteUpdateArgs} args - Arguments to update one Crm_cliente.
     * @example
     * // Update one Crm_cliente
     * const crm_cliente = await prisma.crm_cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends crm_clienteUpdateArgs>(args: SelectSubset<T, crm_clienteUpdateArgs<ExtArgs>>): Prisma__crm_clienteClient<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Crm_clientes.
     * @param {crm_clienteDeleteManyArgs} args - Arguments to filter Crm_clientes to delete.
     * @example
     * // Delete a few Crm_clientes
     * const { count } = await prisma.crm_cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends crm_clienteDeleteManyArgs>(args?: SelectSubset<T, crm_clienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crm_clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crm_clienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crm_clientes
     * const crm_cliente = await prisma.crm_cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends crm_clienteUpdateManyArgs>(args: SelectSubset<T, crm_clienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crm_clientes and returns the data updated in the database.
     * @param {crm_clienteUpdateManyAndReturnArgs} args - Arguments to update many Crm_clientes.
     * @example
     * // Update many Crm_clientes
     * const crm_cliente = await prisma.crm_cliente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Crm_clientes and only return the `CODIGO_CLIENTE`
     * const crm_clienteWithCODIGO_CLIENTEOnly = await prisma.crm_cliente.updateManyAndReturn({
     *   select: { CODIGO_CLIENTE: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends crm_clienteUpdateManyAndReturnArgs>(args: SelectSubset<T, crm_clienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Crm_cliente.
     * @param {crm_clienteUpsertArgs} args - Arguments to update or create a Crm_cliente.
     * @example
     * // Update or create a Crm_cliente
     * const crm_cliente = await prisma.crm_cliente.upsert({
     *   create: {
     *     // ... data to create a Crm_cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crm_cliente we want to update
     *   }
     * })
     */
    upsert<T extends crm_clienteUpsertArgs>(args: SelectSubset<T, crm_clienteUpsertArgs<ExtArgs>>): Prisma__crm_clienteClient<$Result.GetResult<Prisma.$crm_clientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Crm_clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crm_clienteCountArgs} args - Arguments to filter Crm_clientes to count.
     * @example
     * // Count the number of Crm_clientes
     * const count = await prisma.crm_cliente.count({
     *   where: {
     *     // ... the filter for the Crm_clientes we want to count
     *   }
     * })
    **/
    count<T extends crm_clienteCountArgs>(
      args?: Subset<T, crm_clienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Crm_clienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crm_cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Crm_clienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Crm_clienteAggregateArgs>(args: Subset<T, Crm_clienteAggregateArgs>): Prisma.PrismaPromise<GetCrm_clienteAggregateType<T>>

    /**
     * Group by Crm_cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crm_clienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crm_clienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crm_clienteGroupByArgs['orderBy'] }
        : { orderBy?: crm_clienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crm_clienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrm_clienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crm_cliente model
   */
  readonly fields: crm_clienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crm_cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crm_clienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the crm_cliente model
   */
  interface crm_clienteFieldRefs {
    readonly CODIGO_CLIENTE: FieldRef<"crm_cliente", 'String'>
    readonly CPF: FieldRef<"crm_cliente", 'String'>
    readonly DATA_VENDA: FieldRef<"crm_cliente", 'DateTime'>
    readonly TICKET: FieldRef<"crm_cliente", 'String'>
    readonly CODIGO_FILIAL: FieldRef<"crm_cliente", 'String'>
    readonly VALOR_PAGO: FieldRef<"crm_cliente", 'Decimal'>
    readonly VALOR_TIKET: FieldRef<"crm_cliente", 'Decimal'>
    readonly ULTIMA_COMPRA: FieldRef<"crm_cliente", 'DateTime'>
    readonly NOME_SOCIAL: FieldRef<"crm_cliente", 'String'>
    readonly CLIENTE_VAREJO: FieldRef<"crm_cliente", 'String'>
    readonly ANIVERSARIO: FieldRef<"crm_cliente", 'DateTime'>
    readonly EMAIL: FieldRef<"crm_cliente", 'String'>
    readonly DDD_CELULAR: FieldRef<"crm_cliente", 'String'>
    readonly CELULAR: FieldRef<"crm_cliente", 'String'>
    readonly DATA_CADASTROU: FieldRef<"crm_cliente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * crm_cliente findUnique
   */
  export type crm_clienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * Filter, which crm_cliente to fetch.
     */
    where: crm_clienteWhereUniqueInput
  }

  /**
   * crm_cliente findUniqueOrThrow
   */
  export type crm_clienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * Filter, which crm_cliente to fetch.
     */
    where: crm_clienteWhereUniqueInput
  }

  /**
   * crm_cliente findFirst
   */
  export type crm_clienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * Filter, which crm_cliente to fetch.
     */
    where?: crm_clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crm_clientes to fetch.
     */
    orderBy?: crm_clienteOrderByWithRelationInput | crm_clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crm_clientes.
     */
    cursor?: crm_clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crm_clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crm_clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crm_clientes.
     */
    distinct?: Crm_clienteScalarFieldEnum | Crm_clienteScalarFieldEnum[]
  }

  /**
   * crm_cliente findFirstOrThrow
   */
  export type crm_clienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * Filter, which crm_cliente to fetch.
     */
    where?: crm_clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crm_clientes to fetch.
     */
    orderBy?: crm_clienteOrderByWithRelationInput | crm_clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crm_clientes.
     */
    cursor?: crm_clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crm_clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crm_clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crm_clientes.
     */
    distinct?: Crm_clienteScalarFieldEnum | Crm_clienteScalarFieldEnum[]
  }

  /**
   * crm_cliente findMany
   */
  export type crm_clienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * Filter, which crm_clientes to fetch.
     */
    where?: crm_clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crm_clientes to fetch.
     */
    orderBy?: crm_clienteOrderByWithRelationInput | crm_clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crm_clientes.
     */
    cursor?: crm_clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crm_clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crm_clientes.
     */
    skip?: number
    distinct?: Crm_clienteScalarFieldEnum | Crm_clienteScalarFieldEnum[]
  }

  /**
   * crm_cliente create
   */
  export type crm_clienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * The data needed to create a crm_cliente.
     */
    data: XOR<crm_clienteCreateInput, crm_clienteUncheckedCreateInput>
  }

  /**
   * crm_cliente createMany
   */
  export type crm_clienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crm_clientes.
     */
    data: crm_clienteCreateManyInput | crm_clienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * crm_cliente createManyAndReturn
   */
  export type crm_clienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * The data used to create many crm_clientes.
     */
    data: crm_clienteCreateManyInput | crm_clienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * crm_cliente update
   */
  export type crm_clienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * The data needed to update a crm_cliente.
     */
    data: XOR<crm_clienteUpdateInput, crm_clienteUncheckedUpdateInput>
    /**
     * Choose, which crm_cliente to update.
     */
    where: crm_clienteWhereUniqueInput
  }

  /**
   * crm_cliente updateMany
   */
  export type crm_clienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crm_clientes.
     */
    data: XOR<crm_clienteUpdateManyMutationInput, crm_clienteUncheckedUpdateManyInput>
    /**
     * Filter which crm_clientes to update
     */
    where?: crm_clienteWhereInput
    /**
     * Limit how many crm_clientes to update.
     */
    limit?: number
  }

  /**
   * crm_cliente updateManyAndReturn
   */
  export type crm_clienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * The data used to update crm_clientes.
     */
    data: XOR<crm_clienteUpdateManyMutationInput, crm_clienteUncheckedUpdateManyInput>
    /**
     * Filter which crm_clientes to update
     */
    where?: crm_clienteWhereInput
    /**
     * Limit how many crm_clientes to update.
     */
    limit?: number
  }

  /**
   * crm_cliente upsert
   */
  export type crm_clienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * The filter to search for the crm_cliente to update in case it exists.
     */
    where: crm_clienteWhereUniqueInput
    /**
     * In case the crm_cliente found by the `where` argument doesn't exist, create a new crm_cliente with this data.
     */
    create: XOR<crm_clienteCreateInput, crm_clienteUncheckedCreateInput>
    /**
     * In case the crm_cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crm_clienteUpdateInput, crm_clienteUncheckedUpdateInput>
  }

  /**
   * crm_cliente delete
   */
  export type crm_clienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
    /**
     * Filter which crm_cliente to delete.
     */
    where: crm_clienteWhereUniqueInput
  }

  /**
   * crm_cliente deleteMany
   */
  export type crm_clienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crm_clientes to delete
     */
    where?: crm_clienteWhereInput
    /**
     * Limit how many crm_clientes to delete.
     */
    limit?: number
  }

  /**
   * crm_cliente without action
   */
  export type crm_clienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crm_cliente
     */
    select?: crm_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crm_cliente
     */
    omit?: crm_clienteOmit<ExtArgs> | null
  }


  /**
   * Model status_pedido
   */

  export type AggregateStatus_pedido = {
    _count: Status_pedidoCountAggregateOutputType | null
    _avg: Status_pedidoAvgAggregateOutputType | null
    _sum: Status_pedidoSumAggregateOutputType | null
    _min: Status_pedidoMinAggregateOutputType | null
    _max: Status_pedidoMaxAggregateOutputType | null
  }

  export type Status_pedidoAvgAggregateOutputType = {
    id_status_pedido: number | null
    id_empresa: number | null
    ativo: number | null
  }

  export type Status_pedidoSumAggregateOutputType = {
    id_status_pedido: number | null
    id_empresa: number | null
    ativo: number | null
  }

  export type Status_pedidoMinAggregateOutputType = {
    id_status_pedido: number | null
    nome_status: string | null
    id_empresa: number | null
    ativo: number | null
    data_cadastrou: Date | null
  }

  export type Status_pedidoMaxAggregateOutputType = {
    id_status_pedido: number | null
    nome_status: string | null
    id_empresa: number | null
    ativo: number | null
    data_cadastrou: Date | null
  }

  export type Status_pedidoCountAggregateOutputType = {
    id_status_pedido: number
    nome_status: number
    id_empresa: number
    ativo: number
    data_cadastrou: number
    _all: number
  }


  export type Status_pedidoAvgAggregateInputType = {
    id_status_pedido?: true
    id_empresa?: true
    ativo?: true
  }

  export type Status_pedidoSumAggregateInputType = {
    id_status_pedido?: true
    id_empresa?: true
    ativo?: true
  }

  export type Status_pedidoMinAggregateInputType = {
    id_status_pedido?: true
    nome_status?: true
    id_empresa?: true
    ativo?: true
    data_cadastrou?: true
  }

  export type Status_pedidoMaxAggregateInputType = {
    id_status_pedido?: true
    nome_status?: true
    id_empresa?: true
    ativo?: true
    data_cadastrou?: true
  }

  export type Status_pedidoCountAggregateInputType = {
    id_status_pedido?: true
    nome_status?: true
    id_empresa?: true
    ativo?: true
    data_cadastrou?: true
    _all?: true
  }

  export type Status_pedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which status_pedido to aggregate.
     */
    where?: status_pedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of status_pedidos to fetch.
     */
    orderBy?: status_pedidoOrderByWithRelationInput | status_pedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: status_pedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` status_pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` status_pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned status_pedidos
    **/
    _count?: true | Status_pedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Status_pedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Status_pedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Status_pedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Status_pedidoMaxAggregateInputType
  }

  export type GetStatus_pedidoAggregateType<T extends Status_pedidoAggregateArgs> = {
        [P in keyof T & keyof AggregateStatus_pedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatus_pedido[P]>
      : GetScalarType<T[P], AggregateStatus_pedido[P]>
  }




  export type status_pedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: status_pedidoWhereInput
    orderBy?: status_pedidoOrderByWithAggregationInput | status_pedidoOrderByWithAggregationInput[]
    by: Status_pedidoScalarFieldEnum[] | Status_pedidoScalarFieldEnum
    having?: status_pedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Status_pedidoCountAggregateInputType | true
    _avg?: Status_pedidoAvgAggregateInputType
    _sum?: Status_pedidoSumAggregateInputType
    _min?: Status_pedidoMinAggregateInputType
    _max?: Status_pedidoMaxAggregateInputType
  }

  export type Status_pedidoGroupByOutputType = {
    id_status_pedido: number
    nome_status: string
    id_empresa: number
    ativo: number
    data_cadastrou: Date | null
    _count: Status_pedidoCountAggregateOutputType | null
    _avg: Status_pedidoAvgAggregateOutputType | null
    _sum: Status_pedidoSumAggregateOutputType | null
    _min: Status_pedidoMinAggregateOutputType | null
    _max: Status_pedidoMaxAggregateOutputType | null
  }

  type GetStatus_pedidoGroupByPayload<T extends status_pedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Status_pedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Status_pedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Status_pedidoGroupByOutputType[P]>
            : GetScalarType<T[P], Status_pedidoGroupByOutputType[P]>
        }
      >
    >


  export type status_pedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_status_pedido?: boolean
    nome_status?: boolean
    id_empresa?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["status_pedido"]>

  export type status_pedidoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_status_pedido?: boolean
    nome_status?: boolean
    id_empresa?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["status_pedido"]>

  export type status_pedidoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_status_pedido?: boolean
    nome_status?: boolean
    id_empresa?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["status_pedido"]>

  export type status_pedidoSelectScalar = {
    id_status_pedido?: boolean
    nome_status?: boolean
    id_empresa?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
  }

  export type status_pedidoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_status_pedido" | "nome_status" | "id_empresa" | "ativo" | "data_cadastrou", ExtArgs["result"]["status_pedido"]>

  export type $status_pedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "status_pedido"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_status_pedido: number
      nome_status: string
      id_empresa: number
      ativo: number
      data_cadastrou: Date | null
    }, ExtArgs["result"]["status_pedido"]>
    composites: {}
  }

  type status_pedidoGetPayload<S extends boolean | null | undefined | status_pedidoDefaultArgs> = $Result.GetResult<Prisma.$status_pedidoPayload, S>

  type status_pedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<status_pedidoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Status_pedidoCountAggregateInputType | true
    }

  export interface status_pedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['status_pedido'], meta: { name: 'status_pedido' } }
    /**
     * Find zero or one Status_pedido that matches the filter.
     * @param {status_pedidoFindUniqueArgs} args - Arguments to find a Status_pedido
     * @example
     * // Get one Status_pedido
     * const status_pedido = await prisma.status_pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends status_pedidoFindUniqueArgs>(args: SelectSubset<T, status_pedidoFindUniqueArgs<ExtArgs>>): Prisma__status_pedidoClient<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Status_pedido that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {status_pedidoFindUniqueOrThrowArgs} args - Arguments to find a Status_pedido
     * @example
     * // Get one Status_pedido
     * const status_pedido = await prisma.status_pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends status_pedidoFindUniqueOrThrowArgs>(args: SelectSubset<T, status_pedidoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__status_pedidoClient<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Status_pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_pedidoFindFirstArgs} args - Arguments to find a Status_pedido
     * @example
     * // Get one Status_pedido
     * const status_pedido = await prisma.status_pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends status_pedidoFindFirstArgs>(args?: SelectSubset<T, status_pedidoFindFirstArgs<ExtArgs>>): Prisma__status_pedidoClient<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Status_pedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_pedidoFindFirstOrThrowArgs} args - Arguments to find a Status_pedido
     * @example
     * // Get one Status_pedido
     * const status_pedido = await prisma.status_pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends status_pedidoFindFirstOrThrowArgs>(args?: SelectSubset<T, status_pedidoFindFirstOrThrowArgs<ExtArgs>>): Prisma__status_pedidoClient<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Status_pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_pedidoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Status_pedidos
     * const status_pedidos = await prisma.status_pedido.findMany()
     * 
     * // Get first 10 Status_pedidos
     * const status_pedidos = await prisma.status_pedido.findMany({ take: 10 })
     * 
     * // Only select the `id_status_pedido`
     * const status_pedidoWithId_status_pedidoOnly = await prisma.status_pedido.findMany({ select: { id_status_pedido: true } })
     * 
     */
    findMany<T extends status_pedidoFindManyArgs>(args?: SelectSubset<T, status_pedidoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Status_pedido.
     * @param {status_pedidoCreateArgs} args - Arguments to create a Status_pedido.
     * @example
     * // Create one Status_pedido
     * const Status_pedido = await prisma.status_pedido.create({
     *   data: {
     *     // ... data to create a Status_pedido
     *   }
     * })
     * 
     */
    create<T extends status_pedidoCreateArgs>(args: SelectSubset<T, status_pedidoCreateArgs<ExtArgs>>): Prisma__status_pedidoClient<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Status_pedidos.
     * @param {status_pedidoCreateManyArgs} args - Arguments to create many Status_pedidos.
     * @example
     * // Create many Status_pedidos
     * const status_pedido = await prisma.status_pedido.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends status_pedidoCreateManyArgs>(args?: SelectSubset<T, status_pedidoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Status_pedidos and returns the data saved in the database.
     * @param {status_pedidoCreateManyAndReturnArgs} args - Arguments to create many Status_pedidos.
     * @example
     * // Create many Status_pedidos
     * const status_pedido = await prisma.status_pedido.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Status_pedidos and only return the `id_status_pedido`
     * const status_pedidoWithId_status_pedidoOnly = await prisma.status_pedido.createManyAndReturn({
     *   select: { id_status_pedido: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends status_pedidoCreateManyAndReturnArgs>(args?: SelectSubset<T, status_pedidoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Status_pedido.
     * @param {status_pedidoDeleteArgs} args - Arguments to delete one Status_pedido.
     * @example
     * // Delete one Status_pedido
     * const Status_pedido = await prisma.status_pedido.delete({
     *   where: {
     *     // ... filter to delete one Status_pedido
     *   }
     * })
     * 
     */
    delete<T extends status_pedidoDeleteArgs>(args: SelectSubset<T, status_pedidoDeleteArgs<ExtArgs>>): Prisma__status_pedidoClient<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Status_pedido.
     * @param {status_pedidoUpdateArgs} args - Arguments to update one Status_pedido.
     * @example
     * // Update one Status_pedido
     * const status_pedido = await prisma.status_pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends status_pedidoUpdateArgs>(args: SelectSubset<T, status_pedidoUpdateArgs<ExtArgs>>): Prisma__status_pedidoClient<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Status_pedidos.
     * @param {status_pedidoDeleteManyArgs} args - Arguments to filter Status_pedidos to delete.
     * @example
     * // Delete a few Status_pedidos
     * const { count } = await prisma.status_pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends status_pedidoDeleteManyArgs>(args?: SelectSubset<T, status_pedidoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Status_pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_pedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Status_pedidos
     * const status_pedido = await prisma.status_pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends status_pedidoUpdateManyArgs>(args: SelectSubset<T, status_pedidoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Status_pedidos and returns the data updated in the database.
     * @param {status_pedidoUpdateManyAndReturnArgs} args - Arguments to update many Status_pedidos.
     * @example
     * // Update many Status_pedidos
     * const status_pedido = await prisma.status_pedido.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Status_pedidos and only return the `id_status_pedido`
     * const status_pedidoWithId_status_pedidoOnly = await prisma.status_pedido.updateManyAndReturn({
     *   select: { id_status_pedido: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends status_pedidoUpdateManyAndReturnArgs>(args: SelectSubset<T, status_pedidoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Status_pedido.
     * @param {status_pedidoUpsertArgs} args - Arguments to update or create a Status_pedido.
     * @example
     * // Update or create a Status_pedido
     * const status_pedido = await prisma.status_pedido.upsert({
     *   create: {
     *     // ... data to create a Status_pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Status_pedido we want to update
     *   }
     * })
     */
    upsert<T extends status_pedidoUpsertArgs>(args: SelectSubset<T, status_pedidoUpsertArgs<ExtArgs>>): Prisma__status_pedidoClient<$Result.GetResult<Prisma.$status_pedidoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Status_pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_pedidoCountArgs} args - Arguments to filter Status_pedidos to count.
     * @example
     * // Count the number of Status_pedidos
     * const count = await prisma.status_pedido.count({
     *   where: {
     *     // ... the filter for the Status_pedidos we want to count
     *   }
     * })
    **/
    count<T extends status_pedidoCountArgs>(
      args?: Subset<T, status_pedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Status_pedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Status_pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Status_pedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Status_pedidoAggregateArgs>(args: Subset<T, Status_pedidoAggregateArgs>): Prisma.PrismaPromise<GetStatus_pedidoAggregateType<T>>

    /**
     * Group by Status_pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {status_pedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends status_pedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: status_pedidoGroupByArgs['orderBy'] }
        : { orderBy?: status_pedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, status_pedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatus_pedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the status_pedido model
   */
  readonly fields: status_pedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for status_pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__status_pedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the status_pedido model
   */
  interface status_pedidoFieldRefs {
    readonly id_status_pedido: FieldRef<"status_pedido", 'Int'>
    readonly nome_status: FieldRef<"status_pedido", 'String'>
    readonly id_empresa: FieldRef<"status_pedido", 'Int'>
    readonly ativo: FieldRef<"status_pedido", 'Int'>
    readonly data_cadastrou: FieldRef<"status_pedido", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * status_pedido findUnique
   */
  export type status_pedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * Filter, which status_pedido to fetch.
     */
    where: status_pedidoWhereUniqueInput
  }

  /**
   * status_pedido findUniqueOrThrow
   */
  export type status_pedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * Filter, which status_pedido to fetch.
     */
    where: status_pedidoWhereUniqueInput
  }

  /**
   * status_pedido findFirst
   */
  export type status_pedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * Filter, which status_pedido to fetch.
     */
    where?: status_pedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of status_pedidos to fetch.
     */
    orderBy?: status_pedidoOrderByWithRelationInput | status_pedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for status_pedidos.
     */
    cursor?: status_pedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` status_pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` status_pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of status_pedidos.
     */
    distinct?: Status_pedidoScalarFieldEnum | Status_pedidoScalarFieldEnum[]
  }

  /**
   * status_pedido findFirstOrThrow
   */
  export type status_pedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * Filter, which status_pedido to fetch.
     */
    where?: status_pedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of status_pedidos to fetch.
     */
    orderBy?: status_pedidoOrderByWithRelationInput | status_pedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for status_pedidos.
     */
    cursor?: status_pedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` status_pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` status_pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of status_pedidos.
     */
    distinct?: Status_pedidoScalarFieldEnum | Status_pedidoScalarFieldEnum[]
  }

  /**
   * status_pedido findMany
   */
  export type status_pedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * Filter, which status_pedidos to fetch.
     */
    where?: status_pedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of status_pedidos to fetch.
     */
    orderBy?: status_pedidoOrderByWithRelationInput | status_pedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing status_pedidos.
     */
    cursor?: status_pedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` status_pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` status_pedidos.
     */
    skip?: number
    distinct?: Status_pedidoScalarFieldEnum | Status_pedidoScalarFieldEnum[]
  }

  /**
   * status_pedido create
   */
  export type status_pedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * The data needed to create a status_pedido.
     */
    data: XOR<status_pedidoCreateInput, status_pedidoUncheckedCreateInput>
  }

  /**
   * status_pedido createMany
   */
  export type status_pedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many status_pedidos.
     */
    data: status_pedidoCreateManyInput | status_pedidoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * status_pedido createManyAndReturn
   */
  export type status_pedidoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * The data used to create many status_pedidos.
     */
    data: status_pedidoCreateManyInput | status_pedidoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * status_pedido update
   */
  export type status_pedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * The data needed to update a status_pedido.
     */
    data: XOR<status_pedidoUpdateInput, status_pedidoUncheckedUpdateInput>
    /**
     * Choose, which status_pedido to update.
     */
    where: status_pedidoWhereUniqueInput
  }

  /**
   * status_pedido updateMany
   */
  export type status_pedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update status_pedidos.
     */
    data: XOR<status_pedidoUpdateManyMutationInput, status_pedidoUncheckedUpdateManyInput>
    /**
     * Filter which status_pedidos to update
     */
    where?: status_pedidoWhereInput
    /**
     * Limit how many status_pedidos to update.
     */
    limit?: number
  }

  /**
   * status_pedido updateManyAndReturn
   */
  export type status_pedidoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * The data used to update status_pedidos.
     */
    data: XOR<status_pedidoUpdateManyMutationInput, status_pedidoUncheckedUpdateManyInput>
    /**
     * Filter which status_pedidos to update
     */
    where?: status_pedidoWhereInput
    /**
     * Limit how many status_pedidos to update.
     */
    limit?: number
  }

  /**
   * status_pedido upsert
   */
  export type status_pedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * The filter to search for the status_pedido to update in case it exists.
     */
    where: status_pedidoWhereUniqueInput
    /**
     * In case the status_pedido found by the `where` argument doesn't exist, create a new status_pedido with this data.
     */
    create: XOR<status_pedidoCreateInput, status_pedidoUncheckedCreateInput>
    /**
     * In case the status_pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<status_pedidoUpdateInput, status_pedidoUncheckedUpdateInput>
  }

  /**
   * status_pedido delete
   */
  export type status_pedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
    /**
     * Filter which status_pedido to delete.
     */
    where: status_pedidoWhereUniqueInput
  }

  /**
   * status_pedido deleteMany
   */
  export type status_pedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which status_pedidos to delete
     */
    where?: status_pedidoWhereInput
    /**
     * Limit how many status_pedidos to delete.
     */
    limit?: number
  }

  /**
   * status_pedido without action
   */
  export type status_pedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status_pedido
     */
    select?: status_pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status_pedido
     */
    omit?: status_pedidoOmit<ExtArgs> | null
  }


  /**
   * Model pedido
   */

  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id_pedido: number | null
    id_user: number | null
    id_lista: number | null
    total: number | null
  }

  export type PedidoSumAggregateOutputType = {
    id_pedido: number | null
    id_user: number | null
    id_lista: number | null
    total: number | null
  }

  export type PedidoMinAggregateOutputType = {
    id_pedido: number | null
    id_user: number | null
    id_lista: number | null
    total: number | null
    data_cadastrou: Date | null
  }

  export type PedidoMaxAggregateOutputType = {
    id_pedido: number | null
    id_user: number | null
    id_lista: number | null
    total: number | null
    data_cadastrou: Date | null
  }

  export type PedidoCountAggregateOutputType = {
    id_pedido: number
    id_user: number
    id_lista: number
    total: number
    data_cadastrou: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id_pedido?: true
    id_user?: true
    id_lista?: true
    total?: true
  }

  export type PedidoSumAggregateInputType = {
    id_pedido?: true
    id_user?: true
    id_lista?: true
    total?: true
  }

  export type PedidoMinAggregateInputType = {
    id_pedido?: true
    id_user?: true
    id_lista?: true
    total?: true
    data_cadastrou?: true
  }

  export type PedidoMaxAggregateInputType = {
    id_pedido?: true
    id_user?: true
    id_lista?: true
    total?: true
    data_cadastrou?: true
  }

  export type PedidoCountAggregateInputType = {
    id_pedido?: true
    id_user?: true
    id_lista?: true
    total?: true
    data_cadastrou?: true
    _all?: true
  }

  export type PedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pedido to aggregate.
     */
    where?: pedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pedidos to fetch.
     */
    orderBy?: pedidoOrderByWithRelationInput | pedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type pedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pedidoWhereInput
    orderBy?: pedidoOrderByWithAggregationInput | pedidoOrderByWithAggregationInput[]
    by: PedidoScalarFieldEnum[] | PedidoScalarFieldEnum
    having?: pedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }

  export type PedidoGroupByOutputType = {
    id_pedido: number
    id_user: number
    id_lista: number
    total: number
    data_cadastrou: Date | null
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends pedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type pedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pedido?: boolean
    id_user?: boolean
    id_lista?: boolean
    total?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["pedido"]>

  export type pedidoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pedido?: boolean
    id_user?: boolean
    id_lista?: boolean
    total?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["pedido"]>

  export type pedidoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pedido?: boolean
    id_user?: boolean
    id_lista?: boolean
    total?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["pedido"]>

  export type pedidoSelectScalar = {
    id_pedido?: boolean
    id_user?: boolean
    id_lista?: boolean
    total?: boolean
    data_cadastrou?: boolean
  }

  export type pedidoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pedido" | "id_user" | "id_lista" | "total" | "data_cadastrou", ExtArgs["result"]["pedido"]>

  export type $pedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pedido"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_pedido: number
      id_user: number
      id_lista: number
      total: number
      data_cadastrou: Date | null
    }, ExtArgs["result"]["pedido"]>
    composites: {}
  }

  type pedidoGetPayload<S extends boolean | null | undefined | pedidoDefaultArgs> = $Result.GetResult<Prisma.$pedidoPayload, S>

  type pedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pedidoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PedidoCountAggregateInputType | true
    }

  export interface pedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pedido'], meta: { name: 'pedido' } }
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {pedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pedidoFindUniqueArgs>(args: SelectSubset<T, pedidoFindUniqueArgs<ExtArgs>>): Prisma__pedidoClient<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pedido that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pedidoFindUniqueOrThrowArgs>(args: SelectSubset<T, pedidoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pedidoClient<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pedidoFindFirstArgs>(args?: SelectSubset<T, pedidoFindFirstArgs<ExtArgs>>): Prisma__pedidoClient<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pedidoFindFirstOrThrowArgs>(args?: SelectSubset<T, pedidoFindFirstOrThrowArgs<ExtArgs>>): Prisma__pedidoClient<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedidoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id_pedido`
     * const pedidoWithId_pedidoOnly = await prisma.pedido.findMany({ select: { id_pedido: true } })
     * 
     */
    findMany<T extends pedidoFindManyArgs>(args?: SelectSubset<T, pedidoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pedido.
     * @param {pedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
     */
    create<T extends pedidoCreateArgs>(args: SelectSubset<T, pedidoCreateArgs<ExtArgs>>): Prisma__pedidoClient<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pedidos.
     * @param {pedidoCreateManyArgs} args - Arguments to create many Pedidos.
     * @example
     * // Create many Pedidos
     * const pedido = await prisma.pedido.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pedidoCreateManyArgs>(args?: SelectSubset<T, pedidoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pedidos and returns the data saved in the database.
     * @param {pedidoCreateManyAndReturnArgs} args - Arguments to create many Pedidos.
     * @example
     * // Create many Pedidos
     * const pedido = await prisma.pedido.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pedidos and only return the `id_pedido`
     * const pedidoWithId_pedidoOnly = await prisma.pedido.createManyAndReturn({
     *   select: { id_pedido: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pedidoCreateManyAndReturnArgs>(args?: SelectSubset<T, pedidoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pedido.
     * @param {pedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
     */
    delete<T extends pedidoDeleteArgs>(args: SelectSubset<T, pedidoDeleteArgs<ExtArgs>>): Prisma__pedidoClient<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pedido.
     * @param {pedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pedidoUpdateArgs>(args: SelectSubset<T, pedidoUpdateArgs<ExtArgs>>): Prisma__pedidoClient<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pedidos.
     * @param {pedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pedidoDeleteManyArgs>(args?: SelectSubset<T, pedidoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pedidoUpdateManyArgs>(args: SelectSubset<T, pedidoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos and returns the data updated in the database.
     * @param {pedidoUpdateManyAndReturnArgs} args - Arguments to update many Pedidos.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pedidos and only return the `id_pedido`
     * const pedidoWithId_pedidoOnly = await prisma.pedido.updateManyAndReturn({
     *   select: { id_pedido: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pedidoUpdateManyAndReturnArgs>(args: SelectSubset<T, pedidoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pedido.
     * @param {pedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
     */
    upsert<T extends pedidoUpsertArgs>(args: SelectSubset<T, pedidoUpsertArgs<ExtArgs>>): Prisma__pedidoClient<$Result.GetResult<Prisma.$pedidoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends pedidoCountArgs>(
      args?: Subset<T, pedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): Prisma.PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pedidoGroupByArgs['orderBy'] }
        : { orderBy?: pedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pedido model
   */
  readonly fields: pedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pedido model
   */
  interface pedidoFieldRefs {
    readonly id_pedido: FieldRef<"pedido", 'Int'>
    readonly id_user: FieldRef<"pedido", 'Int'>
    readonly id_lista: FieldRef<"pedido", 'Int'>
    readonly total: FieldRef<"pedido", 'Float'>
    readonly data_cadastrou: FieldRef<"pedido", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pedido findUnique
   */
  export type pedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * Filter, which pedido to fetch.
     */
    where: pedidoWhereUniqueInput
  }

  /**
   * pedido findUniqueOrThrow
   */
  export type pedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * Filter, which pedido to fetch.
     */
    where: pedidoWhereUniqueInput
  }

  /**
   * pedido findFirst
   */
  export type pedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * Filter, which pedido to fetch.
     */
    where?: pedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pedidos to fetch.
     */
    orderBy?: pedidoOrderByWithRelationInput | pedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pedidos.
     */
    cursor?: pedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * pedido findFirstOrThrow
   */
  export type pedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * Filter, which pedido to fetch.
     */
    where?: pedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pedidos to fetch.
     */
    orderBy?: pedidoOrderByWithRelationInput | pedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pedidos.
     */
    cursor?: pedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * pedido findMany
   */
  export type pedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * Filter, which pedidos to fetch.
     */
    where?: pedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pedidos to fetch.
     */
    orderBy?: pedidoOrderByWithRelationInput | pedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pedidos.
     */
    cursor?: pedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pedidos.
     */
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * pedido create
   */
  export type pedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * The data needed to create a pedido.
     */
    data: XOR<pedidoCreateInput, pedidoUncheckedCreateInput>
  }

  /**
   * pedido createMany
   */
  export type pedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pedidos.
     */
    data: pedidoCreateManyInput | pedidoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pedido createManyAndReturn
   */
  export type pedidoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * The data used to create many pedidos.
     */
    data: pedidoCreateManyInput | pedidoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pedido update
   */
  export type pedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * The data needed to update a pedido.
     */
    data: XOR<pedidoUpdateInput, pedidoUncheckedUpdateInput>
    /**
     * Choose, which pedido to update.
     */
    where: pedidoWhereUniqueInput
  }

  /**
   * pedido updateMany
   */
  export type pedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pedidos.
     */
    data: XOR<pedidoUpdateManyMutationInput, pedidoUncheckedUpdateManyInput>
    /**
     * Filter which pedidos to update
     */
    where?: pedidoWhereInput
    /**
     * Limit how many pedidos to update.
     */
    limit?: number
  }

  /**
   * pedido updateManyAndReturn
   */
  export type pedidoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * The data used to update pedidos.
     */
    data: XOR<pedidoUpdateManyMutationInput, pedidoUncheckedUpdateManyInput>
    /**
     * Filter which pedidos to update
     */
    where?: pedidoWhereInput
    /**
     * Limit how many pedidos to update.
     */
    limit?: number
  }

  /**
   * pedido upsert
   */
  export type pedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * The filter to search for the pedido to update in case it exists.
     */
    where: pedidoWhereUniqueInput
    /**
     * In case the pedido found by the `where` argument doesn't exist, create a new pedido with this data.
     */
    create: XOR<pedidoCreateInput, pedidoUncheckedCreateInput>
    /**
     * In case the pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pedidoUpdateInput, pedidoUncheckedUpdateInput>
  }

  /**
   * pedido delete
   */
  export type pedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
    /**
     * Filter which pedido to delete.
     */
    where: pedidoWhereUniqueInput
  }

  /**
   * pedido deleteMany
   */
  export type pedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pedidos to delete
     */
    where?: pedidoWhereInput
    /**
     * Limit how many pedidos to delete.
     */
    limit?: number
  }

  /**
   * pedido without action
   */
  export type pedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido
     */
    select?: pedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido
     */
    omit?: pedidoOmit<ExtArgs> | null
  }


  /**
   * Model pedido_item
   */

  export type AggregatePedido_item = {
    _count: Pedido_itemCountAggregateOutputType | null
    _avg: Pedido_itemAvgAggregateOutputType | null
    _sum: Pedido_itemSumAggregateOutputType | null
    _min: Pedido_itemMinAggregateOutputType | null
    _max: Pedido_itemMaxAggregateOutputType | null
  }

  export type Pedido_itemAvgAggregateOutputType = {
    id_pedido_item: number | null
    id_pedido: number | null
    id_produto: number | null
    qtde: number | null
    valor_unit: number | null
  }

  export type Pedido_itemSumAggregateOutputType = {
    id_pedido_item: number | null
    id_pedido: number | null
    id_produto: number | null
    qtde: number | null
    valor_unit: number | null
  }

  export type Pedido_itemMinAggregateOutputType = {
    id_pedido_item: number | null
    id_pedido: number | null
    id_produto: number | null
    qtde: number | null
    valor_unit: number | null
    data_cadastrou: Date | null
  }

  export type Pedido_itemMaxAggregateOutputType = {
    id_pedido_item: number | null
    id_pedido: number | null
    id_produto: number | null
    qtde: number | null
    valor_unit: number | null
    data_cadastrou: Date | null
  }

  export type Pedido_itemCountAggregateOutputType = {
    id_pedido_item: number
    id_pedido: number
    id_produto: number
    qtde: number
    valor_unit: number
    data_cadastrou: number
    _all: number
  }


  export type Pedido_itemAvgAggregateInputType = {
    id_pedido_item?: true
    id_pedido?: true
    id_produto?: true
    qtde?: true
    valor_unit?: true
  }

  export type Pedido_itemSumAggregateInputType = {
    id_pedido_item?: true
    id_pedido?: true
    id_produto?: true
    qtde?: true
    valor_unit?: true
  }

  export type Pedido_itemMinAggregateInputType = {
    id_pedido_item?: true
    id_pedido?: true
    id_produto?: true
    qtde?: true
    valor_unit?: true
    data_cadastrou?: true
  }

  export type Pedido_itemMaxAggregateInputType = {
    id_pedido_item?: true
    id_pedido?: true
    id_produto?: true
    qtde?: true
    valor_unit?: true
    data_cadastrou?: true
  }

  export type Pedido_itemCountAggregateInputType = {
    id_pedido_item?: true
    id_pedido?: true
    id_produto?: true
    qtde?: true
    valor_unit?: true
    data_cadastrou?: true
    _all?: true
  }

  export type Pedido_itemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pedido_item to aggregate.
     */
    where?: pedido_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pedido_items to fetch.
     */
    orderBy?: pedido_itemOrderByWithRelationInput | pedido_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pedido_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pedido_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pedido_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pedido_items
    **/
    _count?: true | Pedido_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pedido_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pedido_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pedido_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pedido_itemMaxAggregateInputType
  }

  export type GetPedido_itemAggregateType<T extends Pedido_itemAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido_item[P]>
      : GetScalarType<T[P], AggregatePedido_item[P]>
  }




  export type pedido_itemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pedido_itemWhereInput
    orderBy?: pedido_itemOrderByWithAggregationInput | pedido_itemOrderByWithAggregationInput[]
    by: Pedido_itemScalarFieldEnum[] | Pedido_itemScalarFieldEnum
    having?: pedido_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pedido_itemCountAggregateInputType | true
    _avg?: Pedido_itemAvgAggregateInputType
    _sum?: Pedido_itemSumAggregateInputType
    _min?: Pedido_itemMinAggregateInputType
    _max?: Pedido_itemMaxAggregateInputType
  }

  export type Pedido_itemGroupByOutputType = {
    id_pedido_item: number
    id_pedido: number
    id_produto: number
    qtde: number
    valor_unit: number
    data_cadastrou: Date | null
    _count: Pedido_itemCountAggregateOutputType | null
    _avg: Pedido_itemAvgAggregateOutputType | null
    _sum: Pedido_itemSumAggregateOutputType | null
    _min: Pedido_itemMinAggregateOutputType | null
    _max: Pedido_itemMaxAggregateOutputType | null
  }

  type GetPedido_itemGroupByPayload<T extends pedido_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pedido_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pedido_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pedido_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Pedido_itemGroupByOutputType[P]>
        }
      >
    >


  export type pedido_itemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pedido_item?: boolean
    id_pedido?: boolean
    id_produto?: boolean
    qtde?: boolean
    valor_unit?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["pedido_item"]>

  export type pedido_itemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pedido_item?: boolean
    id_pedido?: boolean
    id_produto?: boolean
    qtde?: boolean
    valor_unit?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["pedido_item"]>

  export type pedido_itemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pedido_item?: boolean
    id_pedido?: boolean
    id_produto?: boolean
    qtde?: boolean
    valor_unit?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["pedido_item"]>

  export type pedido_itemSelectScalar = {
    id_pedido_item?: boolean
    id_pedido?: boolean
    id_produto?: boolean
    qtde?: boolean
    valor_unit?: boolean
    data_cadastrou?: boolean
  }

  export type pedido_itemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pedido_item" | "id_pedido" | "id_produto" | "qtde" | "valor_unit" | "data_cadastrou", ExtArgs["result"]["pedido_item"]>

  export type $pedido_itemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pedido_item"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_pedido_item: number
      id_pedido: number
      id_produto: number
      qtde: number
      valor_unit: number
      data_cadastrou: Date | null
    }, ExtArgs["result"]["pedido_item"]>
    composites: {}
  }

  type pedido_itemGetPayload<S extends boolean | null | undefined | pedido_itemDefaultArgs> = $Result.GetResult<Prisma.$pedido_itemPayload, S>

  type pedido_itemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pedido_itemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pedido_itemCountAggregateInputType | true
    }

  export interface pedido_itemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pedido_item'], meta: { name: 'pedido_item' } }
    /**
     * Find zero or one Pedido_item that matches the filter.
     * @param {pedido_itemFindUniqueArgs} args - Arguments to find a Pedido_item
     * @example
     * // Get one Pedido_item
     * const pedido_item = await prisma.pedido_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pedido_itemFindUniqueArgs>(args: SelectSubset<T, pedido_itemFindUniqueArgs<ExtArgs>>): Prisma__pedido_itemClient<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pedido_item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pedido_itemFindUniqueOrThrowArgs} args - Arguments to find a Pedido_item
     * @example
     * // Get one Pedido_item
     * const pedido_item = await prisma.pedido_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pedido_itemFindUniqueOrThrowArgs>(args: SelectSubset<T, pedido_itemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pedido_itemClient<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pedido_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedido_itemFindFirstArgs} args - Arguments to find a Pedido_item
     * @example
     * // Get one Pedido_item
     * const pedido_item = await prisma.pedido_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pedido_itemFindFirstArgs>(args?: SelectSubset<T, pedido_itemFindFirstArgs<ExtArgs>>): Prisma__pedido_itemClient<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pedido_item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedido_itemFindFirstOrThrowArgs} args - Arguments to find a Pedido_item
     * @example
     * // Get one Pedido_item
     * const pedido_item = await prisma.pedido_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pedido_itemFindFirstOrThrowArgs>(args?: SelectSubset<T, pedido_itemFindFirstOrThrowArgs<ExtArgs>>): Prisma__pedido_itemClient<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pedido_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedido_itemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedido_items
     * const pedido_items = await prisma.pedido_item.findMany()
     * 
     * // Get first 10 Pedido_items
     * const pedido_items = await prisma.pedido_item.findMany({ take: 10 })
     * 
     * // Only select the `id_pedido_item`
     * const pedido_itemWithId_pedido_itemOnly = await prisma.pedido_item.findMany({ select: { id_pedido_item: true } })
     * 
     */
    findMany<T extends pedido_itemFindManyArgs>(args?: SelectSubset<T, pedido_itemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pedido_item.
     * @param {pedido_itemCreateArgs} args - Arguments to create a Pedido_item.
     * @example
     * // Create one Pedido_item
     * const Pedido_item = await prisma.pedido_item.create({
     *   data: {
     *     // ... data to create a Pedido_item
     *   }
     * })
     * 
     */
    create<T extends pedido_itemCreateArgs>(args: SelectSubset<T, pedido_itemCreateArgs<ExtArgs>>): Prisma__pedido_itemClient<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pedido_items.
     * @param {pedido_itemCreateManyArgs} args - Arguments to create many Pedido_items.
     * @example
     * // Create many Pedido_items
     * const pedido_item = await prisma.pedido_item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pedido_itemCreateManyArgs>(args?: SelectSubset<T, pedido_itemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pedido_items and returns the data saved in the database.
     * @param {pedido_itemCreateManyAndReturnArgs} args - Arguments to create many Pedido_items.
     * @example
     * // Create many Pedido_items
     * const pedido_item = await prisma.pedido_item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pedido_items and only return the `id_pedido_item`
     * const pedido_itemWithId_pedido_itemOnly = await prisma.pedido_item.createManyAndReturn({
     *   select: { id_pedido_item: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pedido_itemCreateManyAndReturnArgs>(args?: SelectSubset<T, pedido_itemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pedido_item.
     * @param {pedido_itemDeleteArgs} args - Arguments to delete one Pedido_item.
     * @example
     * // Delete one Pedido_item
     * const Pedido_item = await prisma.pedido_item.delete({
     *   where: {
     *     // ... filter to delete one Pedido_item
     *   }
     * })
     * 
     */
    delete<T extends pedido_itemDeleteArgs>(args: SelectSubset<T, pedido_itemDeleteArgs<ExtArgs>>): Prisma__pedido_itemClient<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pedido_item.
     * @param {pedido_itemUpdateArgs} args - Arguments to update one Pedido_item.
     * @example
     * // Update one Pedido_item
     * const pedido_item = await prisma.pedido_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pedido_itemUpdateArgs>(args: SelectSubset<T, pedido_itemUpdateArgs<ExtArgs>>): Prisma__pedido_itemClient<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pedido_items.
     * @param {pedido_itemDeleteManyArgs} args - Arguments to filter Pedido_items to delete.
     * @example
     * // Delete a few Pedido_items
     * const { count } = await prisma.pedido_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pedido_itemDeleteManyArgs>(args?: SelectSubset<T, pedido_itemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedido_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedido_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedido_items
     * const pedido_item = await prisma.pedido_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pedido_itemUpdateManyArgs>(args: SelectSubset<T, pedido_itemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedido_items and returns the data updated in the database.
     * @param {pedido_itemUpdateManyAndReturnArgs} args - Arguments to update many Pedido_items.
     * @example
     * // Update many Pedido_items
     * const pedido_item = await prisma.pedido_item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pedido_items and only return the `id_pedido_item`
     * const pedido_itemWithId_pedido_itemOnly = await prisma.pedido_item.updateManyAndReturn({
     *   select: { id_pedido_item: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pedido_itemUpdateManyAndReturnArgs>(args: SelectSubset<T, pedido_itemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pedido_item.
     * @param {pedido_itemUpsertArgs} args - Arguments to update or create a Pedido_item.
     * @example
     * // Update or create a Pedido_item
     * const pedido_item = await prisma.pedido_item.upsert({
     *   create: {
     *     // ... data to create a Pedido_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido_item we want to update
     *   }
     * })
     */
    upsert<T extends pedido_itemUpsertArgs>(args: SelectSubset<T, pedido_itemUpsertArgs<ExtArgs>>): Prisma__pedido_itemClient<$Result.GetResult<Prisma.$pedido_itemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pedido_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedido_itemCountArgs} args - Arguments to filter Pedido_items to count.
     * @example
     * // Count the number of Pedido_items
     * const count = await prisma.pedido_item.count({
     *   where: {
     *     // ... the filter for the Pedido_items we want to count
     *   }
     * })
    **/
    count<T extends pedido_itemCountArgs>(
      args?: Subset<T, pedido_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pedido_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pedido_itemAggregateArgs>(args: Subset<T, Pedido_itemAggregateArgs>): Prisma.PrismaPromise<GetPedido_itemAggregateType<T>>

    /**
     * Group by Pedido_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pedido_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pedido_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pedido_itemGroupByArgs['orderBy'] }
        : { orderBy?: pedido_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pedido_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedido_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pedido_item model
   */
  readonly fields: pedido_itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pedido_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pedido_itemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pedido_item model
   */
  interface pedido_itemFieldRefs {
    readonly id_pedido_item: FieldRef<"pedido_item", 'Int'>
    readonly id_pedido: FieldRef<"pedido_item", 'Int'>
    readonly id_produto: FieldRef<"pedido_item", 'Int'>
    readonly qtde: FieldRef<"pedido_item", 'Int'>
    readonly valor_unit: FieldRef<"pedido_item", 'Float'>
    readonly data_cadastrou: FieldRef<"pedido_item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pedido_item findUnique
   */
  export type pedido_itemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * Filter, which pedido_item to fetch.
     */
    where: pedido_itemWhereUniqueInput
  }

  /**
   * pedido_item findUniqueOrThrow
   */
  export type pedido_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * Filter, which pedido_item to fetch.
     */
    where: pedido_itemWhereUniqueInput
  }

  /**
   * pedido_item findFirst
   */
  export type pedido_itemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * Filter, which pedido_item to fetch.
     */
    where?: pedido_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pedido_items to fetch.
     */
    orderBy?: pedido_itemOrderByWithRelationInput | pedido_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pedido_items.
     */
    cursor?: pedido_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pedido_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pedido_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pedido_items.
     */
    distinct?: Pedido_itemScalarFieldEnum | Pedido_itemScalarFieldEnum[]
  }

  /**
   * pedido_item findFirstOrThrow
   */
  export type pedido_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * Filter, which pedido_item to fetch.
     */
    where?: pedido_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pedido_items to fetch.
     */
    orderBy?: pedido_itemOrderByWithRelationInput | pedido_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pedido_items.
     */
    cursor?: pedido_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pedido_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pedido_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pedido_items.
     */
    distinct?: Pedido_itemScalarFieldEnum | Pedido_itemScalarFieldEnum[]
  }

  /**
   * pedido_item findMany
   */
  export type pedido_itemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * Filter, which pedido_items to fetch.
     */
    where?: pedido_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pedido_items to fetch.
     */
    orderBy?: pedido_itemOrderByWithRelationInput | pedido_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pedido_items.
     */
    cursor?: pedido_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pedido_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pedido_items.
     */
    skip?: number
    distinct?: Pedido_itemScalarFieldEnum | Pedido_itemScalarFieldEnum[]
  }

  /**
   * pedido_item create
   */
  export type pedido_itemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * The data needed to create a pedido_item.
     */
    data: XOR<pedido_itemCreateInput, pedido_itemUncheckedCreateInput>
  }

  /**
   * pedido_item createMany
   */
  export type pedido_itemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pedido_items.
     */
    data: pedido_itemCreateManyInput | pedido_itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pedido_item createManyAndReturn
   */
  export type pedido_itemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * The data used to create many pedido_items.
     */
    data: pedido_itemCreateManyInput | pedido_itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pedido_item update
   */
  export type pedido_itemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * The data needed to update a pedido_item.
     */
    data: XOR<pedido_itemUpdateInput, pedido_itemUncheckedUpdateInput>
    /**
     * Choose, which pedido_item to update.
     */
    where: pedido_itemWhereUniqueInput
  }

  /**
   * pedido_item updateMany
   */
  export type pedido_itemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pedido_items.
     */
    data: XOR<pedido_itemUpdateManyMutationInput, pedido_itemUncheckedUpdateManyInput>
    /**
     * Filter which pedido_items to update
     */
    where?: pedido_itemWhereInput
    /**
     * Limit how many pedido_items to update.
     */
    limit?: number
  }

  /**
   * pedido_item updateManyAndReturn
   */
  export type pedido_itemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * The data used to update pedido_items.
     */
    data: XOR<pedido_itemUpdateManyMutationInput, pedido_itemUncheckedUpdateManyInput>
    /**
     * Filter which pedido_items to update
     */
    where?: pedido_itemWhereInput
    /**
     * Limit how many pedido_items to update.
     */
    limit?: number
  }

  /**
   * pedido_item upsert
   */
  export type pedido_itemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * The filter to search for the pedido_item to update in case it exists.
     */
    where: pedido_itemWhereUniqueInput
    /**
     * In case the pedido_item found by the `where` argument doesn't exist, create a new pedido_item with this data.
     */
    create: XOR<pedido_itemCreateInput, pedido_itemUncheckedCreateInput>
    /**
     * In case the pedido_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pedido_itemUpdateInput, pedido_itemUncheckedUpdateInput>
  }

  /**
   * pedido_item delete
   */
  export type pedido_itemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
    /**
     * Filter which pedido_item to delete.
     */
    where: pedido_itemWhereUniqueInput
  }

  /**
   * pedido_item deleteMany
   */
  export type pedido_itemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pedido_items to delete
     */
    where?: pedido_itemWhereInput
    /**
     * Limit how many pedido_items to delete.
     */
    limit?: number
  }

  /**
   * pedido_item without action
   */
  export type pedido_itemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pedido_item
     */
    select?: pedido_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pedido_item
     */
    omit?: pedido_itemOmit<ExtArgs> | null
  }


  /**
   * Model lista_produto
   */

  export type AggregateLista_produto = {
    _count: Lista_produtoCountAggregateOutputType | null
    _avg: Lista_produtoAvgAggregateOutputType | null
    _sum: Lista_produtoSumAggregateOutputType | null
    _min: Lista_produtoMinAggregateOutputType | null
    _max: Lista_produtoMaxAggregateOutputType | null
  }

  export type Lista_produtoAvgAggregateOutputType = {
    id_lista_produto: number | null
    id_produto: number | null
    id_lista: number | null
    id_empresa: number | null
    qtde_para_venda: number | null
    qtde_disponivel: number | null
  }

  export type Lista_produtoSumAggregateOutputType = {
    id_lista_produto: number | null
    id_produto: number | null
    id_lista: number | null
    id_empresa: number | null
    qtde_para_venda: number | null
    qtde_disponivel: number | null
  }

  export type Lista_produtoMinAggregateOutputType = {
    id_lista_produto: number | null
    id_produto: number | null
    id_lista: number | null
    id_empresa: number | null
    qtde_para_venda: number | null
    qtde_disponivel: number | null
    data_cadastrou: Date | null
  }

  export type Lista_produtoMaxAggregateOutputType = {
    id_lista_produto: number | null
    id_produto: number | null
    id_lista: number | null
    id_empresa: number | null
    qtde_para_venda: number | null
    qtde_disponivel: number | null
    data_cadastrou: Date | null
  }

  export type Lista_produtoCountAggregateOutputType = {
    id_lista_produto: number
    id_produto: number
    id_lista: number
    id_empresa: number
    qtde_para_venda: number
    qtde_disponivel: number
    data_cadastrou: number
    _all: number
  }


  export type Lista_produtoAvgAggregateInputType = {
    id_lista_produto?: true
    id_produto?: true
    id_lista?: true
    id_empresa?: true
    qtde_para_venda?: true
    qtde_disponivel?: true
  }

  export type Lista_produtoSumAggregateInputType = {
    id_lista_produto?: true
    id_produto?: true
    id_lista?: true
    id_empresa?: true
    qtde_para_venda?: true
    qtde_disponivel?: true
  }

  export type Lista_produtoMinAggregateInputType = {
    id_lista_produto?: true
    id_produto?: true
    id_lista?: true
    id_empresa?: true
    qtde_para_venda?: true
    qtde_disponivel?: true
    data_cadastrou?: true
  }

  export type Lista_produtoMaxAggregateInputType = {
    id_lista_produto?: true
    id_produto?: true
    id_lista?: true
    id_empresa?: true
    qtde_para_venda?: true
    qtde_disponivel?: true
    data_cadastrou?: true
  }

  export type Lista_produtoCountAggregateInputType = {
    id_lista_produto?: true
    id_produto?: true
    id_lista?: true
    id_empresa?: true
    qtde_para_venda?: true
    qtde_disponivel?: true
    data_cadastrou?: true
    _all?: true
  }

  export type Lista_produtoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lista_produto to aggregate.
     */
    where?: lista_produtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lista_produtos to fetch.
     */
    orderBy?: lista_produtoOrderByWithRelationInput | lista_produtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lista_produtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lista_produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lista_produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lista_produtos
    **/
    _count?: true | Lista_produtoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lista_produtoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lista_produtoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lista_produtoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lista_produtoMaxAggregateInputType
  }

  export type GetLista_produtoAggregateType<T extends Lista_produtoAggregateArgs> = {
        [P in keyof T & keyof AggregateLista_produto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLista_produto[P]>
      : GetScalarType<T[P], AggregateLista_produto[P]>
  }




  export type lista_produtoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lista_produtoWhereInput
    orderBy?: lista_produtoOrderByWithAggregationInput | lista_produtoOrderByWithAggregationInput[]
    by: Lista_produtoScalarFieldEnum[] | Lista_produtoScalarFieldEnum
    having?: lista_produtoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lista_produtoCountAggregateInputType | true
    _avg?: Lista_produtoAvgAggregateInputType
    _sum?: Lista_produtoSumAggregateInputType
    _min?: Lista_produtoMinAggregateInputType
    _max?: Lista_produtoMaxAggregateInputType
  }

  export type Lista_produtoGroupByOutputType = {
    id_lista_produto: number
    id_produto: number
    id_lista: number
    id_empresa: number
    qtde_para_venda: number
    qtde_disponivel: number
    data_cadastrou: Date | null
    _count: Lista_produtoCountAggregateOutputType | null
    _avg: Lista_produtoAvgAggregateOutputType | null
    _sum: Lista_produtoSumAggregateOutputType | null
    _min: Lista_produtoMinAggregateOutputType | null
    _max: Lista_produtoMaxAggregateOutputType | null
  }

  type GetLista_produtoGroupByPayload<T extends lista_produtoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lista_produtoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lista_produtoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lista_produtoGroupByOutputType[P]>
            : GetScalarType<T[P], Lista_produtoGroupByOutputType[P]>
        }
      >
    >


  export type lista_produtoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_lista_produto?: boolean
    id_produto?: boolean
    id_lista?: boolean
    id_empresa?: boolean
    qtde_para_venda?: boolean
    qtde_disponivel?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["lista_produto"]>

  export type lista_produtoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_lista_produto?: boolean
    id_produto?: boolean
    id_lista?: boolean
    id_empresa?: boolean
    qtde_para_venda?: boolean
    qtde_disponivel?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["lista_produto"]>

  export type lista_produtoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_lista_produto?: boolean
    id_produto?: boolean
    id_lista?: boolean
    id_empresa?: boolean
    qtde_para_venda?: boolean
    qtde_disponivel?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["lista_produto"]>

  export type lista_produtoSelectScalar = {
    id_lista_produto?: boolean
    id_produto?: boolean
    id_lista?: boolean
    id_empresa?: boolean
    qtde_para_venda?: boolean
    qtde_disponivel?: boolean
    data_cadastrou?: boolean
  }

  export type lista_produtoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_lista_produto" | "id_produto" | "id_lista" | "id_empresa" | "qtde_para_venda" | "qtde_disponivel" | "data_cadastrou", ExtArgs["result"]["lista_produto"]>

  export type $lista_produtoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lista_produto"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_lista_produto: number
      id_produto: number
      id_lista: number
      id_empresa: number
      qtde_para_venda: number
      qtde_disponivel: number
      data_cadastrou: Date | null
    }, ExtArgs["result"]["lista_produto"]>
    composites: {}
  }

  type lista_produtoGetPayload<S extends boolean | null | undefined | lista_produtoDefaultArgs> = $Result.GetResult<Prisma.$lista_produtoPayload, S>

  type lista_produtoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lista_produtoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Lista_produtoCountAggregateInputType | true
    }

  export interface lista_produtoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lista_produto'], meta: { name: 'lista_produto' } }
    /**
     * Find zero or one Lista_produto that matches the filter.
     * @param {lista_produtoFindUniqueArgs} args - Arguments to find a Lista_produto
     * @example
     * // Get one Lista_produto
     * const lista_produto = await prisma.lista_produto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lista_produtoFindUniqueArgs>(args: SelectSubset<T, lista_produtoFindUniqueArgs<ExtArgs>>): Prisma__lista_produtoClient<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lista_produto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lista_produtoFindUniqueOrThrowArgs} args - Arguments to find a Lista_produto
     * @example
     * // Get one Lista_produto
     * const lista_produto = await prisma.lista_produto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lista_produtoFindUniqueOrThrowArgs>(args: SelectSubset<T, lista_produtoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lista_produtoClient<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lista_produto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lista_produtoFindFirstArgs} args - Arguments to find a Lista_produto
     * @example
     * // Get one Lista_produto
     * const lista_produto = await prisma.lista_produto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lista_produtoFindFirstArgs>(args?: SelectSubset<T, lista_produtoFindFirstArgs<ExtArgs>>): Prisma__lista_produtoClient<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lista_produto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lista_produtoFindFirstOrThrowArgs} args - Arguments to find a Lista_produto
     * @example
     * // Get one Lista_produto
     * const lista_produto = await prisma.lista_produto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lista_produtoFindFirstOrThrowArgs>(args?: SelectSubset<T, lista_produtoFindFirstOrThrowArgs<ExtArgs>>): Prisma__lista_produtoClient<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lista_produtos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lista_produtoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lista_produtos
     * const lista_produtos = await prisma.lista_produto.findMany()
     * 
     * // Get first 10 Lista_produtos
     * const lista_produtos = await prisma.lista_produto.findMany({ take: 10 })
     * 
     * // Only select the `id_lista_produto`
     * const lista_produtoWithId_lista_produtoOnly = await prisma.lista_produto.findMany({ select: { id_lista_produto: true } })
     * 
     */
    findMany<T extends lista_produtoFindManyArgs>(args?: SelectSubset<T, lista_produtoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lista_produto.
     * @param {lista_produtoCreateArgs} args - Arguments to create a Lista_produto.
     * @example
     * // Create one Lista_produto
     * const Lista_produto = await prisma.lista_produto.create({
     *   data: {
     *     // ... data to create a Lista_produto
     *   }
     * })
     * 
     */
    create<T extends lista_produtoCreateArgs>(args: SelectSubset<T, lista_produtoCreateArgs<ExtArgs>>): Prisma__lista_produtoClient<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lista_produtos.
     * @param {lista_produtoCreateManyArgs} args - Arguments to create many Lista_produtos.
     * @example
     * // Create many Lista_produtos
     * const lista_produto = await prisma.lista_produto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lista_produtoCreateManyArgs>(args?: SelectSubset<T, lista_produtoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lista_produtos and returns the data saved in the database.
     * @param {lista_produtoCreateManyAndReturnArgs} args - Arguments to create many Lista_produtos.
     * @example
     * // Create many Lista_produtos
     * const lista_produto = await prisma.lista_produto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lista_produtos and only return the `id_lista_produto`
     * const lista_produtoWithId_lista_produtoOnly = await prisma.lista_produto.createManyAndReturn({
     *   select: { id_lista_produto: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends lista_produtoCreateManyAndReturnArgs>(args?: SelectSubset<T, lista_produtoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lista_produto.
     * @param {lista_produtoDeleteArgs} args - Arguments to delete one Lista_produto.
     * @example
     * // Delete one Lista_produto
     * const Lista_produto = await prisma.lista_produto.delete({
     *   where: {
     *     // ... filter to delete one Lista_produto
     *   }
     * })
     * 
     */
    delete<T extends lista_produtoDeleteArgs>(args: SelectSubset<T, lista_produtoDeleteArgs<ExtArgs>>): Prisma__lista_produtoClient<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lista_produto.
     * @param {lista_produtoUpdateArgs} args - Arguments to update one Lista_produto.
     * @example
     * // Update one Lista_produto
     * const lista_produto = await prisma.lista_produto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lista_produtoUpdateArgs>(args: SelectSubset<T, lista_produtoUpdateArgs<ExtArgs>>): Prisma__lista_produtoClient<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lista_produtos.
     * @param {lista_produtoDeleteManyArgs} args - Arguments to filter Lista_produtos to delete.
     * @example
     * // Delete a few Lista_produtos
     * const { count } = await prisma.lista_produto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lista_produtoDeleteManyArgs>(args?: SelectSubset<T, lista_produtoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lista_produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lista_produtoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lista_produtos
     * const lista_produto = await prisma.lista_produto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lista_produtoUpdateManyArgs>(args: SelectSubset<T, lista_produtoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lista_produtos and returns the data updated in the database.
     * @param {lista_produtoUpdateManyAndReturnArgs} args - Arguments to update many Lista_produtos.
     * @example
     * // Update many Lista_produtos
     * const lista_produto = await prisma.lista_produto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lista_produtos and only return the `id_lista_produto`
     * const lista_produtoWithId_lista_produtoOnly = await prisma.lista_produto.updateManyAndReturn({
     *   select: { id_lista_produto: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends lista_produtoUpdateManyAndReturnArgs>(args: SelectSubset<T, lista_produtoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lista_produto.
     * @param {lista_produtoUpsertArgs} args - Arguments to update or create a Lista_produto.
     * @example
     * // Update or create a Lista_produto
     * const lista_produto = await prisma.lista_produto.upsert({
     *   create: {
     *     // ... data to create a Lista_produto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lista_produto we want to update
     *   }
     * })
     */
    upsert<T extends lista_produtoUpsertArgs>(args: SelectSubset<T, lista_produtoUpsertArgs<ExtArgs>>): Prisma__lista_produtoClient<$Result.GetResult<Prisma.$lista_produtoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lista_produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lista_produtoCountArgs} args - Arguments to filter Lista_produtos to count.
     * @example
     * // Count the number of Lista_produtos
     * const count = await prisma.lista_produto.count({
     *   where: {
     *     // ... the filter for the Lista_produtos we want to count
     *   }
     * })
    **/
    count<T extends lista_produtoCountArgs>(
      args?: Subset<T, lista_produtoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lista_produtoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lista_produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lista_produtoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lista_produtoAggregateArgs>(args: Subset<T, Lista_produtoAggregateArgs>): Prisma.PrismaPromise<GetLista_produtoAggregateType<T>>

    /**
     * Group by Lista_produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lista_produtoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lista_produtoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lista_produtoGroupByArgs['orderBy'] }
        : { orderBy?: lista_produtoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lista_produtoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLista_produtoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lista_produto model
   */
  readonly fields: lista_produtoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lista_produto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lista_produtoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lista_produto model
   */
  interface lista_produtoFieldRefs {
    readonly id_lista_produto: FieldRef<"lista_produto", 'Int'>
    readonly id_produto: FieldRef<"lista_produto", 'Int'>
    readonly id_lista: FieldRef<"lista_produto", 'Int'>
    readonly id_empresa: FieldRef<"lista_produto", 'Int'>
    readonly qtde_para_venda: FieldRef<"lista_produto", 'Int'>
    readonly qtde_disponivel: FieldRef<"lista_produto", 'Int'>
    readonly data_cadastrou: FieldRef<"lista_produto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * lista_produto findUnique
   */
  export type lista_produtoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * Filter, which lista_produto to fetch.
     */
    where: lista_produtoWhereUniqueInput
  }

  /**
   * lista_produto findUniqueOrThrow
   */
  export type lista_produtoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * Filter, which lista_produto to fetch.
     */
    where: lista_produtoWhereUniqueInput
  }

  /**
   * lista_produto findFirst
   */
  export type lista_produtoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * Filter, which lista_produto to fetch.
     */
    where?: lista_produtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lista_produtos to fetch.
     */
    orderBy?: lista_produtoOrderByWithRelationInput | lista_produtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lista_produtos.
     */
    cursor?: lista_produtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lista_produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lista_produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lista_produtos.
     */
    distinct?: Lista_produtoScalarFieldEnum | Lista_produtoScalarFieldEnum[]
  }

  /**
   * lista_produto findFirstOrThrow
   */
  export type lista_produtoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * Filter, which lista_produto to fetch.
     */
    where?: lista_produtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lista_produtos to fetch.
     */
    orderBy?: lista_produtoOrderByWithRelationInput | lista_produtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lista_produtos.
     */
    cursor?: lista_produtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lista_produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lista_produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lista_produtos.
     */
    distinct?: Lista_produtoScalarFieldEnum | Lista_produtoScalarFieldEnum[]
  }

  /**
   * lista_produto findMany
   */
  export type lista_produtoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * Filter, which lista_produtos to fetch.
     */
    where?: lista_produtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lista_produtos to fetch.
     */
    orderBy?: lista_produtoOrderByWithRelationInput | lista_produtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lista_produtos.
     */
    cursor?: lista_produtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lista_produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lista_produtos.
     */
    skip?: number
    distinct?: Lista_produtoScalarFieldEnum | Lista_produtoScalarFieldEnum[]
  }

  /**
   * lista_produto create
   */
  export type lista_produtoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * The data needed to create a lista_produto.
     */
    data: XOR<lista_produtoCreateInput, lista_produtoUncheckedCreateInput>
  }

  /**
   * lista_produto createMany
   */
  export type lista_produtoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lista_produtos.
     */
    data: lista_produtoCreateManyInput | lista_produtoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lista_produto createManyAndReturn
   */
  export type lista_produtoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * The data used to create many lista_produtos.
     */
    data: lista_produtoCreateManyInput | lista_produtoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lista_produto update
   */
  export type lista_produtoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * The data needed to update a lista_produto.
     */
    data: XOR<lista_produtoUpdateInput, lista_produtoUncheckedUpdateInput>
    /**
     * Choose, which lista_produto to update.
     */
    where: lista_produtoWhereUniqueInput
  }

  /**
   * lista_produto updateMany
   */
  export type lista_produtoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lista_produtos.
     */
    data: XOR<lista_produtoUpdateManyMutationInput, lista_produtoUncheckedUpdateManyInput>
    /**
     * Filter which lista_produtos to update
     */
    where?: lista_produtoWhereInput
    /**
     * Limit how many lista_produtos to update.
     */
    limit?: number
  }

  /**
   * lista_produto updateManyAndReturn
   */
  export type lista_produtoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * The data used to update lista_produtos.
     */
    data: XOR<lista_produtoUpdateManyMutationInput, lista_produtoUncheckedUpdateManyInput>
    /**
     * Filter which lista_produtos to update
     */
    where?: lista_produtoWhereInput
    /**
     * Limit how many lista_produtos to update.
     */
    limit?: number
  }

  /**
   * lista_produto upsert
   */
  export type lista_produtoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * The filter to search for the lista_produto to update in case it exists.
     */
    where: lista_produtoWhereUniqueInput
    /**
     * In case the lista_produto found by the `where` argument doesn't exist, create a new lista_produto with this data.
     */
    create: XOR<lista_produtoCreateInput, lista_produtoUncheckedCreateInput>
    /**
     * In case the lista_produto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lista_produtoUpdateInput, lista_produtoUncheckedUpdateInput>
  }

  /**
   * lista_produto delete
   */
  export type lista_produtoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
    /**
     * Filter which lista_produto to delete.
     */
    where: lista_produtoWhereUniqueInput
  }

  /**
   * lista_produto deleteMany
   */
  export type lista_produtoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lista_produtos to delete
     */
    where?: lista_produtoWhereInput
    /**
     * Limit how many lista_produtos to delete.
     */
    limit?: number
  }

  /**
   * lista_produto without action
   */
  export type lista_produtoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista_produto
     */
    select?: lista_produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista_produto
     */
    omit?: lista_produtoOmit<ExtArgs> | null
  }


  /**
   * Model campanha_token
   */

  export type AggregateCampanha_token = {
    _count: Campanha_tokenCountAggregateOutputType | null
    _avg: Campanha_tokenAvgAggregateOutputType | null
    _sum: Campanha_tokenSumAggregateOutputType | null
    _min: Campanha_tokenMinAggregateOutputType | null
    _max: Campanha_tokenMaxAggregateOutputType | null
  }

  export type Campanha_tokenAvgAggregateOutputType = {
    id_campanha_token: number | null
    id_campanha: number | null
    utilizado: number | null
    gerado: number | null
  }

  export type Campanha_tokenSumAggregateOutputType = {
    id_campanha_token: number | null
    id_campanha: number | null
    utilizado: number | null
    gerado: number | null
  }

  export type Campanha_tokenMinAggregateOutputType = {
    id_campanha_token: number | null
    id_campanha: number | null
    token: string | null
    utilizado: number | null
    gerado: number | null
    data_cadastrou: Date | null
  }

  export type Campanha_tokenMaxAggregateOutputType = {
    id_campanha_token: number | null
    id_campanha: number | null
    token: string | null
    utilizado: number | null
    gerado: number | null
    data_cadastrou: Date | null
  }

  export type Campanha_tokenCountAggregateOutputType = {
    id_campanha_token: number
    id_campanha: number
    token: number
    utilizado: number
    gerado: number
    data_cadastrou: number
    _all: number
  }


  export type Campanha_tokenAvgAggregateInputType = {
    id_campanha_token?: true
    id_campanha?: true
    utilizado?: true
    gerado?: true
  }

  export type Campanha_tokenSumAggregateInputType = {
    id_campanha_token?: true
    id_campanha?: true
    utilizado?: true
    gerado?: true
  }

  export type Campanha_tokenMinAggregateInputType = {
    id_campanha_token?: true
    id_campanha?: true
    token?: true
    utilizado?: true
    gerado?: true
    data_cadastrou?: true
  }

  export type Campanha_tokenMaxAggregateInputType = {
    id_campanha_token?: true
    id_campanha?: true
    token?: true
    utilizado?: true
    gerado?: true
    data_cadastrou?: true
  }

  export type Campanha_tokenCountAggregateInputType = {
    id_campanha_token?: true
    id_campanha?: true
    token?: true
    utilizado?: true
    gerado?: true
    data_cadastrou?: true
    _all?: true
  }

  export type Campanha_tokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanha_token to aggregate.
     */
    where?: campanha_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanha_tokens to fetch.
     */
    orderBy?: campanha_tokenOrderByWithRelationInput | campanha_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campanha_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanha_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanha_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campanha_tokens
    **/
    _count?: true | Campanha_tokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Campanha_tokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Campanha_tokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Campanha_tokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Campanha_tokenMaxAggregateInputType
  }

  export type GetCampanha_tokenAggregateType<T extends Campanha_tokenAggregateArgs> = {
        [P in keyof T & keyof AggregateCampanha_token]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampanha_token[P]>
      : GetScalarType<T[P], AggregateCampanha_token[P]>
  }




  export type campanha_tokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campanha_tokenWhereInput
    orderBy?: campanha_tokenOrderByWithAggregationInput | campanha_tokenOrderByWithAggregationInput[]
    by: Campanha_tokenScalarFieldEnum[] | Campanha_tokenScalarFieldEnum
    having?: campanha_tokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Campanha_tokenCountAggregateInputType | true
    _avg?: Campanha_tokenAvgAggregateInputType
    _sum?: Campanha_tokenSumAggregateInputType
    _min?: Campanha_tokenMinAggregateInputType
    _max?: Campanha_tokenMaxAggregateInputType
  }

  export type Campanha_tokenGroupByOutputType = {
    id_campanha_token: number
    id_campanha: number
    token: string
    utilizado: number
    gerado: number
    data_cadastrou: Date | null
    _count: Campanha_tokenCountAggregateOutputType | null
    _avg: Campanha_tokenAvgAggregateOutputType | null
    _sum: Campanha_tokenSumAggregateOutputType | null
    _min: Campanha_tokenMinAggregateOutputType | null
    _max: Campanha_tokenMaxAggregateOutputType | null
  }

  type GetCampanha_tokenGroupByPayload<T extends campanha_tokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Campanha_tokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Campanha_tokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Campanha_tokenGroupByOutputType[P]>
            : GetScalarType<T[P], Campanha_tokenGroupByOutputType[P]>
        }
      >
    >


  export type campanha_tokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha_token?: boolean
    id_campanha?: boolean
    token?: boolean
    utilizado?: boolean
    gerado?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["campanha_token"]>

  export type campanha_tokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha_token?: boolean
    id_campanha?: boolean
    token?: boolean
    utilizado?: boolean
    gerado?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["campanha_token"]>

  export type campanha_tokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha_token?: boolean
    id_campanha?: boolean
    token?: boolean
    utilizado?: boolean
    gerado?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["campanha_token"]>

  export type campanha_tokenSelectScalar = {
    id_campanha_token?: boolean
    id_campanha?: boolean
    token?: boolean
    utilizado?: boolean
    gerado?: boolean
    data_cadastrou?: boolean
  }

  export type campanha_tokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_campanha_token" | "id_campanha" | "token" | "utilizado" | "gerado" | "data_cadastrou", ExtArgs["result"]["campanha_token"]>

  export type $campanha_tokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campanha_token"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_campanha_token: number
      id_campanha: number
      token: string
      utilizado: number
      gerado: number
      data_cadastrou: Date | null
    }, ExtArgs["result"]["campanha_token"]>
    composites: {}
  }

  type campanha_tokenGetPayload<S extends boolean | null | undefined | campanha_tokenDefaultArgs> = $Result.GetResult<Prisma.$campanha_tokenPayload, S>

  type campanha_tokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<campanha_tokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Campanha_tokenCountAggregateInputType | true
    }

  export interface campanha_tokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campanha_token'], meta: { name: 'campanha_token' } }
    /**
     * Find zero or one Campanha_token that matches the filter.
     * @param {campanha_tokenFindUniqueArgs} args - Arguments to find a Campanha_token
     * @example
     * // Get one Campanha_token
     * const campanha_token = await prisma.campanha_token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campanha_tokenFindUniqueArgs>(args: SelectSubset<T, campanha_tokenFindUniqueArgs<ExtArgs>>): Prisma__campanha_tokenClient<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campanha_token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {campanha_tokenFindUniqueOrThrowArgs} args - Arguments to find a Campanha_token
     * @example
     * // Get one Campanha_token
     * const campanha_token = await prisma.campanha_token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campanha_tokenFindUniqueOrThrowArgs>(args: SelectSubset<T, campanha_tokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campanha_tokenClient<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campanha_token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_tokenFindFirstArgs} args - Arguments to find a Campanha_token
     * @example
     * // Get one Campanha_token
     * const campanha_token = await prisma.campanha_token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campanha_tokenFindFirstArgs>(args?: SelectSubset<T, campanha_tokenFindFirstArgs<ExtArgs>>): Prisma__campanha_tokenClient<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campanha_token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_tokenFindFirstOrThrowArgs} args - Arguments to find a Campanha_token
     * @example
     * // Get one Campanha_token
     * const campanha_token = await prisma.campanha_token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campanha_tokenFindFirstOrThrowArgs>(args?: SelectSubset<T, campanha_tokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__campanha_tokenClient<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campanha_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_tokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campanha_tokens
     * const campanha_tokens = await prisma.campanha_token.findMany()
     * 
     * // Get first 10 Campanha_tokens
     * const campanha_tokens = await prisma.campanha_token.findMany({ take: 10 })
     * 
     * // Only select the `id_campanha_token`
     * const campanha_tokenWithId_campanha_tokenOnly = await prisma.campanha_token.findMany({ select: { id_campanha_token: true } })
     * 
     */
    findMany<T extends campanha_tokenFindManyArgs>(args?: SelectSubset<T, campanha_tokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campanha_token.
     * @param {campanha_tokenCreateArgs} args - Arguments to create a Campanha_token.
     * @example
     * // Create one Campanha_token
     * const Campanha_token = await prisma.campanha_token.create({
     *   data: {
     *     // ... data to create a Campanha_token
     *   }
     * })
     * 
     */
    create<T extends campanha_tokenCreateArgs>(args: SelectSubset<T, campanha_tokenCreateArgs<ExtArgs>>): Prisma__campanha_tokenClient<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campanha_tokens.
     * @param {campanha_tokenCreateManyArgs} args - Arguments to create many Campanha_tokens.
     * @example
     * // Create many Campanha_tokens
     * const campanha_token = await prisma.campanha_token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campanha_tokenCreateManyArgs>(args?: SelectSubset<T, campanha_tokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campanha_tokens and returns the data saved in the database.
     * @param {campanha_tokenCreateManyAndReturnArgs} args - Arguments to create many Campanha_tokens.
     * @example
     * // Create many Campanha_tokens
     * const campanha_token = await prisma.campanha_token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campanha_tokens and only return the `id_campanha_token`
     * const campanha_tokenWithId_campanha_tokenOnly = await prisma.campanha_token.createManyAndReturn({
     *   select: { id_campanha_token: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campanha_tokenCreateManyAndReturnArgs>(args?: SelectSubset<T, campanha_tokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campanha_token.
     * @param {campanha_tokenDeleteArgs} args - Arguments to delete one Campanha_token.
     * @example
     * // Delete one Campanha_token
     * const Campanha_token = await prisma.campanha_token.delete({
     *   where: {
     *     // ... filter to delete one Campanha_token
     *   }
     * })
     * 
     */
    delete<T extends campanha_tokenDeleteArgs>(args: SelectSubset<T, campanha_tokenDeleteArgs<ExtArgs>>): Prisma__campanha_tokenClient<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campanha_token.
     * @param {campanha_tokenUpdateArgs} args - Arguments to update one Campanha_token.
     * @example
     * // Update one Campanha_token
     * const campanha_token = await prisma.campanha_token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campanha_tokenUpdateArgs>(args: SelectSubset<T, campanha_tokenUpdateArgs<ExtArgs>>): Prisma__campanha_tokenClient<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campanha_tokens.
     * @param {campanha_tokenDeleteManyArgs} args - Arguments to filter Campanha_tokens to delete.
     * @example
     * // Delete a few Campanha_tokens
     * const { count } = await prisma.campanha_token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campanha_tokenDeleteManyArgs>(args?: SelectSubset<T, campanha_tokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanha_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_tokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campanha_tokens
     * const campanha_token = await prisma.campanha_token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campanha_tokenUpdateManyArgs>(args: SelectSubset<T, campanha_tokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanha_tokens and returns the data updated in the database.
     * @param {campanha_tokenUpdateManyAndReturnArgs} args - Arguments to update many Campanha_tokens.
     * @example
     * // Update many Campanha_tokens
     * const campanha_token = await prisma.campanha_token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campanha_tokens and only return the `id_campanha_token`
     * const campanha_tokenWithId_campanha_tokenOnly = await prisma.campanha_token.updateManyAndReturn({
     *   select: { id_campanha_token: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends campanha_tokenUpdateManyAndReturnArgs>(args: SelectSubset<T, campanha_tokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campanha_token.
     * @param {campanha_tokenUpsertArgs} args - Arguments to update or create a Campanha_token.
     * @example
     * // Update or create a Campanha_token
     * const campanha_token = await prisma.campanha_token.upsert({
     *   create: {
     *     // ... data to create a Campanha_token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campanha_token we want to update
     *   }
     * })
     */
    upsert<T extends campanha_tokenUpsertArgs>(args: SelectSubset<T, campanha_tokenUpsertArgs<ExtArgs>>): Prisma__campanha_tokenClient<$Result.GetResult<Prisma.$campanha_tokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campanha_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_tokenCountArgs} args - Arguments to filter Campanha_tokens to count.
     * @example
     * // Count the number of Campanha_tokens
     * const count = await prisma.campanha_token.count({
     *   where: {
     *     // ... the filter for the Campanha_tokens we want to count
     *   }
     * })
    **/
    count<T extends campanha_tokenCountArgs>(
      args?: Subset<T, campanha_tokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Campanha_tokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campanha_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campanha_tokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Campanha_tokenAggregateArgs>(args: Subset<T, Campanha_tokenAggregateArgs>): Prisma.PrismaPromise<GetCampanha_tokenAggregateType<T>>

    /**
     * Group by Campanha_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_tokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campanha_tokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campanha_tokenGroupByArgs['orderBy'] }
        : { orderBy?: campanha_tokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campanha_tokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampanha_tokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campanha_token model
   */
  readonly fields: campanha_tokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campanha_token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campanha_tokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campanha_token model
   */
  interface campanha_tokenFieldRefs {
    readonly id_campanha_token: FieldRef<"campanha_token", 'Int'>
    readonly id_campanha: FieldRef<"campanha_token", 'Int'>
    readonly token: FieldRef<"campanha_token", 'String'>
    readonly utilizado: FieldRef<"campanha_token", 'Int'>
    readonly gerado: FieldRef<"campanha_token", 'Int'>
    readonly data_cadastrou: FieldRef<"campanha_token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * campanha_token findUnique
   */
  export type campanha_tokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * Filter, which campanha_token to fetch.
     */
    where: campanha_tokenWhereUniqueInput
  }

  /**
   * campanha_token findUniqueOrThrow
   */
  export type campanha_tokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * Filter, which campanha_token to fetch.
     */
    where: campanha_tokenWhereUniqueInput
  }

  /**
   * campanha_token findFirst
   */
  export type campanha_tokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * Filter, which campanha_token to fetch.
     */
    where?: campanha_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanha_tokens to fetch.
     */
    orderBy?: campanha_tokenOrderByWithRelationInput | campanha_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanha_tokens.
     */
    cursor?: campanha_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanha_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanha_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanha_tokens.
     */
    distinct?: Campanha_tokenScalarFieldEnum | Campanha_tokenScalarFieldEnum[]
  }

  /**
   * campanha_token findFirstOrThrow
   */
  export type campanha_tokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * Filter, which campanha_token to fetch.
     */
    where?: campanha_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanha_tokens to fetch.
     */
    orderBy?: campanha_tokenOrderByWithRelationInput | campanha_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanha_tokens.
     */
    cursor?: campanha_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanha_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanha_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanha_tokens.
     */
    distinct?: Campanha_tokenScalarFieldEnum | Campanha_tokenScalarFieldEnum[]
  }

  /**
   * campanha_token findMany
   */
  export type campanha_tokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * Filter, which campanha_tokens to fetch.
     */
    where?: campanha_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanha_tokens to fetch.
     */
    orderBy?: campanha_tokenOrderByWithRelationInput | campanha_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campanha_tokens.
     */
    cursor?: campanha_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanha_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanha_tokens.
     */
    skip?: number
    distinct?: Campanha_tokenScalarFieldEnum | Campanha_tokenScalarFieldEnum[]
  }

  /**
   * campanha_token create
   */
  export type campanha_tokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * The data needed to create a campanha_token.
     */
    data: XOR<campanha_tokenCreateInput, campanha_tokenUncheckedCreateInput>
  }

  /**
   * campanha_token createMany
   */
  export type campanha_tokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campanha_tokens.
     */
    data: campanha_tokenCreateManyInput | campanha_tokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campanha_token createManyAndReturn
   */
  export type campanha_tokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * The data used to create many campanha_tokens.
     */
    data: campanha_tokenCreateManyInput | campanha_tokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campanha_token update
   */
  export type campanha_tokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * The data needed to update a campanha_token.
     */
    data: XOR<campanha_tokenUpdateInput, campanha_tokenUncheckedUpdateInput>
    /**
     * Choose, which campanha_token to update.
     */
    where: campanha_tokenWhereUniqueInput
  }

  /**
   * campanha_token updateMany
   */
  export type campanha_tokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campanha_tokens.
     */
    data: XOR<campanha_tokenUpdateManyMutationInput, campanha_tokenUncheckedUpdateManyInput>
    /**
     * Filter which campanha_tokens to update
     */
    where?: campanha_tokenWhereInput
    /**
     * Limit how many campanha_tokens to update.
     */
    limit?: number
  }

  /**
   * campanha_token updateManyAndReturn
   */
  export type campanha_tokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * The data used to update campanha_tokens.
     */
    data: XOR<campanha_tokenUpdateManyMutationInput, campanha_tokenUncheckedUpdateManyInput>
    /**
     * Filter which campanha_tokens to update
     */
    where?: campanha_tokenWhereInput
    /**
     * Limit how many campanha_tokens to update.
     */
    limit?: number
  }

  /**
   * campanha_token upsert
   */
  export type campanha_tokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * The filter to search for the campanha_token to update in case it exists.
     */
    where: campanha_tokenWhereUniqueInput
    /**
     * In case the campanha_token found by the `where` argument doesn't exist, create a new campanha_token with this data.
     */
    create: XOR<campanha_tokenCreateInput, campanha_tokenUncheckedCreateInput>
    /**
     * In case the campanha_token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campanha_tokenUpdateInput, campanha_tokenUncheckedUpdateInput>
  }

  /**
   * campanha_token delete
   */
  export type campanha_tokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
    /**
     * Filter which campanha_token to delete.
     */
    where: campanha_tokenWhereUniqueInput
  }

  /**
   * campanha_token deleteMany
   */
  export type campanha_tokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanha_tokens to delete
     */
    where?: campanha_tokenWhereInput
    /**
     * Limit how many campanha_tokens to delete.
     */
    limit?: number
  }

  /**
   * campanha_token without action
   */
  export type campanha_tokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_token
     */
    select?: campanha_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_token
     */
    omit?: campanha_tokenOmit<ExtArgs> | null
  }


  /**
   * Model userempresa
   */

  export type AggregateUserempresa = {
    _count: UserempresaCountAggregateOutputType | null
    _avg: UserempresaAvgAggregateOutputType | null
    _sum: UserempresaSumAggregateOutputType | null
    _min: UserempresaMinAggregateOutputType | null
    _max: UserempresaMaxAggregateOutputType | null
  }

  export type UserempresaAvgAggregateOutputType = {
    id_user_empresa: number | null
    id_empresa: number | null
    id_user: number | null
    role: number | null
  }

  export type UserempresaSumAggregateOutputType = {
    id_user_empresa: number | null
    id_empresa: number | null
    id_user: number | null
    role: number | null
  }

  export type UserempresaMinAggregateOutputType = {
    id_user_empresa: number | null
    id_empresa: number | null
    id_user: number | null
    data_cadastrou: Date | null
    role: number | null
  }

  export type UserempresaMaxAggregateOutputType = {
    id_user_empresa: number | null
    id_empresa: number | null
    id_user: number | null
    data_cadastrou: Date | null
    role: number | null
  }

  export type UserempresaCountAggregateOutputType = {
    id_user_empresa: number
    id_empresa: number
    id_user: number
    data_cadastrou: number
    role: number
    _all: number
  }


  export type UserempresaAvgAggregateInputType = {
    id_user_empresa?: true
    id_empresa?: true
    id_user?: true
    role?: true
  }

  export type UserempresaSumAggregateInputType = {
    id_user_empresa?: true
    id_empresa?: true
    id_user?: true
    role?: true
  }

  export type UserempresaMinAggregateInputType = {
    id_user_empresa?: true
    id_empresa?: true
    id_user?: true
    data_cadastrou?: true
    role?: true
  }

  export type UserempresaMaxAggregateInputType = {
    id_user_empresa?: true
    id_empresa?: true
    id_user?: true
    data_cadastrou?: true
    role?: true
  }

  export type UserempresaCountAggregateInputType = {
    id_user_empresa?: true
    id_empresa?: true
    id_user?: true
    data_cadastrou?: true
    role?: true
    _all?: true
  }

  export type UserempresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userempresa to aggregate.
     */
    where?: userempresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userempresas to fetch.
     */
    orderBy?: userempresaOrderByWithRelationInput | userempresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userempresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userempresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userempresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userempresas
    **/
    _count?: true | UserempresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserempresaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserempresaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserempresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserempresaMaxAggregateInputType
  }

  export type GetUserempresaAggregateType<T extends UserempresaAggregateArgs> = {
        [P in keyof T & keyof AggregateUserempresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserempresa[P]>
      : GetScalarType<T[P], AggregateUserempresa[P]>
  }




  export type userempresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userempresaWhereInput
    orderBy?: userempresaOrderByWithAggregationInput | userempresaOrderByWithAggregationInput[]
    by: UserempresaScalarFieldEnum[] | UserempresaScalarFieldEnum
    having?: userempresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserempresaCountAggregateInputType | true
    _avg?: UserempresaAvgAggregateInputType
    _sum?: UserempresaSumAggregateInputType
    _min?: UserempresaMinAggregateInputType
    _max?: UserempresaMaxAggregateInputType
  }

  export type UserempresaGroupByOutputType = {
    id_user_empresa: number
    id_empresa: number
    id_user: number
    data_cadastrou: Date | null
    role: number | null
    _count: UserempresaCountAggregateOutputType | null
    _avg: UserempresaAvgAggregateOutputType | null
    _sum: UserempresaSumAggregateOutputType | null
    _min: UserempresaMinAggregateOutputType | null
    _max: UserempresaMaxAggregateOutputType | null
  }

  type GetUserempresaGroupByPayload<T extends userempresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserempresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserempresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserempresaGroupByOutputType[P]>
            : GetScalarType<T[P], UserempresaGroupByOutputType[P]>
        }
      >
    >


  export type userempresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user_empresa?: boolean
    id_empresa?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    role?: boolean
  }, ExtArgs["result"]["userempresa"]>

  export type userempresaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user_empresa?: boolean
    id_empresa?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    role?: boolean
  }, ExtArgs["result"]["userempresa"]>

  export type userempresaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user_empresa?: boolean
    id_empresa?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    role?: boolean
  }, ExtArgs["result"]["userempresa"]>

  export type userempresaSelectScalar = {
    id_user_empresa?: boolean
    id_empresa?: boolean
    id_user?: boolean
    data_cadastrou?: boolean
    role?: boolean
  }

  export type userempresaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_user_empresa" | "id_empresa" | "id_user" | "data_cadastrou" | "role", ExtArgs["result"]["userempresa"]>

  export type $userempresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userempresa"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_user_empresa: number
      id_empresa: number
      id_user: number
      data_cadastrou: Date | null
      role: number | null
    }, ExtArgs["result"]["userempresa"]>
    composites: {}
  }

  type userempresaGetPayload<S extends boolean | null | undefined | userempresaDefaultArgs> = $Result.GetResult<Prisma.$userempresaPayload, S>

  type userempresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userempresaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserempresaCountAggregateInputType | true
    }

  export interface userempresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userempresa'], meta: { name: 'userempresa' } }
    /**
     * Find zero or one Userempresa that matches the filter.
     * @param {userempresaFindUniqueArgs} args - Arguments to find a Userempresa
     * @example
     * // Get one Userempresa
     * const userempresa = await prisma.userempresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userempresaFindUniqueArgs>(args: SelectSubset<T, userempresaFindUniqueArgs<ExtArgs>>): Prisma__userempresaClient<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userempresa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userempresaFindUniqueOrThrowArgs} args - Arguments to find a Userempresa
     * @example
     * // Get one Userempresa
     * const userempresa = await prisma.userempresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userempresaFindUniqueOrThrowArgs>(args: SelectSubset<T, userempresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userempresaClient<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userempresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userempresaFindFirstArgs} args - Arguments to find a Userempresa
     * @example
     * // Get one Userempresa
     * const userempresa = await prisma.userempresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userempresaFindFirstArgs>(args?: SelectSubset<T, userempresaFindFirstArgs<ExtArgs>>): Prisma__userempresaClient<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userempresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userempresaFindFirstOrThrowArgs} args - Arguments to find a Userempresa
     * @example
     * // Get one Userempresa
     * const userempresa = await prisma.userempresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userempresaFindFirstOrThrowArgs>(args?: SelectSubset<T, userempresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__userempresaClient<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userempresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userempresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userempresas
     * const userempresas = await prisma.userempresa.findMany()
     * 
     * // Get first 10 Userempresas
     * const userempresas = await prisma.userempresa.findMany({ take: 10 })
     * 
     * // Only select the `id_user_empresa`
     * const userempresaWithId_user_empresaOnly = await prisma.userempresa.findMany({ select: { id_user_empresa: true } })
     * 
     */
    findMany<T extends userempresaFindManyArgs>(args?: SelectSubset<T, userempresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userempresa.
     * @param {userempresaCreateArgs} args - Arguments to create a Userempresa.
     * @example
     * // Create one Userempresa
     * const Userempresa = await prisma.userempresa.create({
     *   data: {
     *     // ... data to create a Userempresa
     *   }
     * })
     * 
     */
    create<T extends userempresaCreateArgs>(args: SelectSubset<T, userempresaCreateArgs<ExtArgs>>): Prisma__userempresaClient<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userempresas.
     * @param {userempresaCreateManyArgs} args - Arguments to create many Userempresas.
     * @example
     * // Create many Userempresas
     * const userempresa = await prisma.userempresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userempresaCreateManyArgs>(args?: SelectSubset<T, userempresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userempresas and returns the data saved in the database.
     * @param {userempresaCreateManyAndReturnArgs} args - Arguments to create many Userempresas.
     * @example
     * // Create many Userempresas
     * const userempresa = await prisma.userempresa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userempresas and only return the `id_user_empresa`
     * const userempresaWithId_user_empresaOnly = await prisma.userempresa.createManyAndReturn({
     *   select: { id_user_empresa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userempresaCreateManyAndReturnArgs>(args?: SelectSubset<T, userempresaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userempresa.
     * @param {userempresaDeleteArgs} args - Arguments to delete one Userempresa.
     * @example
     * // Delete one Userempresa
     * const Userempresa = await prisma.userempresa.delete({
     *   where: {
     *     // ... filter to delete one Userempresa
     *   }
     * })
     * 
     */
    delete<T extends userempresaDeleteArgs>(args: SelectSubset<T, userempresaDeleteArgs<ExtArgs>>): Prisma__userempresaClient<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userempresa.
     * @param {userempresaUpdateArgs} args - Arguments to update one Userempresa.
     * @example
     * // Update one Userempresa
     * const userempresa = await prisma.userempresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userempresaUpdateArgs>(args: SelectSubset<T, userempresaUpdateArgs<ExtArgs>>): Prisma__userempresaClient<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userempresas.
     * @param {userempresaDeleteManyArgs} args - Arguments to filter Userempresas to delete.
     * @example
     * // Delete a few Userempresas
     * const { count } = await prisma.userempresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userempresaDeleteManyArgs>(args?: SelectSubset<T, userempresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userempresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userempresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userempresas
     * const userempresa = await prisma.userempresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userempresaUpdateManyArgs>(args: SelectSubset<T, userempresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userempresas and returns the data updated in the database.
     * @param {userempresaUpdateManyAndReturnArgs} args - Arguments to update many Userempresas.
     * @example
     * // Update many Userempresas
     * const userempresa = await prisma.userempresa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userempresas and only return the `id_user_empresa`
     * const userempresaWithId_user_empresaOnly = await prisma.userempresa.updateManyAndReturn({
     *   select: { id_user_empresa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userempresaUpdateManyAndReturnArgs>(args: SelectSubset<T, userempresaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userempresa.
     * @param {userempresaUpsertArgs} args - Arguments to update or create a Userempresa.
     * @example
     * // Update or create a Userempresa
     * const userempresa = await prisma.userempresa.upsert({
     *   create: {
     *     // ... data to create a Userempresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userempresa we want to update
     *   }
     * })
     */
    upsert<T extends userempresaUpsertArgs>(args: SelectSubset<T, userempresaUpsertArgs<ExtArgs>>): Prisma__userempresaClient<$Result.GetResult<Prisma.$userempresaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userempresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userempresaCountArgs} args - Arguments to filter Userempresas to count.
     * @example
     * // Count the number of Userempresas
     * const count = await prisma.userempresa.count({
     *   where: {
     *     // ... the filter for the Userempresas we want to count
     *   }
     * })
    **/
    count<T extends userempresaCountArgs>(
      args?: Subset<T, userempresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserempresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userempresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserempresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserempresaAggregateArgs>(args: Subset<T, UserempresaAggregateArgs>): Prisma.PrismaPromise<GetUserempresaAggregateType<T>>

    /**
     * Group by Userempresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userempresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userempresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userempresaGroupByArgs['orderBy'] }
        : { orderBy?: userempresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userempresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserempresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userempresa model
   */
  readonly fields: userempresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userempresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userempresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userempresa model
   */
  interface userempresaFieldRefs {
    readonly id_user_empresa: FieldRef<"userempresa", 'Int'>
    readonly id_empresa: FieldRef<"userempresa", 'Int'>
    readonly id_user: FieldRef<"userempresa", 'Int'>
    readonly data_cadastrou: FieldRef<"userempresa", 'DateTime'>
    readonly role: FieldRef<"userempresa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * userempresa findUnique
   */
  export type userempresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * Filter, which userempresa to fetch.
     */
    where: userempresaWhereUniqueInput
  }

  /**
   * userempresa findUniqueOrThrow
   */
  export type userempresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * Filter, which userempresa to fetch.
     */
    where: userempresaWhereUniqueInput
  }

  /**
   * userempresa findFirst
   */
  export type userempresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * Filter, which userempresa to fetch.
     */
    where?: userempresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userempresas to fetch.
     */
    orderBy?: userempresaOrderByWithRelationInput | userempresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userempresas.
     */
    cursor?: userempresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userempresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userempresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userempresas.
     */
    distinct?: UserempresaScalarFieldEnum | UserempresaScalarFieldEnum[]
  }

  /**
   * userempresa findFirstOrThrow
   */
  export type userempresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * Filter, which userempresa to fetch.
     */
    where?: userempresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userempresas to fetch.
     */
    orderBy?: userempresaOrderByWithRelationInput | userempresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userempresas.
     */
    cursor?: userempresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userempresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userempresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userempresas.
     */
    distinct?: UserempresaScalarFieldEnum | UserempresaScalarFieldEnum[]
  }

  /**
   * userempresa findMany
   */
  export type userempresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * Filter, which userempresas to fetch.
     */
    where?: userempresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userempresas to fetch.
     */
    orderBy?: userempresaOrderByWithRelationInput | userempresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userempresas.
     */
    cursor?: userempresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userempresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userempresas.
     */
    skip?: number
    distinct?: UserempresaScalarFieldEnum | UserempresaScalarFieldEnum[]
  }

  /**
   * userempresa create
   */
  export type userempresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * The data needed to create a userempresa.
     */
    data: XOR<userempresaCreateInput, userempresaUncheckedCreateInput>
  }

  /**
   * userempresa createMany
   */
  export type userempresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userempresas.
     */
    data: userempresaCreateManyInput | userempresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userempresa createManyAndReturn
   */
  export type userempresaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * The data used to create many userempresas.
     */
    data: userempresaCreateManyInput | userempresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userempresa update
   */
  export type userempresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * The data needed to update a userempresa.
     */
    data: XOR<userempresaUpdateInput, userempresaUncheckedUpdateInput>
    /**
     * Choose, which userempresa to update.
     */
    where: userempresaWhereUniqueInput
  }

  /**
   * userempresa updateMany
   */
  export type userempresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userempresas.
     */
    data: XOR<userempresaUpdateManyMutationInput, userempresaUncheckedUpdateManyInput>
    /**
     * Filter which userempresas to update
     */
    where?: userempresaWhereInput
    /**
     * Limit how many userempresas to update.
     */
    limit?: number
  }

  /**
   * userempresa updateManyAndReturn
   */
  export type userempresaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * The data used to update userempresas.
     */
    data: XOR<userempresaUpdateManyMutationInput, userempresaUncheckedUpdateManyInput>
    /**
     * Filter which userempresas to update
     */
    where?: userempresaWhereInput
    /**
     * Limit how many userempresas to update.
     */
    limit?: number
  }

  /**
   * userempresa upsert
   */
  export type userempresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * The filter to search for the userempresa to update in case it exists.
     */
    where: userempresaWhereUniqueInput
    /**
     * In case the userempresa found by the `where` argument doesn't exist, create a new userempresa with this data.
     */
    create: XOR<userempresaCreateInput, userempresaUncheckedCreateInput>
    /**
     * In case the userempresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userempresaUpdateInput, userempresaUncheckedUpdateInput>
  }

  /**
   * userempresa delete
   */
  export type userempresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
    /**
     * Filter which userempresa to delete.
     */
    where: userempresaWhereUniqueInput
  }

  /**
   * userempresa deleteMany
   */
  export type userempresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userempresas to delete
     */
    where?: userempresaWhereInput
    /**
     * Limit how many userempresas to delete.
     */
    limit?: number
  }

  /**
   * userempresa without action
   */
  export type userempresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userempresa
     */
    select?: userempresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userempresa
     */
    omit?: userempresaOmit<ExtArgs> | null
  }


  /**
   * Model lista
   */

  export type AggregateLista = {
    _count: ListaCountAggregateOutputType | null
    _avg: ListaAvgAggregateOutputType | null
    _sum: ListaSumAggregateOutputType | null
    _min: ListaMinAggregateOutputType | null
    _max: ListaMaxAggregateOutputType | null
  }

  export type ListaAvgAggregateOutputType = {
    id_lista: number | null
    id_empresa: number | null
    ativo: number | null
  }

  export type ListaSumAggregateOutputType = {
    id_lista: number | null
    id_empresa: number | null
    ativo: number | null
  }

  export type ListaMinAggregateOutputType = {
    id_lista: number | null
    id_empresa: number | null
    nome_lista: string | null
    ativo: number | null
    descricao: string | null
    data_cadastrou: Date | null
    data_vigencia_inicio: Date | null
    data_vigencia_fim: Date | null
    uid: string | null
  }

  export type ListaMaxAggregateOutputType = {
    id_lista: number | null
    id_empresa: number | null
    nome_lista: string | null
    ativo: number | null
    descricao: string | null
    data_cadastrou: Date | null
    data_vigencia_inicio: Date | null
    data_vigencia_fim: Date | null
    uid: string | null
  }

  export type ListaCountAggregateOutputType = {
    id_lista: number
    id_empresa: number
    nome_lista: number
    ativo: number
    descricao: number
    data_cadastrou: number
    data_vigencia_inicio: number
    data_vigencia_fim: number
    uid: number
    _all: number
  }


  export type ListaAvgAggregateInputType = {
    id_lista?: true
    id_empresa?: true
    ativo?: true
  }

  export type ListaSumAggregateInputType = {
    id_lista?: true
    id_empresa?: true
    ativo?: true
  }

  export type ListaMinAggregateInputType = {
    id_lista?: true
    id_empresa?: true
    nome_lista?: true
    ativo?: true
    descricao?: true
    data_cadastrou?: true
    data_vigencia_inicio?: true
    data_vigencia_fim?: true
    uid?: true
  }

  export type ListaMaxAggregateInputType = {
    id_lista?: true
    id_empresa?: true
    nome_lista?: true
    ativo?: true
    descricao?: true
    data_cadastrou?: true
    data_vigencia_inicio?: true
    data_vigencia_fim?: true
    uid?: true
  }

  export type ListaCountAggregateInputType = {
    id_lista?: true
    id_empresa?: true
    nome_lista?: true
    ativo?: true
    descricao?: true
    data_cadastrou?: true
    data_vigencia_inicio?: true
    data_vigencia_fim?: true
    uid?: true
    _all?: true
  }

  export type ListaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lista to aggregate.
     */
    where?: listaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listas to fetch.
     */
    orderBy?: listaOrderByWithRelationInput | listaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: listaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned listas
    **/
    _count?: true | ListaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListaMaxAggregateInputType
  }

  export type GetListaAggregateType<T extends ListaAggregateArgs> = {
        [P in keyof T & keyof AggregateLista]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLista[P]>
      : GetScalarType<T[P], AggregateLista[P]>
  }




  export type listaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: listaWhereInput
    orderBy?: listaOrderByWithAggregationInput | listaOrderByWithAggregationInput[]
    by: ListaScalarFieldEnum[] | ListaScalarFieldEnum
    having?: listaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListaCountAggregateInputType | true
    _avg?: ListaAvgAggregateInputType
    _sum?: ListaSumAggregateInputType
    _min?: ListaMinAggregateInputType
    _max?: ListaMaxAggregateInputType
  }

  export type ListaGroupByOutputType = {
    id_lista: number
    id_empresa: number
    nome_lista: string
    ativo: number | null
    descricao: string
    data_cadastrou: Date | null
    data_vigencia_inicio: Date | null
    data_vigencia_fim: Date | null
    uid: string | null
    _count: ListaCountAggregateOutputType | null
    _avg: ListaAvgAggregateOutputType | null
    _sum: ListaSumAggregateOutputType | null
    _min: ListaMinAggregateOutputType | null
    _max: ListaMaxAggregateOutputType | null
  }

  type GetListaGroupByPayload<T extends listaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListaGroupByOutputType[P]>
            : GetScalarType<T[P], ListaGroupByOutputType[P]>
        }
      >
    >


  export type listaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_lista?: boolean
    id_empresa?: boolean
    nome_lista?: boolean
    ativo?: boolean
    descricao?: boolean
    data_cadastrou?: boolean
    data_vigencia_inicio?: boolean
    data_vigencia_fim?: boolean
    uid?: boolean
  }, ExtArgs["result"]["lista"]>

  export type listaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_lista?: boolean
    id_empresa?: boolean
    nome_lista?: boolean
    ativo?: boolean
    descricao?: boolean
    data_cadastrou?: boolean
    data_vigencia_inicio?: boolean
    data_vigencia_fim?: boolean
    uid?: boolean
  }, ExtArgs["result"]["lista"]>

  export type listaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_lista?: boolean
    id_empresa?: boolean
    nome_lista?: boolean
    ativo?: boolean
    descricao?: boolean
    data_cadastrou?: boolean
    data_vigencia_inicio?: boolean
    data_vigencia_fim?: boolean
    uid?: boolean
  }, ExtArgs["result"]["lista"]>

  export type listaSelectScalar = {
    id_lista?: boolean
    id_empresa?: boolean
    nome_lista?: boolean
    ativo?: boolean
    descricao?: boolean
    data_cadastrou?: boolean
    data_vigencia_inicio?: boolean
    data_vigencia_fim?: boolean
    uid?: boolean
  }

  export type listaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_lista" | "id_empresa" | "nome_lista" | "ativo" | "descricao" | "data_cadastrou" | "data_vigencia_inicio" | "data_vigencia_fim" | "uid", ExtArgs["result"]["lista"]>

  export type $listaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lista"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_lista: number
      id_empresa: number
      nome_lista: string
      ativo: number | null
      descricao: string
      data_cadastrou: Date | null
      data_vigencia_inicio: Date | null
      data_vigencia_fim: Date | null
      uid: string | null
    }, ExtArgs["result"]["lista"]>
    composites: {}
  }

  type listaGetPayload<S extends boolean | null | undefined | listaDefaultArgs> = $Result.GetResult<Prisma.$listaPayload, S>

  type listaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<listaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListaCountAggregateInputType | true
    }

  export interface listaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lista'], meta: { name: 'lista' } }
    /**
     * Find zero or one Lista that matches the filter.
     * @param {listaFindUniqueArgs} args - Arguments to find a Lista
     * @example
     * // Get one Lista
     * const lista = await prisma.lista.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends listaFindUniqueArgs>(args: SelectSubset<T, listaFindUniqueArgs<ExtArgs>>): Prisma__listaClient<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lista that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {listaFindUniqueOrThrowArgs} args - Arguments to find a Lista
     * @example
     * // Get one Lista
     * const lista = await prisma.lista.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends listaFindUniqueOrThrowArgs>(args: SelectSubset<T, listaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__listaClient<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lista that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaFindFirstArgs} args - Arguments to find a Lista
     * @example
     * // Get one Lista
     * const lista = await prisma.lista.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends listaFindFirstArgs>(args?: SelectSubset<T, listaFindFirstArgs<ExtArgs>>): Prisma__listaClient<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lista that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaFindFirstOrThrowArgs} args - Arguments to find a Lista
     * @example
     * // Get one Lista
     * const lista = await prisma.lista.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends listaFindFirstOrThrowArgs>(args?: SelectSubset<T, listaFindFirstOrThrowArgs<ExtArgs>>): Prisma__listaClient<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Listas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listas
     * const listas = await prisma.lista.findMany()
     * 
     * // Get first 10 Listas
     * const listas = await prisma.lista.findMany({ take: 10 })
     * 
     * // Only select the `id_lista`
     * const listaWithId_listaOnly = await prisma.lista.findMany({ select: { id_lista: true } })
     * 
     */
    findMany<T extends listaFindManyArgs>(args?: SelectSubset<T, listaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lista.
     * @param {listaCreateArgs} args - Arguments to create a Lista.
     * @example
     * // Create one Lista
     * const Lista = await prisma.lista.create({
     *   data: {
     *     // ... data to create a Lista
     *   }
     * })
     * 
     */
    create<T extends listaCreateArgs>(args: SelectSubset<T, listaCreateArgs<ExtArgs>>): Prisma__listaClient<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Listas.
     * @param {listaCreateManyArgs} args - Arguments to create many Listas.
     * @example
     * // Create many Listas
     * const lista = await prisma.lista.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends listaCreateManyArgs>(args?: SelectSubset<T, listaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Listas and returns the data saved in the database.
     * @param {listaCreateManyAndReturnArgs} args - Arguments to create many Listas.
     * @example
     * // Create many Listas
     * const lista = await prisma.lista.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Listas and only return the `id_lista`
     * const listaWithId_listaOnly = await prisma.lista.createManyAndReturn({
     *   select: { id_lista: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends listaCreateManyAndReturnArgs>(args?: SelectSubset<T, listaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lista.
     * @param {listaDeleteArgs} args - Arguments to delete one Lista.
     * @example
     * // Delete one Lista
     * const Lista = await prisma.lista.delete({
     *   where: {
     *     // ... filter to delete one Lista
     *   }
     * })
     * 
     */
    delete<T extends listaDeleteArgs>(args: SelectSubset<T, listaDeleteArgs<ExtArgs>>): Prisma__listaClient<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lista.
     * @param {listaUpdateArgs} args - Arguments to update one Lista.
     * @example
     * // Update one Lista
     * const lista = await prisma.lista.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends listaUpdateArgs>(args: SelectSubset<T, listaUpdateArgs<ExtArgs>>): Prisma__listaClient<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Listas.
     * @param {listaDeleteManyArgs} args - Arguments to filter Listas to delete.
     * @example
     * // Delete a few Listas
     * const { count } = await prisma.lista.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends listaDeleteManyArgs>(args?: SelectSubset<T, listaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listas
     * const lista = await prisma.lista.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends listaUpdateManyArgs>(args: SelectSubset<T, listaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listas and returns the data updated in the database.
     * @param {listaUpdateManyAndReturnArgs} args - Arguments to update many Listas.
     * @example
     * // Update many Listas
     * const lista = await prisma.lista.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Listas and only return the `id_lista`
     * const listaWithId_listaOnly = await prisma.lista.updateManyAndReturn({
     *   select: { id_lista: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends listaUpdateManyAndReturnArgs>(args: SelectSubset<T, listaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lista.
     * @param {listaUpsertArgs} args - Arguments to update or create a Lista.
     * @example
     * // Update or create a Lista
     * const lista = await prisma.lista.upsert({
     *   create: {
     *     // ... data to create a Lista
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lista we want to update
     *   }
     * })
     */
    upsert<T extends listaUpsertArgs>(args: SelectSubset<T, listaUpsertArgs<ExtArgs>>): Prisma__listaClient<$Result.GetResult<Prisma.$listaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Listas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaCountArgs} args - Arguments to filter Listas to count.
     * @example
     * // Count the number of Listas
     * const count = await prisma.lista.count({
     *   where: {
     *     // ... the filter for the Listas we want to count
     *   }
     * })
    **/
    count<T extends listaCountArgs>(
      args?: Subset<T, listaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListaAggregateArgs>(args: Subset<T, ListaAggregateArgs>): Prisma.PrismaPromise<GetListaAggregateType<T>>

    /**
     * Group by Lista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends listaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: listaGroupByArgs['orderBy'] }
        : { orderBy?: listaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, listaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lista model
   */
  readonly fields: listaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lista.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__listaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lista model
   */
  interface listaFieldRefs {
    readonly id_lista: FieldRef<"lista", 'Int'>
    readonly id_empresa: FieldRef<"lista", 'Int'>
    readonly nome_lista: FieldRef<"lista", 'String'>
    readonly ativo: FieldRef<"lista", 'Int'>
    readonly descricao: FieldRef<"lista", 'String'>
    readonly data_cadastrou: FieldRef<"lista", 'DateTime'>
    readonly data_vigencia_inicio: FieldRef<"lista", 'DateTime'>
    readonly data_vigencia_fim: FieldRef<"lista", 'DateTime'>
    readonly uid: FieldRef<"lista", 'String'>
  }
    

  // Custom InputTypes
  /**
   * lista findUnique
   */
  export type listaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * Filter, which lista to fetch.
     */
    where: listaWhereUniqueInput
  }

  /**
   * lista findUniqueOrThrow
   */
  export type listaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * Filter, which lista to fetch.
     */
    where: listaWhereUniqueInput
  }

  /**
   * lista findFirst
   */
  export type listaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * Filter, which lista to fetch.
     */
    where?: listaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listas to fetch.
     */
    orderBy?: listaOrderByWithRelationInput | listaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for listas.
     */
    cursor?: listaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of listas.
     */
    distinct?: ListaScalarFieldEnum | ListaScalarFieldEnum[]
  }

  /**
   * lista findFirstOrThrow
   */
  export type listaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * Filter, which lista to fetch.
     */
    where?: listaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listas to fetch.
     */
    orderBy?: listaOrderByWithRelationInput | listaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for listas.
     */
    cursor?: listaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of listas.
     */
    distinct?: ListaScalarFieldEnum | ListaScalarFieldEnum[]
  }

  /**
   * lista findMany
   */
  export type listaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * Filter, which listas to fetch.
     */
    where?: listaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listas to fetch.
     */
    orderBy?: listaOrderByWithRelationInput | listaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing listas.
     */
    cursor?: listaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listas.
     */
    skip?: number
    distinct?: ListaScalarFieldEnum | ListaScalarFieldEnum[]
  }

  /**
   * lista create
   */
  export type listaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * The data needed to create a lista.
     */
    data: XOR<listaCreateInput, listaUncheckedCreateInput>
  }

  /**
   * lista createMany
   */
  export type listaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many listas.
     */
    data: listaCreateManyInput | listaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lista createManyAndReturn
   */
  export type listaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * The data used to create many listas.
     */
    data: listaCreateManyInput | listaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lista update
   */
  export type listaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * The data needed to update a lista.
     */
    data: XOR<listaUpdateInput, listaUncheckedUpdateInput>
    /**
     * Choose, which lista to update.
     */
    where: listaWhereUniqueInput
  }

  /**
   * lista updateMany
   */
  export type listaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update listas.
     */
    data: XOR<listaUpdateManyMutationInput, listaUncheckedUpdateManyInput>
    /**
     * Filter which listas to update
     */
    where?: listaWhereInput
    /**
     * Limit how many listas to update.
     */
    limit?: number
  }

  /**
   * lista updateManyAndReturn
   */
  export type listaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * The data used to update listas.
     */
    data: XOR<listaUpdateManyMutationInput, listaUncheckedUpdateManyInput>
    /**
     * Filter which listas to update
     */
    where?: listaWhereInput
    /**
     * Limit how many listas to update.
     */
    limit?: number
  }

  /**
   * lista upsert
   */
  export type listaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * The filter to search for the lista to update in case it exists.
     */
    where: listaWhereUniqueInput
    /**
     * In case the lista found by the `where` argument doesn't exist, create a new lista with this data.
     */
    create: XOR<listaCreateInput, listaUncheckedCreateInput>
    /**
     * In case the lista was found with the provided `where` argument, update it with this data.
     */
    update: XOR<listaUpdateInput, listaUncheckedUpdateInput>
  }

  /**
   * lista delete
   */
  export type listaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
    /**
     * Filter which lista to delete.
     */
    where: listaWhereUniqueInput
  }

  /**
   * lista deleteMany
   */
  export type listaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which listas to delete
     */
    where?: listaWhereInput
    /**
     * Limit how many listas to delete.
     */
    limit?: number
  }

  /**
   * lista without action
   */
  export type listaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null
  }


  /**
   * Model categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id_categoria: number | null
    id_empresa: number | null
    ativo: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id_categoria: number | null
    id_empresa: number | null
    ativo: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id_categoria: number | null
    id_empresa: number | null
    nome_categoria: string | null
    ativo: number | null
    data_cadastrou: Date | null
    data_update: Date | null
    icon: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id_categoria: number | null
    id_empresa: number | null
    nome_categoria: string | null
    ativo: number | null
    data_cadastrou: Date | null
    data_update: Date | null
    icon: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id_categoria: number
    id_empresa: number
    nome_categoria: number
    ativo: number
    data_cadastrou: number
    data_update: number
    icon: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id_categoria?: true
    id_empresa?: true
    ativo?: true
  }

  export type CategoriaSumAggregateInputType = {
    id_categoria?: true
    id_empresa?: true
    ativo?: true
  }

  export type CategoriaMinAggregateInputType = {
    id_categoria?: true
    id_empresa?: true
    nome_categoria?: true
    ativo?: true
    data_cadastrou?: true
    data_update?: true
    icon?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id_categoria?: true
    id_empresa?: true
    nome_categoria?: true
    ativo?: true
    data_cadastrou?: true
    data_update?: true
    icon?: true
  }

  export type CategoriaCountAggregateInputType = {
    id_categoria?: true
    id_empresa?: true
    nome_categoria?: true
    ativo?: true
    data_cadastrou?: true
    data_update?: true
    icon?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoria to aggregate.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type categoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriaWhereInput
    orderBy?: categoriaOrderByWithAggregationInput | categoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: categoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    id_categoria: number
    id_empresa: number
    nome_categoria: string
    ativo: number
    data_cadastrou: Date | null
    data_update: Date | null
    icon: string | null
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends categoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type categoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_categoria?: boolean
    id_empresa?: boolean
    nome_categoria?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    data_update?: boolean
    icon?: boolean
    produtos?: boolean | categoria$produtosArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type categoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_categoria?: boolean
    id_empresa?: boolean
    nome_categoria?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    data_update?: boolean
    icon?: boolean
  }, ExtArgs["result"]["categoria"]>

  export type categoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_categoria?: boolean
    id_empresa?: boolean
    nome_categoria?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    data_update?: boolean
    icon?: boolean
  }, ExtArgs["result"]["categoria"]>

  export type categoriaSelectScalar = {
    id_categoria?: boolean
    id_empresa?: boolean
    nome_categoria?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    data_update?: boolean
    icon?: boolean
  }

  export type categoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_categoria" | "id_empresa" | "nome_categoria" | "ativo" | "data_cadastrou" | "data_update" | "icon", ExtArgs["result"]["categoria"]>
  export type categoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produtos?: boolean | categoria$produtosArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type categoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categoria"
    objects: {
      produtos: Prisma.$produtoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_categoria: number
      id_empresa: number
      nome_categoria: string
      ativo: number
      data_cadastrou: Date | null
      data_update: Date | null
      icon: string | null
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }

  type categoriaGetPayload<S extends boolean | null | undefined | categoriaDefaultArgs> = $Result.GetResult<Prisma.$categoriaPayload, S>

  type categoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface categoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categoria'], meta: { name: 'categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {categoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriaFindUniqueArgs>(args: SelectSubset<T, categoriaFindUniqueArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriaFindFirstArgs>(args?: SelectSubset<T, categoriaFindFirstArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id_categoria`
     * const categoriaWithId_categoriaOnly = await prisma.categoria.findMany({ select: { id_categoria: true } })
     * 
     */
    findMany<T extends categoriaFindManyArgs>(args?: SelectSubset<T, categoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categoria.
     * @param {categoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
     */
    create<T extends categoriaCreateArgs>(args: SelectSubset<T, categoriaCreateArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categorias.
     * @param {categoriaCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriaCreateManyArgs>(args?: SelectSubset<T, categoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categorias and returns the data saved in the database.
     * @param {categoriaCreateManyAndReturnArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categorias and only return the `id_categoria`
     * const categoriaWithId_categoriaOnly = await prisma.categoria.createManyAndReturn({
     *   select: { id_categoria: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categoria.
     * @param {categoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
     */
    delete<T extends categoriaDeleteArgs>(args: SelectSubset<T, categoriaDeleteArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categoria.
     * @param {categoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriaUpdateArgs>(args: SelectSubset<T, categoriaUpdateArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categorias.
     * @param {categoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriaDeleteManyArgs>(args?: SelectSubset<T, categoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriaUpdateManyArgs>(args: SelectSubset<T, categoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias and returns the data updated in the database.
     * @param {categoriaUpdateManyAndReturnArgs} args - Arguments to update many Categorias.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categorias and only return the `id_categoria`
     * const categoriaWithId_categoriaOnly = await prisma.categoria.updateManyAndReturn({
     *   select: { id_categoria: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categoria.
     * @param {categoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
     */
    upsert<T extends categoriaUpsertArgs>(args: SelectSubset<T, categoriaUpsertArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends categoriaCountArgs>(
      args?: Subset<T, categoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriaGroupByArgs['orderBy'] }
        : { orderBy?: categoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categoria model
   */
  readonly fields: categoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    produtos<T extends categoria$produtosArgs<ExtArgs> = {}>(args?: Subset<T, categoria$produtosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categoria model
   */
  interface categoriaFieldRefs {
    readonly id_categoria: FieldRef<"categoria", 'Int'>
    readonly id_empresa: FieldRef<"categoria", 'Int'>
    readonly nome_categoria: FieldRef<"categoria", 'String'>
    readonly ativo: FieldRef<"categoria", 'Int'>
    readonly data_cadastrou: FieldRef<"categoria", 'DateTime'>
    readonly data_update: FieldRef<"categoria", 'DateTime'>
    readonly icon: FieldRef<"categoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * categoria findUnique
   */
  export type categoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where: categoriaWhereUniqueInput
  }

  /**
   * categoria findUniqueOrThrow
   */
  export type categoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where: categoriaWhereUniqueInput
  }

  /**
   * categoria findFirst
   */
  export type categoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * categoria findFirstOrThrow
   */
  export type categoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * categoria findMany
   */
  export type categoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categorias.
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * categoria create
   */
  export type categoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a categoria.
     */
    data: XOR<categoriaCreateInput, categoriaUncheckedCreateInput>
  }

  /**
   * categoria createMany
   */
  export type categoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categorias.
     */
    data: categoriaCreateManyInput | categoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categoria createManyAndReturn
   */
  export type categoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * The data used to create many categorias.
     */
    data: categoriaCreateManyInput | categoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categoria update
   */
  export type categoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a categoria.
     */
    data: XOR<categoriaUpdateInput, categoriaUncheckedUpdateInput>
    /**
     * Choose, which categoria to update.
     */
    where: categoriaWhereUniqueInput
  }

  /**
   * categoria updateMany
   */
  export type categoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriaUpdateManyMutationInput, categoriaUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriaWhereInput
    /**
     * Limit how many categorias to update.
     */
    limit?: number
  }

  /**
   * categoria updateManyAndReturn
   */
  export type categoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriaUpdateManyMutationInput, categoriaUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriaWhereInput
    /**
     * Limit how many categorias to update.
     */
    limit?: number
  }

  /**
   * categoria upsert
   */
  export type categoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the categoria to update in case it exists.
     */
    where: categoriaWhereUniqueInput
    /**
     * In case the categoria found by the `where` argument doesn't exist, create a new categoria with this data.
     */
    create: XOR<categoriaCreateInput, categoriaUncheckedCreateInput>
    /**
     * In case the categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriaUpdateInput, categoriaUncheckedUpdateInput>
  }

  /**
   * categoria delete
   */
  export type categoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter which categoria to delete.
     */
    where: categoriaWhereUniqueInput
  }

  /**
   * categoria deleteMany
   */
  export type categoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categorias to delete
     */
    where?: categoriaWhereInput
    /**
     * Limit how many categorias to delete.
     */
    limit?: number
  }

  /**
   * categoria.produtos
   */
  export type categoria$produtosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    where?: produtoWhereInput
    orderBy?: produtoOrderByWithRelationInput | produtoOrderByWithRelationInput[]
    cursor?: produtoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * categoria without action
   */
  export type categoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
  }


  /**
   * Model produto
   */

  export type AggregateProduto = {
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  export type ProdutoAvgAggregateOutputType = {
    id_produto: number | null
    id_empresa: number | null
    id_categoria: number | null
    valor: number | null
    ativo: number | null
  }

  export type ProdutoSumAggregateOutputType = {
    id_produto: number | null
    id_empresa: number | null
    id_categoria: number | null
    valor: number | null
    ativo: number | null
  }

  export type ProdutoMinAggregateOutputType = {
    id_produto: number | null
    id_empresa: number | null
    id_categoria: number | null
    nome_produto: string | null
    valor: number | null
    ativo: number | null
    data_cadastrou: Date | null
    descricao: string | null
  }

  export type ProdutoMaxAggregateOutputType = {
    id_produto: number | null
    id_empresa: number | null
    id_categoria: number | null
    nome_produto: string | null
    valor: number | null
    ativo: number | null
    data_cadastrou: Date | null
    descricao: string | null
  }

  export type ProdutoCountAggregateOutputType = {
    id_produto: number
    id_empresa: number
    id_categoria: number
    nome_produto: number
    valor: number
    ativo: number
    data_cadastrou: number
    descricao: number
    _all: number
  }


  export type ProdutoAvgAggregateInputType = {
    id_produto?: true
    id_empresa?: true
    id_categoria?: true
    valor?: true
    ativo?: true
  }

  export type ProdutoSumAggregateInputType = {
    id_produto?: true
    id_empresa?: true
    id_categoria?: true
    valor?: true
    ativo?: true
  }

  export type ProdutoMinAggregateInputType = {
    id_produto?: true
    id_empresa?: true
    id_categoria?: true
    nome_produto?: true
    valor?: true
    ativo?: true
    data_cadastrou?: true
    descricao?: true
  }

  export type ProdutoMaxAggregateInputType = {
    id_produto?: true
    id_empresa?: true
    id_categoria?: true
    nome_produto?: true
    valor?: true
    ativo?: true
    data_cadastrou?: true
    descricao?: true
  }

  export type ProdutoCountAggregateInputType = {
    id_produto?: true
    id_empresa?: true
    id_categoria?: true
    nome_produto?: true
    valor?: true
    ativo?: true
    data_cadastrou?: true
    descricao?: true
    _all?: true
  }

  export type ProdutoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produto to aggregate.
     */
    where?: produtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produtos to fetch.
     */
    orderBy?: produtoOrderByWithRelationInput | produtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: produtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned produtos
    **/
    _count?: true | ProdutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdutoMaxAggregateInputType
  }

  export type GetProdutoAggregateType<T extends ProdutoAggregateArgs> = {
        [P in keyof T & keyof AggregateProduto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduto[P]>
      : GetScalarType<T[P], AggregateProduto[P]>
  }




  export type produtoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produtoWhereInput
    orderBy?: produtoOrderByWithAggregationInput | produtoOrderByWithAggregationInput[]
    by: ProdutoScalarFieldEnum[] | ProdutoScalarFieldEnum
    having?: produtoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdutoCountAggregateInputType | true
    _avg?: ProdutoAvgAggregateInputType
    _sum?: ProdutoSumAggregateInputType
    _min?: ProdutoMinAggregateInputType
    _max?: ProdutoMaxAggregateInputType
  }

  export type ProdutoGroupByOutputType = {
    id_produto: number
    id_empresa: number
    id_categoria: number
    nome_produto: string
    valor: number
    ativo: number
    data_cadastrou: Date | null
    descricao: string
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  type GetProdutoGroupByPayload<T extends produtoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
            : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
        }
      >
    >


  export type produtoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_produto?: boolean
    id_empresa?: boolean
    id_categoria?: boolean
    nome_produto?: boolean
    valor?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    descricao?: boolean
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>

  export type produtoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_produto?: boolean
    id_empresa?: boolean
    id_categoria?: boolean
    nome_produto?: boolean
    valor?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    descricao?: boolean
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>

  export type produtoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_produto?: boolean
    id_empresa?: boolean
    id_categoria?: boolean
    nome_produto?: boolean
    valor?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    descricao?: boolean
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>

  export type produtoSelectScalar = {
    id_produto?: boolean
    id_empresa?: boolean
    id_categoria?: boolean
    nome_produto?: boolean
    valor?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    descricao?: boolean
  }

  export type produtoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_produto" | "id_empresa" | "id_categoria" | "nome_produto" | "valor" | "ativo" | "data_cadastrou" | "descricao", ExtArgs["result"]["produto"]>
  export type produtoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }
  export type produtoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }
  export type produtoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }

  export type $produtoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "produto"
    objects: {
      categoria: Prisma.$categoriaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_produto: number
      id_empresa: number
      id_categoria: number
      nome_produto: string
      valor: number
      ativo: number
      data_cadastrou: Date | null
      descricao: string
    }, ExtArgs["result"]["produto"]>
    composites: {}
  }

  type produtoGetPayload<S extends boolean | null | undefined | produtoDefaultArgs> = $Result.GetResult<Prisma.$produtoPayload, S>

  type produtoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<produtoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProdutoCountAggregateInputType | true
    }

  export interface produtoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['produto'], meta: { name: 'produto' } }
    /**
     * Find zero or one Produto that matches the filter.
     * @param {produtoFindUniqueArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends produtoFindUniqueArgs>(args: SelectSubset<T, produtoFindUniqueArgs<ExtArgs>>): Prisma__produtoClient<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Produto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {produtoFindUniqueOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends produtoFindUniqueOrThrowArgs>(args: SelectSubset<T, produtoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__produtoClient<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produtoFindFirstArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends produtoFindFirstArgs>(args?: SelectSubset<T, produtoFindFirstArgs<ExtArgs>>): Prisma__produtoClient<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produtoFindFirstOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends produtoFindFirstOrThrowArgs>(args?: SelectSubset<T, produtoFindFirstOrThrowArgs<ExtArgs>>): Prisma__produtoClient<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Produtos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produtoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produtos
     * const produtos = await prisma.produto.findMany()
     * 
     * // Get first 10 Produtos
     * const produtos = await prisma.produto.findMany({ take: 10 })
     * 
     * // Only select the `id_produto`
     * const produtoWithId_produtoOnly = await prisma.produto.findMany({ select: { id_produto: true } })
     * 
     */
    findMany<T extends produtoFindManyArgs>(args?: SelectSubset<T, produtoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Produto.
     * @param {produtoCreateArgs} args - Arguments to create a Produto.
     * @example
     * // Create one Produto
     * const Produto = await prisma.produto.create({
     *   data: {
     *     // ... data to create a Produto
     *   }
     * })
     * 
     */
    create<T extends produtoCreateArgs>(args: SelectSubset<T, produtoCreateArgs<ExtArgs>>): Prisma__produtoClient<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Produtos.
     * @param {produtoCreateManyArgs} args - Arguments to create many Produtos.
     * @example
     * // Create many Produtos
     * const produto = await prisma.produto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends produtoCreateManyArgs>(args?: SelectSubset<T, produtoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Produtos and returns the data saved in the database.
     * @param {produtoCreateManyAndReturnArgs} args - Arguments to create many Produtos.
     * @example
     * // Create many Produtos
     * const produto = await prisma.produto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Produtos and only return the `id_produto`
     * const produtoWithId_produtoOnly = await prisma.produto.createManyAndReturn({
     *   select: { id_produto: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends produtoCreateManyAndReturnArgs>(args?: SelectSubset<T, produtoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Produto.
     * @param {produtoDeleteArgs} args - Arguments to delete one Produto.
     * @example
     * // Delete one Produto
     * const Produto = await prisma.produto.delete({
     *   where: {
     *     // ... filter to delete one Produto
     *   }
     * })
     * 
     */
    delete<T extends produtoDeleteArgs>(args: SelectSubset<T, produtoDeleteArgs<ExtArgs>>): Prisma__produtoClient<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Produto.
     * @param {produtoUpdateArgs} args - Arguments to update one Produto.
     * @example
     * // Update one Produto
     * const produto = await prisma.produto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends produtoUpdateArgs>(args: SelectSubset<T, produtoUpdateArgs<ExtArgs>>): Prisma__produtoClient<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Produtos.
     * @param {produtoDeleteManyArgs} args - Arguments to filter Produtos to delete.
     * @example
     * // Delete a few Produtos
     * const { count } = await prisma.produto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends produtoDeleteManyArgs>(args?: SelectSubset<T, produtoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produtoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produtos
     * const produto = await prisma.produto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends produtoUpdateManyArgs>(args: SelectSubset<T, produtoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produtos and returns the data updated in the database.
     * @param {produtoUpdateManyAndReturnArgs} args - Arguments to update many Produtos.
     * @example
     * // Update many Produtos
     * const produto = await prisma.produto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Produtos and only return the `id_produto`
     * const produtoWithId_produtoOnly = await prisma.produto.updateManyAndReturn({
     *   select: { id_produto: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends produtoUpdateManyAndReturnArgs>(args: SelectSubset<T, produtoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Produto.
     * @param {produtoUpsertArgs} args - Arguments to update or create a Produto.
     * @example
     * // Update or create a Produto
     * const produto = await prisma.produto.upsert({
     *   create: {
     *     // ... data to create a Produto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produto we want to update
     *   }
     * })
     */
    upsert<T extends produtoUpsertArgs>(args: SelectSubset<T, produtoUpsertArgs<ExtArgs>>): Prisma__produtoClient<$Result.GetResult<Prisma.$produtoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produtoCountArgs} args - Arguments to filter Produtos to count.
     * @example
     * // Count the number of Produtos
     * const count = await prisma.produto.count({
     *   where: {
     *     // ... the filter for the Produtos we want to count
     *   }
     * })
    **/
    count<T extends produtoCountArgs>(
      args?: Subset<T, produtoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdutoAggregateArgs>(args: Subset<T, ProdutoAggregateArgs>): Prisma.PrismaPromise<GetProdutoAggregateType<T>>

    /**
     * Group by Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produtoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends produtoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: produtoGroupByArgs['orderBy'] }
        : { orderBy?: produtoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, produtoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the produto model
   */
  readonly fields: produtoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for produto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__produtoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categoria<T extends categoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriaDefaultArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the produto model
   */
  interface produtoFieldRefs {
    readonly id_produto: FieldRef<"produto", 'Int'>
    readonly id_empresa: FieldRef<"produto", 'Int'>
    readonly id_categoria: FieldRef<"produto", 'Int'>
    readonly nome_produto: FieldRef<"produto", 'String'>
    readonly valor: FieldRef<"produto", 'Float'>
    readonly ativo: FieldRef<"produto", 'Int'>
    readonly data_cadastrou: FieldRef<"produto", 'DateTime'>
    readonly descricao: FieldRef<"produto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * produto findUnique
   */
  export type produtoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    /**
     * Filter, which produto to fetch.
     */
    where: produtoWhereUniqueInput
  }

  /**
   * produto findUniqueOrThrow
   */
  export type produtoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    /**
     * Filter, which produto to fetch.
     */
    where: produtoWhereUniqueInput
  }

  /**
   * produto findFirst
   */
  export type produtoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    /**
     * Filter, which produto to fetch.
     */
    where?: produtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produtos to fetch.
     */
    orderBy?: produtoOrderByWithRelationInput | produtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produtos.
     */
    cursor?: produtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * produto findFirstOrThrow
   */
  export type produtoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    /**
     * Filter, which produto to fetch.
     */
    where?: produtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produtos to fetch.
     */
    orderBy?: produtoOrderByWithRelationInput | produtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produtos.
     */
    cursor?: produtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * produto findMany
   */
  export type produtoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    /**
     * Filter, which produtos to fetch.
     */
    where?: produtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produtos to fetch.
     */
    orderBy?: produtoOrderByWithRelationInput | produtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing produtos.
     */
    cursor?: produtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produtos.
     */
    skip?: number
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * produto create
   */
  export type produtoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    /**
     * The data needed to create a produto.
     */
    data: XOR<produtoCreateInput, produtoUncheckedCreateInput>
  }

  /**
   * produto createMany
   */
  export type produtoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many produtos.
     */
    data: produtoCreateManyInput | produtoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * produto createManyAndReturn
   */
  export type produtoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * The data used to create many produtos.
     */
    data: produtoCreateManyInput | produtoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * produto update
   */
  export type produtoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    /**
     * The data needed to update a produto.
     */
    data: XOR<produtoUpdateInput, produtoUncheckedUpdateInput>
    /**
     * Choose, which produto to update.
     */
    where: produtoWhereUniqueInput
  }

  /**
   * produto updateMany
   */
  export type produtoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update produtos.
     */
    data: XOR<produtoUpdateManyMutationInput, produtoUncheckedUpdateManyInput>
    /**
     * Filter which produtos to update
     */
    where?: produtoWhereInput
    /**
     * Limit how many produtos to update.
     */
    limit?: number
  }

  /**
   * produto updateManyAndReturn
   */
  export type produtoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * The data used to update produtos.
     */
    data: XOR<produtoUpdateManyMutationInput, produtoUncheckedUpdateManyInput>
    /**
     * Filter which produtos to update
     */
    where?: produtoWhereInput
    /**
     * Limit how many produtos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * produto upsert
   */
  export type produtoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    /**
     * The filter to search for the produto to update in case it exists.
     */
    where: produtoWhereUniqueInput
    /**
     * In case the produto found by the `where` argument doesn't exist, create a new produto with this data.
     */
    create: XOR<produtoCreateInput, produtoUncheckedCreateInput>
    /**
     * In case the produto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<produtoUpdateInput, produtoUncheckedUpdateInput>
  }

  /**
   * produto delete
   */
  export type produtoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
    /**
     * Filter which produto to delete.
     */
    where: produtoWhereUniqueInput
  }

  /**
   * produto deleteMany
   */
  export type produtoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produtos to delete
     */
    where?: produtoWhereInput
    /**
     * Limit how many produtos to delete.
     */
    limit?: number
  }

  /**
   * produto without action
   */
  export type produtoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produto
     */
    select?: produtoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the produto
     */
    omit?: produtoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produtoInclude<ExtArgs> | null
  }


  /**
   * Model usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id_usuario: number | null
    id_user: number | null
    ativo: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id_usuario: number | null
    id_user: number | null
    ativo: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id_usuario: number | null
    id_user: number | null
    cpf: string | null
    nome: string | null
    endereco: string | null
    bairro: string | null
    tipo: string | null
    cidade: string | null
    postalcode: string | null
    celular: string | null
    data_cadastrou: Date | null
    ativo: number | null
    numero: string | null
    data_nascimento: Date | null
    email: string | null
    telefone: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id_usuario: number | null
    id_user: number | null
    cpf: string | null
    nome: string | null
    endereco: string | null
    bairro: string | null
    tipo: string | null
    cidade: string | null
    postalcode: string | null
    celular: string | null
    data_cadastrou: Date | null
    ativo: number | null
    numero: string | null
    data_nascimento: Date | null
    email: string | null
    telefone: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    id_usuario: number
    id_user: number
    cpf: number
    nome: number
    endereco: number
    bairro: number
    tipo: number
    cidade: number
    postalcode: number
    celular: number
    data_cadastrou: number
    ativo: number
    numero: number
    data_nascimento: number
    email: number
    telefone: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id_usuario?: true
    id_user?: true
    ativo?: true
  }

  export type UsuarioSumAggregateInputType = {
    id_usuario?: true
    id_user?: true
    ativo?: true
  }

  export type UsuarioMinAggregateInputType = {
    id_usuario?: true
    id_user?: true
    cpf?: true
    nome?: true
    endereco?: true
    bairro?: true
    tipo?: true
    cidade?: true
    postalcode?: true
    celular?: true
    data_cadastrou?: true
    ativo?: true
    numero?: true
    data_nascimento?: true
    email?: true
    telefone?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id_usuario?: true
    id_user?: true
    cpf?: true
    nome?: true
    endereco?: true
    bairro?: true
    tipo?: true
    cidade?: true
    postalcode?: true
    celular?: true
    data_cadastrou?: true
    ativo?: true
    numero?: true
    data_nascimento?: true
    email?: true
    telefone?: true
  }

  export type UsuarioCountAggregateInputType = {
    id_usuario?: true
    id_user?: true
    cpf?: true
    nome?: true
    endereco?: true
    bairro?: true
    tipo?: true
    cidade?: true
    postalcode?: true
    celular?: true
    data_cadastrou?: true
    ativo?: true
    numero?: true
    data_nascimento?: true
    email?: true
    telefone?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type usuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithAggregationInput | usuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id_usuario: number
    id_user: number
    cpf: string
    nome: string
    endereco: string
    bairro: string
    tipo: string
    cidade: string
    postalcode: string
    celular: string
    data_cadastrou: Date | null
    ativo: number | null
    numero: string
    data_nascimento: Date | null
    email: string | null
    telefone: string | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends usuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    id_user?: boolean
    cpf?: boolean
    nome?: boolean
    endereco?: boolean
    bairro?: boolean
    tipo?: boolean
    cidade?: boolean
    postalcode?: boolean
    celular?: boolean
    data_cadastrou?: boolean
    ativo?: boolean
    numero?: boolean
    data_nascimento?: boolean
    email?: boolean
    telefone?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    id_user?: boolean
    cpf?: boolean
    nome?: boolean
    endereco?: boolean
    bairro?: boolean
    tipo?: boolean
    cidade?: boolean
    postalcode?: boolean
    celular?: boolean
    data_cadastrou?: boolean
    ativo?: boolean
    numero?: boolean
    data_nascimento?: boolean
    email?: boolean
    telefone?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    id_user?: boolean
    cpf?: boolean
    nome?: boolean
    endereco?: boolean
    bairro?: boolean
    tipo?: boolean
    cidade?: boolean
    postalcode?: boolean
    celular?: boolean
    data_cadastrou?: boolean
    ativo?: boolean
    numero?: boolean
    data_nascimento?: boolean
    email?: boolean
    telefone?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectScalar = {
    id_usuario?: boolean
    id_user?: boolean
    cpf?: boolean
    nome?: boolean
    endereco?: boolean
    bairro?: boolean
    tipo?: boolean
    cidade?: boolean
    postalcode?: boolean
    celular?: boolean
    data_cadastrou?: boolean
    ativo?: boolean
    numero?: boolean
    data_nascimento?: boolean
    email?: boolean
    telefone?: boolean
  }

  export type usuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_usuario" | "id_user" | "cpf" | "nome" | "endereco" | "bairro" | "tipo" | "cidade" | "postalcode" | "celular" | "data_cadastrou" | "ativo" | "numero" | "data_nascimento" | "email" | "telefone", ExtArgs["result"]["usuario"]>
  export type usuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type usuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type usuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $usuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      id_user: number
      cpf: string
      nome: string
      endereco: string
      bairro: string
      tipo: string
      cidade: string
      postalcode: string
      celular: string
      data_cadastrou: Date | null
      ativo: number | null
      numero: string
      data_nascimento: Date | null
      email: string | null
      telefone: string | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type usuarioGetPayload<S extends boolean | null | undefined | usuarioDefaultArgs> = $Result.GetResult<Prisma.$usuarioPayload, S>

  type usuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface usuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario'], meta: { name: 'usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuarioFindUniqueArgs>(args: SelectSubset<T, usuarioFindUniqueArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, usuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuarioFindFirstArgs>(args?: SelectSubset<T, usuarioFindFirstArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, usuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends usuarioFindManyArgs>(args?: SelectSubset<T, usuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends usuarioCreateArgs>(args: SelectSubset<T, usuarioCreateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuarioCreateManyArgs>(args?: SelectSubset<T, usuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {usuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id_usuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, usuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends usuarioDeleteArgs>(args: SelectSubset<T, usuarioDeleteArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuarioUpdateArgs>(args: SelectSubset<T, usuarioUpdateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuarioDeleteManyArgs>(args?: SelectSubset<T, usuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuarioUpdateManyArgs>(args: SelectSubset<T, usuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {usuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id_usuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, usuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends usuarioUpsertArgs>(args: SelectSubset<T, usuarioUpsertArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuarioGroupByArgs['orderBy'] }
        : { orderBy?: usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario model
   */
  readonly fields: usuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuario model
   */
  interface usuarioFieldRefs {
    readonly id_usuario: FieldRef<"usuario", 'Int'>
    readonly id_user: FieldRef<"usuario", 'Int'>
    readonly cpf: FieldRef<"usuario", 'String'>
    readonly nome: FieldRef<"usuario", 'String'>
    readonly endereco: FieldRef<"usuario", 'String'>
    readonly bairro: FieldRef<"usuario", 'String'>
    readonly tipo: FieldRef<"usuario", 'String'>
    readonly cidade: FieldRef<"usuario", 'String'>
    readonly postalcode: FieldRef<"usuario", 'String'>
    readonly celular: FieldRef<"usuario", 'String'>
    readonly data_cadastrou: FieldRef<"usuario", 'DateTime'>
    readonly ativo: FieldRef<"usuario", 'Int'>
    readonly numero: FieldRef<"usuario", 'String'>
    readonly data_nascimento: FieldRef<"usuario", 'DateTime'>
    readonly email: FieldRef<"usuario", 'String'>
    readonly telefone: FieldRef<"usuario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * usuario findUnique
   */
  export type usuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findFirst
   */
  export type usuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario create
   */
  export type usuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }

  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario createManyAndReturn
   */
  export type usuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuario update
   */
  export type usuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
  }

  /**
   * usuario updateManyAndReturn
   */
  export type usuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }

  /**
   * usuario delete
   */
  export type usuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput
    /**
     * Limit how many usuarios to delete.
     */
    limit?: number
  }

  /**
   * usuario without action
   */
  export type usuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
  }


  /**
   * Model Campanha_msg
   */

  export type AggregateCampanha_msg = {
    _count: Campanha_msgCountAggregateOutputType | null
    _avg: Campanha_msgAvgAggregateOutputType | null
    _sum: Campanha_msgSumAggregateOutputType | null
    _min: Campanha_msgMinAggregateOutputType | null
    _max: Campanha_msgMaxAggregateOutputType | null
  }

  export type Campanha_msgAvgAggregateOutputType = {
    id_campanha_msg: number | null
    ativo: number | null
    id_empresa: number | null
    id_user: number | null
  }

  export type Campanha_msgSumAggregateOutputType = {
    id_campanha_msg: number | null
    ativo: number | null
    id_empresa: number | null
    id_user: number | null
  }

  export type Campanha_msgMinAggregateOutputType = {
    id_campanha_msg: number | null
    mensagem: string | null
    nome: string | null
    ativo: number | null
    data_cadastrou: Date | null
    id_empresa: number | null
    id_user: number | null
  }

  export type Campanha_msgMaxAggregateOutputType = {
    id_campanha_msg: number | null
    mensagem: string | null
    nome: string | null
    ativo: number | null
    data_cadastrou: Date | null
    id_empresa: number | null
    id_user: number | null
  }

  export type Campanha_msgCountAggregateOutputType = {
    id_campanha_msg: number
    mensagem: number
    nome: number
    ativo: number
    data_cadastrou: number
    id_empresa: number
    id_user: number
    _all: number
  }


  export type Campanha_msgAvgAggregateInputType = {
    id_campanha_msg?: true
    ativo?: true
    id_empresa?: true
    id_user?: true
  }

  export type Campanha_msgSumAggregateInputType = {
    id_campanha_msg?: true
    ativo?: true
    id_empresa?: true
    id_user?: true
  }

  export type Campanha_msgMinAggregateInputType = {
    id_campanha_msg?: true
    mensagem?: true
    nome?: true
    ativo?: true
    data_cadastrou?: true
    id_empresa?: true
    id_user?: true
  }

  export type Campanha_msgMaxAggregateInputType = {
    id_campanha_msg?: true
    mensagem?: true
    nome?: true
    ativo?: true
    data_cadastrou?: true
    id_empresa?: true
    id_user?: true
  }

  export type Campanha_msgCountAggregateInputType = {
    id_campanha_msg?: true
    mensagem?: true
    nome?: true
    ativo?: true
    data_cadastrou?: true
    id_empresa?: true
    id_user?: true
    _all?: true
  }

  export type Campanha_msgAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campanha_msg to aggregate.
     */
    where?: Campanha_msgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campanha_msgs to fetch.
     */
    orderBy?: Campanha_msgOrderByWithRelationInput | Campanha_msgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Campanha_msgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campanha_msgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campanha_msgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campanha_msgs
    **/
    _count?: true | Campanha_msgCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Campanha_msgAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Campanha_msgSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Campanha_msgMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Campanha_msgMaxAggregateInputType
  }

  export type GetCampanha_msgAggregateType<T extends Campanha_msgAggregateArgs> = {
        [P in keyof T & keyof AggregateCampanha_msg]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampanha_msg[P]>
      : GetScalarType<T[P], AggregateCampanha_msg[P]>
  }




  export type Campanha_msgGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Campanha_msgWhereInput
    orderBy?: Campanha_msgOrderByWithAggregationInput | Campanha_msgOrderByWithAggregationInput[]
    by: Campanha_msgScalarFieldEnum[] | Campanha_msgScalarFieldEnum
    having?: Campanha_msgScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Campanha_msgCountAggregateInputType | true
    _avg?: Campanha_msgAvgAggregateInputType
    _sum?: Campanha_msgSumAggregateInputType
    _min?: Campanha_msgMinAggregateInputType
    _max?: Campanha_msgMaxAggregateInputType
  }

  export type Campanha_msgGroupByOutputType = {
    id_campanha_msg: number
    mensagem: string
    nome: string
    ativo: number | null
    data_cadastrou: Date | null
    id_empresa: number
    id_user: number
    _count: Campanha_msgCountAggregateOutputType | null
    _avg: Campanha_msgAvgAggregateOutputType | null
    _sum: Campanha_msgSumAggregateOutputType | null
    _min: Campanha_msgMinAggregateOutputType | null
    _max: Campanha_msgMaxAggregateOutputType | null
  }

  type GetCampanha_msgGroupByPayload<T extends Campanha_msgGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Campanha_msgGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Campanha_msgGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Campanha_msgGroupByOutputType[P]>
            : GetScalarType<T[P], Campanha_msgGroupByOutputType[P]>
        }
      >
    >


  export type Campanha_msgSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha_msg?: boolean
    mensagem?: boolean
    nome?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    id_empresa?: boolean
    id_user?: boolean
  }, ExtArgs["result"]["campanha_msg"]>

  export type Campanha_msgSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha_msg?: boolean
    mensagem?: boolean
    nome?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    id_empresa?: boolean
    id_user?: boolean
  }, ExtArgs["result"]["campanha_msg"]>

  export type Campanha_msgSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha_msg?: boolean
    mensagem?: boolean
    nome?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    id_empresa?: boolean
    id_user?: boolean
  }, ExtArgs["result"]["campanha_msg"]>

  export type Campanha_msgSelectScalar = {
    id_campanha_msg?: boolean
    mensagem?: boolean
    nome?: boolean
    ativo?: boolean
    data_cadastrou?: boolean
    id_empresa?: boolean
    id_user?: boolean
  }

  export type Campanha_msgOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_campanha_msg" | "mensagem" | "nome" | "ativo" | "data_cadastrou" | "id_empresa" | "id_user", ExtArgs["result"]["campanha_msg"]>

  export type $Campanha_msgPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campanha_msg"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_campanha_msg: number
      mensagem: string
      nome: string
      ativo: number | null
      data_cadastrou: Date | null
      id_empresa: number
      id_user: number
    }, ExtArgs["result"]["campanha_msg"]>
    composites: {}
  }

  type Campanha_msgGetPayload<S extends boolean | null | undefined | Campanha_msgDefaultArgs> = $Result.GetResult<Prisma.$Campanha_msgPayload, S>

  type Campanha_msgCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Campanha_msgFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Campanha_msgCountAggregateInputType | true
    }

  export interface Campanha_msgDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campanha_msg'], meta: { name: 'Campanha_msg' } }
    /**
     * Find zero or one Campanha_msg that matches the filter.
     * @param {Campanha_msgFindUniqueArgs} args - Arguments to find a Campanha_msg
     * @example
     * // Get one Campanha_msg
     * const campanha_msg = await prisma.campanha_msg.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Campanha_msgFindUniqueArgs>(args: SelectSubset<T, Campanha_msgFindUniqueArgs<ExtArgs>>): Prisma__Campanha_msgClient<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campanha_msg that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Campanha_msgFindUniqueOrThrowArgs} args - Arguments to find a Campanha_msg
     * @example
     * // Get one Campanha_msg
     * const campanha_msg = await prisma.campanha_msg.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Campanha_msgFindUniqueOrThrowArgs>(args: SelectSubset<T, Campanha_msgFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Campanha_msgClient<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campanha_msg that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campanha_msgFindFirstArgs} args - Arguments to find a Campanha_msg
     * @example
     * // Get one Campanha_msg
     * const campanha_msg = await prisma.campanha_msg.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Campanha_msgFindFirstArgs>(args?: SelectSubset<T, Campanha_msgFindFirstArgs<ExtArgs>>): Prisma__Campanha_msgClient<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campanha_msg that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campanha_msgFindFirstOrThrowArgs} args - Arguments to find a Campanha_msg
     * @example
     * // Get one Campanha_msg
     * const campanha_msg = await prisma.campanha_msg.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Campanha_msgFindFirstOrThrowArgs>(args?: SelectSubset<T, Campanha_msgFindFirstOrThrowArgs<ExtArgs>>): Prisma__Campanha_msgClient<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campanha_msgs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campanha_msgFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campanha_msgs
     * const campanha_msgs = await prisma.campanha_msg.findMany()
     * 
     * // Get first 10 Campanha_msgs
     * const campanha_msgs = await prisma.campanha_msg.findMany({ take: 10 })
     * 
     * // Only select the `id_campanha_msg`
     * const campanha_msgWithId_campanha_msgOnly = await prisma.campanha_msg.findMany({ select: { id_campanha_msg: true } })
     * 
     */
    findMany<T extends Campanha_msgFindManyArgs>(args?: SelectSubset<T, Campanha_msgFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campanha_msg.
     * @param {Campanha_msgCreateArgs} args - Arguments to create a Campanha_msg.
     * @example
     * // Create one Campanha_msg
     * const Campanha_msg = await prisma.campanha_msg.create({
     *   data: {
     *     // ... data to create a Campanha_msg
     *   }
     * })
     * 
     */
    create<T extends Campanha_msgCreateArgs>(args: SelectSubset<T, Campanha_msgCreateArgs<ExtArgs>>): Prisma__Campanha_msgClient<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campanha_msgs.
     * @param {Campanha_msgCreateManyArgs} args - Arguments to create many Campanha_msgs.
     * @example
     * // Create many Campanha_msgs
     * const campanha_msg = await prisma.campanha_msg.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Campanha_msgCreateManyArgs>(args?: SelectSubset<T, Campanha_msgCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campanha_msgs and returns the data saved in the database.
     * @param {Campanha_msgCreateManyAndReturnArgs} args - Arguments to create many Campanha_msgs.
     * @example
     * // Create many Campanha_msgs
     * const campanha_msg = await prisma.campanha_msg.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campanha_msgs and only return the `id_campanha_msg`
     * const campanha_msgWithId_campanha_msgOnly = await prisma.campanha_msg.createManyAndReturn({
     *   select: { id_campanha_msg: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Campanha_msgCreateManyAndReturnArgs>(args?: SelectSubset<T, Campanha_msgCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campanha_msg.
     * @param {Campanha_msgDeleteArgs} args - Arguments to delete one Campanha_msg.
     * @example
     * // Delete one Campanha_msg
     * const Campanha_msg = await prisma.campanha_msg.delete({
     *   where: {
     *     // ... filter to delete one Campanha_msg
     *   }
     * })
     * 
     */
    delete<T extends Campanha_msgDeleteArgs>(args: SelectSubset<T, Campanha_msgDeleteArgs<ExtArgs>>): Prisma__Campanha_msgClient<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campanha_msg.
     * @param {Campanha_msgUpdateArgs} args - Arguments to update one Campanha_msg.
     * @example
     * // Update one Campanha_msg
     * const campanha_msg = await prisma.campanha_msg.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Campanha_msgUpdateArgs>(args: SelectSubset<T, Campanha_msgUpdateArgs<ExtArgs>>): Prisma__Campanha_msgClient<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campanha_msgs.
     * @param {Campanha_msgDeleteManyArgs} args - Arguments to filter Campanha_msgs to delete.
     * @example
     * // Delete a few Campanha_msgs
     * const { count } = await prisma.campanha_msg.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Campanha_msgDeleteManyArgs>(args?: SelectSubset<T, Campanha_msgDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanha_msgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campanha_msgUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campanha_msgs
     * const campanha_msg = await prisma.campanha_msg.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Campanha_msgUpdateManyArgs>(args: SelectSubset<T, Campanha_msgUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanha_msgs and returns the data updated in the database.
     * @param {Campanha_msgUpdateManyAndReturnArgs} args - Arguments to update many Campanha_msgs.
     * @example
     * // Update many Campanha_msgs
     * const campanha_msg = await prisma.campanha_msg.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campanha_msgs and only return the `id_campanha_msg`
     * const campanha_msgWithId_campanha_msgOnly = await prisma.campanha_msg.updateManyAndReturn({
     *   select: { id_campanha_msg: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Campanha_msgUpdateManyAndReturnArgs>(args: SelectSubset<T, Campanha_msgUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campanha_msg.
     * @param {Campanha_msgUpsertArgs} args - Arguments to update or create a Campanha_msg.
     * @example
     * // Update or create a Campanha_msg
     * const campanha_msg = await prisma.campanha_msg.upsert({
     *   create: {
     *     // ... data to create a Campanha_msg
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campanha_msg we want to update
     *   }
     * })
     */
    upsert<T extends Campanha_msgUpsertArgs>(args: SelectSubset<T, Campanha_msgUpsertArgs<ExtArgs>>): Prisma__Campanha_msgClient<$Result.GetResult<Prisma.$Campanha_msgPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campanha_msgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campanha_msgCountArgs} args - Arguments to filter Campanha_msgs to count.
     * @example
     * // Count the number of Campanha_msgs
     * const count = await prisma.campanha_msg.count({
     *   where: {
     *     // ... the filter for the Campanha_msgs we want to count
     *   }
     * })
    **/
    count<T extends Campanha_msgCountArgs>(
      args?: Subset<T, Campanha_msgCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Campanha_msgCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campanha_msg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campanha_msgAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Campanha_msgAggregateArgs>(args: Subset<T, Campanha_msgAggregateArgs>): Prisma.PrismaPromise<GetCampanha_msgAggregateType<T>>

    /**
     * Group by Campanha_msg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campanha_msgGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Campanha_msgGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Campanha_msgGroupByArgs['orderBy'] }
        : { orderBy?: Campanha_msgGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Campanha_msgGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampanha_msgGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campanha_msg model
   */
  readonly fields: Campanha_msgFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campanha_msg.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Campanha_msgClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campanha_msg model
   */
  interface Campanha_msgFieldRefs {
    readonly id_campanha_msg: FieldRef<"Campanha_msg", 'Int'>
    readonly mensagem: FieldRef<"Campanha_msg", 'String'>
    readonly nome: FieldRef<"Campanha_msg", 'String'>
    readonly ativo: FieldRef<"Campanha_msg", 'Int'>
    readonly data_cadastrou: FieldRef<"Campanha_msg", 'DateTime'>
    readonly id_empresa: FieldRef<"Campanha_msg", 'Int'>
    readonly id_user: FieldRef<"Campanha_msg", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Campanha_msg findUnique
   */
  export type Campanha_msgFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * Filter, which Campanha_msg to fetch.
     */
    where: Campanha_msgWhereUniqueInput
  }

  /**
   * Campanha_msg findUniqueOrThrow
   */
  export type Campanha_msgFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * Filter, which Campanha_msg to fetch.
     */
    where: Campanha_msgWhereUniqueInput
  }

  /**
   * Campanha_msg findFirst
   */
  export type Campanha_msgFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * Filter, which Campanha_msg to fetch.
     */
    where?: Campanha_msgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campanha_msgs to fetch.
     */
    orderBy?: Campanha_msgOrderByWithRelationInput | Campanha_msgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campanha_msgs.
     */
    cursor?: Campanha_msgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campanha_msgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campanha_msgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campanha_msgs.
     */
    distinct?: Campanha_msgScalarFieldEnum | Campanha_msgScalarFieldEnum[]
  }

  /**
   * Campanha_msg findFirstOrThrow
   */
  export type Campanha_msgFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * Filter, which Campanha_msg to fetch.
     */
    where?: Campanha_msgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campanha_msgs to fetch.
     */
    orderBy?: Campanha_msgOrderByWithRelationInput | Campanha_msgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campanha_msgs.
     */
    cursor?: Campanha_msgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campanha_msgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campanha_msgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campanha_msgs.
     */
    distinct?: Campanha_msgScalarFieldEnum | Campanha_msgScalarFieldEnum[]
  }

  /**
   * Campanha_msg findMany
   */
  export type Campanha_msgFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * Filter, which Campanha_msgs to fetch.
     */
    where?: Campanha_msgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campanha_msgs to fetch.
     */
    orderBy?: Campanha_msgOrderByWithRelationInput | Campanha_msgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campanha_msgs.
     */
    cursor?: Campanha_msgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campanha_msgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campanha_msgs.
     */
    skip?: number
    distinct?: Campanha_msgScalarFieldEnum | Campanha_msgScalarFieldEnum[]
  }

  /**
   * Campanha_msg create
   */
  export type Campanha_msgCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * The data needed to create a Campanha_msg.
     */
    data: XOR<Campanha_msgCreateInput, Campanha_msgUncheckedCreateInput>
  }

  /**
   * Campanha_msg createMany
   */
  export type Campanha_msgCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campanha_msgs.
     */
    data: Campanha_msgCreateManyInput | Campanha_msgCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campanha_msg createManyAndReturn
   */
  export type Campanha_msgCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * The data used to create many Campanha_msgs.
     */
    data: Campanha_msgCreateManyInput | Campanha_msgCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campanha_msg update
   */
  export type Campanha_msgUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * The data needed to update a Campanha_msg.
     */
    data: XOR<Campanha_msgUpdateInput, Campanha_msgUncheckedUpdateInput>
    /**
     * Choose, which Campanha_msg to update.
     */
    where: Campanha_msgWhereUniqueInput
  }

  /**
   * Campanha_msg updateMany
   */
  export type Campanha_msgUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campanha_msgs.
     */
    data: XOR<Campanha_msgUpdateManyMutationInput, Campanha_msgUncheckedUpdateManyInput>
    /**
     * Filter which Campanha_msgs to update
     */
    where?: Campanha_msgWhereInput
    /**
     * Limit how many Campanha_msgs to update.
     */
    limit?: number
  }

  /**
   * Campanha_msg updateManyAndReturn
   */
  export type Campanha_msgUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * The data used to update Campanha_msgs.
     */
    data: XOR<Campanha_msgUpdateManyMutationInput, Campanha_msgUncheckedUpdateManyInput>
    /**
     * Filter which Campanha_msgs to update
     */
    where?: Campanha_msgWhereInput
    /**
     * Limit how many Campanha_msgs to update.
     */
    limit?: number
  }

  /**
   * Campanha_msg upsert
   */
  export type Campanha_msgUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * The filter to search for the Campanha_msg to update in case it exists.
     */
    where: Campanha_msgWhereUniqueInput
    /**
     * In case the Campanha_msg found by the `where` argument doesn't exist, create a new Campanha_msg with this data.
     */
    create: XOR<Campanha_msgCreateInput, Campanha_msgUncheckedCreateInput>
    /**
     * In case the Campanha_msg was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Campanha_msgUpdateInput, Campanha_msgUncheckedUpdateInput>
  }

  /**
   * Campanha_msg delete
   */
  export type Campanha_msgDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
    /**
     * Filter which Campanha_msg to delete.
     */
    where: Campanha_msgWhereUniqueInput
  }

  /**
   * Campanha_msg deleteMany
   */
  export type Campanha_msgDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campanha_msgs to delete
     */
    where?: Campanha_msgWhereInput
    /**
     * Limit how many Campanha_msgs to delete.
     */
    limit?: number
  }

  /**
   * Campanha_msg without action
   */
  export type Campanha_msgDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campanha_msg
     */
    select?: Campanha_msgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campanha_msg
     */
    omit?: Campanha_msgOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    role: number | null
    ativo: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    role: number | null
    ativo: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    cpf: string | null
    role: number | null
    created_at: Date | null
    update_at: Date | null
    ativo: number | null
    uid_user: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    cpf: string | null
    role: number | null
    created_at: Date | null
    update_at: Date | null
    ativo: number | null
    uid_user: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    cpf: number
    role: number
    created_at: number
    update_at: number
    ativo: number
    uid_user: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    role?: true
    ativo?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    role?: true
    ativo?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    cpf?: true
    role?: true
    created_at?: true
    update_at?: true
    ativo?: true
    uid_user?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    cpf?: true
    role?: true
    created_at?: true
    update_at?: true
    ativo?: true
    uid_user?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    cpf?: true
    role?: true
    created_at?: true
    update_at?: true
    ativo?: true
    uid_user?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string | null
    password: string
    cpf: string | null
    role: number | null
    created_at: Date | null
    update_at: Date | null
    ativo: number
    uid_user: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    cpf?: boolean
    role?: boolean
    created_at?: boolean
    update_at?: boolean
    ativo?: boolean
    uid_user?: boolean
    usuario?: boolean | User$usuarioArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    cpf?: boolean
    role?: boolean
    created_at?: boolean
    update_at?: boolean
    ativo?: boolean
    uid_user?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    cpf?: boolean
    role?: boolean
    created_at?: boolean
    update_at?: boolean
    ativo?: boolean
    uid_user?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    cpf?: boolean
    role?: boolean
    created_at?: boolean
    update_at?: boolean
    ativo?: boolean
    uid_user?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "cpf" | "role" | "created_at" | "update_at" | "ativo" | "uid_user", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | User$usuarioArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string | null
      password: string
      cpf: string | null
      role: number | null
      created_at: Date | null
      update_at: Date | null
      ativo: number
      uid_user: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends User$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, User$usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly cpf: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Int'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly update_at: FieldRef<"User", 'DateTime'>
    readonly ativo: FieldRef<"User", 'Int'>
    readonly uid_user: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.usuario
   */
  export type User$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    cursor?: usuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Resgate
   */

  export type AggregateResgate = {
    _count: ResgateCountAggregateOutputType | null
    _avg: ResgateAvgAggregateOutputType | null
    _sum: ResgateSumAggregateOutputType | null
    _min: ResgateMinAggregateOutputType | null
    _max: ResgateMaxAggregateOutputType | null
  }

  export type ResgateAvgAggregateOutputType = {
    id_resgate: number | null
    id_campanha: number | null
    id_user: number | null
    id_user_realizou: number | null
    qtde_resgatado: number | null
  }

  export type ResgateSumAggregateOutputType = {
    id_resgate: number | null
    id_campanha: number | null
    id_user: number | null
    id_user_realizou: number | null
    qtde_resgatado: number | null
  }

  export type ResgateMinAggregateOutputType = {
    id_resgate: number | null
    id_campanha: number | null
    id_user: number | null
    id_user_realizou: number | null
    data_cadastrou: Date | null
    qtde_resgatado: number | null
  }

  export type ResgateMaxAggregateOutputType = {
    id_resgate: number | null
    id_campanha: number | null
    id_user: number | null
    id_user_realizou: number | null
    data_cadastrou: Date | null
    qtde_resgatado: number | null
  }

  export type ResgateCountAggregateOutputType = {
    id_resgate: number
    id_campanha: number
    id_user: number
    id_user_realizou: number
    data_cadastrou: number
    qtde_resgatado: number
    _all: number
  }


  export type ResgateAvgAggregateInputType = {
    id_resgate?: true
    id_campanha?: true
    id_user?: true
    id_user_realizou?: true
    qtde_resgatado?: true
  }

  export type ResgateSumAggregateInputType = {
    id_resgate?: true
    id_campanha?: true
    id_user?: true
    id_user_realizou?: true
    qtde_resgatado?: true
  }

  export type ResgateMinAggregateInputType = {
    id_resgate?: true
    id_campanha?: true
    id_user?: true
    id_user_realizou?: true
    data_cadastrou?: true
    qtde_resgatado?: true
  }

  export type ResgateMaxAggregateInputType = {
    id_resgate?: true
    id_campanha?: true
    id_user?: true
    id_user_realizou?: true
    data_cadastrou?: true
    qtde_resgatado?: true
  }

  export type ResgateCountAggregateInputType = {
    id_resgate?: true
    id_campanha?: true
    id_user?: true
    id_user_realizou?: true
    data_cadastrou?: true
    qtde_resgatado?: true
    _all?: true
  }

  export type ResgateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resgate to aggregate.
     */
    where?: ResgateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resgates to fetch.
     */
    orderBy?: ResgateOrderByWithRelationInput | ResgateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResgateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resgates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resgates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resgates
    **/
    _count?: true | ResgateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResgateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResgateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResgateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResgateMaxAggregateInputType
  }

  export type GetResgateAggregateType<T extends ResgateAggregateArgs> = {
        [P in keyof T & keyof AggregateResgate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResgate[P]>
      : GetScalarType<T[P], AggregateResgate[P]>
  }




  export type ResgateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResgateWhereInput
    orderBy?: ResgateOrderByWithAggregationInput | ResgateOrderByWithAggregationInput[]
    by: ResgateScalarFieldEnum[] | ResgateScalarFieldEnum
    having?: ResgateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResgateCountAggregateInputType | true
    _avg?: ResgateAvgAggregateInputType
    _sum?: ResgateSumAggregateInputType
    _min?: ResgateMinAggregateInputType
    _max?: ResgateMaxAggregateInputType
  }

  export type ResgateGroupByOutputType = {
    id_resgate: number
    id_campanha: number
    id_user: number
    id_user_realizou: number
    data_cadastrou: Date | null
    qtde_resgatado: number
    _count: ResgateCountAggregateOutputType | null
    _avg: ResgateAvgAggregateOutputType | null
    _sum: ResgateSumAggregateOutputType | null
    _min: ResgateMinAggregateOutputType | null
    _max: ResgateMaxAggregateOutputType | null
  }

  type GetResgateGroupByPayload<T extends ResgateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResgateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResgateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResgateGroupByOutputType[P]>
            : GetScalarType<T[P], ResgateGroupByOutputType[P]>
        }
      >
    >


  export type ResgateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_resgate?: boolean
    id_campanha?: boolean
    id_user?: boolean
    id_user_realizou?: boolean
    data_cadastrou?: boolean
    qtde_resgatado?: boolean
  }, ExtArgs["result"]["resgate"]>

  export type ResgateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_resgate?: boolean
    id_campanha?: boolean
    id_user?: boolean
    id_user_realizou?: boolean
    data_cadastrou?: boolean
    qtde_resgatado?: boolean
  }, ExtArgs["result"]["resgate"]>

  export type ResgateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_resgate?: boolean
    id_campanha?: boolean
    id_user?: boolean
    id_user_realizou?: boolean
    data_cadastrou?: boolean
    qtde_resgatado?: boolean
  }, ExtArgs["result"]["resgate"]>

  export type ResgateSelectScalar = {
    id_resgate?: boolean
    id_campanha?: boolean
    id_user?: boolean
    id_user_realizou?: boolean
    data_cadastrou?: boolean
    qtde_resgatado?: boolean
  }

  export type ResgateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_resgate" | "id_campanha" | "id_user" | "id_user_realizou" | "data_cadastrou" | "qtde_resgatado", ExtArgs["result"]["resgate"]>

  export type $ResgatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resgate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_resgate: number
      id_campanha: number
      id_user: number
      id_user_realizou: number
      data_cadastrou: Date | null
      qtde_resgatado: number
    }, ExtArgs["result"]["resgate"]>
    composites: {}
  }

  type ResgateGetPayload<S extends boolean | null | undefined | ResgateDefaultArgs> = $Result.GetResult<Prisma.$ResgatePayload, S>

  type ResgateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResgateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResgateCountAggregateInputType | true
    }

  export interface ResgateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resgate'], meta: { name: 'Resgate' } }
    /**
     * Find zero or one Resgate that matches the filter.
     * @param {ResgateFindUniqueArgs} args - Arguments to find a Resgate
     * @example
     * // Get one Resgate
     * const resgate = await prisma.resgate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResgateFindUniqueArgs>(args: SelectSubset<T, ResgateFindUniqueArgs<ExtArgs>>): Prisma__ResgateClient<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resgate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResgateFindUniqueOrThrowArgs} args - Arguments to find a Resgate
     * @example
     * // Get one Resgate
     * const resgate = await prisma.resgate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResgateFindUniqueOrThrowArgs>(args: SelectSubset<T, ResgateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResgateClient<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resgate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResgateFindFirstArgs} args - Arguments to find a Resgate
     * @example
     * // Get one Resgate
     * const resgate = await prisma.resgate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResgateFindFirstArgs>(args?: SelectSubset<T, ResgateFindFirstArgs<ExtArgs>>): Prisma__ResgateClient<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resgate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResgateFindFirstOrThrowArgs} args - Arguments to find a Resgate
     * @example
     * // Get one Resgate
     * const resgate = await prisma.resgate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResgateFindFirstOrThrowArgs>(args?: SelectSubset<T, ResgateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResgateClient<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resgates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResgateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resgates
     * const resgates = await prisma.resgate.findMany()
     * 
     * // Get first 10 Resgates
     * const resgates = await prisma.resgate.findMany({ take: 10 })
     * 
     * // Only select the `id_resgate`
     * const resgateWithId_resgateOnly = await prisma.resgate.findMany({ select: { id_resgate: true } })
     * 
     */
    findMany<T extends ResgateFindManyArgs>(args?: SelectSubset<T, ResgateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resgate.
     * @param {ResgateCreateArgs} args - Arguments to create a Resgate.
     * @example
     * // Create one Resgate
     * const Resgate = await prisma.resgate.create({
     *   data: {
     *     // ... data to create a Resgate
     *   }
     * })
     * 
     */
    create<T extends ResgateCreateArgs>(args: SelectSubset<T, ResgateCreateArgs<ExtArgs>>): Prisma__ResgateClient<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resgates.
     * @param {ResgateCreateManyArgs} args - Arguments to create many Resgates.
     * @example
     * // Create many Resgates
     * const resgate = await prisma.resgate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResgateCreateManyArgs>(args?: SelectSubset<T, ResgateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resgates and returns the data saved in the database.
     * @param {ResgateCreateManyAndReturnArgs} args - Arguments to create many Resgates.
     * @example
     * // Create many Resgates
     * const resgate = await prisma.resgate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resgates and only return the `id_resgate`
     * const resgateWithId_resgateOnly = await prisma.resgate.createManyAndReturn({
     *   select: { id_resgate: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResgateCreateManyAndReturnArgs>(args?: SelectSubset<T, ResgateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resgate.
     * @param {ResgateDeleteArgs} args - Arguments to delete one Resgate.
     * @example
     * // Delete one Resgate
     * const Resgate = await prisma.resgate.delete({
     *   where: {
     *     // ... filter to delete one Resgate
     *   }
     * })
     * 
     */
    delete<T extends ResgateDeleteArgs>(args: SelectSubset<T, ResgateDeleteArgs<ExtArgs>>): Prisma__ResgateClient<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resgate.
     * @param {ResgateUpdateArgs} args - Arguments to update one Resgate.
     * @example
     * // Update one Resgate
     * const resgate = await prisma.resgate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResgateUpdateArgs>(args: SelectSubset<T, ResgateUpdateArgs<ExtArgs>>): Prisma__ResgateClient<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resgates.
     * @param {ResgateDeleteManyArgs} args - Arguments to filter Resgates to delete.
     * @example
     * // Delete a few Resgates
     * const { count } = await prisma.resgate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResgateDeleteManyArgs>(args?: SelectSubset<T, ResgateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resgates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResgateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resgates
     * const resgate = await prisma.resgate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResgateUpdateManyArgs>(args: SelectSubset<T, ResgateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resgates and returns the data updated in the database.
     * @param {ResgateUpdateManyAndReturnArgs} args - Arguments to update many Resgates.
     * @example
     * // Update many Resgates
     * const resgate = await prisma.resgate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resgates and only return the `id_resgate`
     * const resgateWithId_resgateOnly = await prisma.resgate.updateManyAndReturn({
     *   select: { id_resgate: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResgateUpdateManyAndReturnArgs>(args: SelectSubset<T, ResgateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resgate.
     * @param {ResgateUpsertArgs} args - Arguments to update or create a Resgate.
     * @example
     * // Update or create a Resgate
     * const resgate = await prisma.resgate.upsert({
     *   create: {
     *     // ... data to create a Resgate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resgate we want to update
     *   }
     * })
     */
    upsert<T extends ResgateUpsertArgs>(args: SelectSubset<T, ResgateUpsertArgs<ExtArgs>>): Prisma__ResgateClient<$Result.GetResult<Prisma.$ResgatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resgates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResgateCountArgs} args - Arguments to filter Resgates to count.
     * @example
     * // Count the number of Resgates
     * const count = await prisma.resgate.count({
     *   where: {
     *     // ... the filter for the Resgates we want to count
     *   }
     * })
    **/
    count<T extends ResgateCountArgs>(
      args?: Subset<T, ResgateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResgateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resgate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResgateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResgateAggregateArgs>(args: Subset<T, ResgateAggregateArgs>): Prisma.PrismaPromise<GetResgateAggregateType<T>>

    /**
     * Group by Resgate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResgateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResgateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResgateGroupByArgs['orderBy'] }
        : { orderBy?: ResgateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResgateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResgateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resgate model
   */
  readonly fields: ResgateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resgate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResgateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resgate model
   */
  interface ResgateFieldRefs {
    readonly id_resgate: FieldRef<"Resgate", 'Int'>
    readonly id_campanha: FieldRef<"Resgate", 'Int'>
    readonly id_user: FieldRef<"Resgate", 'Int'>
    readonly id_user_realizou: FieldRef<"Resgate", 'Int'>
    readonly data_cadastrou: FieldRef<"Resgate", 'DateTime'>
    readonly qtde_resgatado: FieldRef<"Resgate", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Resgate findUnique
   */
  export type ResgateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * Filter, which Resgate to fetch.
     */
    where: ResgateWhereUniqueInput
  }

  /**
   * Resgate findUniqueOrThrow
   */
  export type ResgateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * Filter, which Resgate to fetch.
     */
    where: ResgateWhereUniqueInput
  }

  /**
   * Resgate findFirst
   */
  export type ResgateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * Filter, which Resgate to fetch.
     */
    where?: ResgateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resgates to fetch.
     */
    orderBy?: ResgateOrderByWithRelationInput | ResgateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resgates.
     */
    cursor?: ResgateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resgates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resgates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resgates.
     */
    distinct?: ResgateScalarFieldEnum | ResgateScalarFieldEnum[]
  }

  /**
   * Resgate findFirstOrThrow
   */
  export type ResgateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * Filter, which Resgate to fetch.
     */
    where?: ResgateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resgates to fetch.
     */
    orderBy?: ResgateOrderByWithRelationInput | ResgateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resgates.
     */
    cursor?: ResgateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resgates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resgates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resgates.
     */
    distinct?: ResgateScalarFieldEnum | ResgateScalarFieldEnum[]
  }

  /**
   * Resgate findMany
   */
  export type ResgateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * Filter, which Resgates to fetch.
     */
    where?: ResgateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resgates to fetch.
     */
    orderBy?: ResgateOrderByWithRelationInput | ResgateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resgates.
     */
    cursor?: ResgateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resgates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resgates.
     */
    skip?: number
    distinct?: ResgateScalarFieldEnum | ResgateScalarFieldEnum[]
  }

  /**
   * Resgate create
   */
  export type ResgateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * The data needed to create a Resgate.
     */
    data: XOR<ResgateCreateInput, ResgateUncheckedCreateInput>
  }

  /**
   * Resgate createMany
   */
  export type ResgateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resgates.
     */
    data: ResgateCreateManyInput | ResgateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resgate createManyAndReturn
   */
  export type ResgateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * The data used to create many Resgates.
     */
    data: ResgateCreateManyInput | ResgateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resgate update
   */
  export type ResgateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * The data needed to update a Resgate.
     */
    data: XOR<ResgateUpdateInput, ResgateUncheckedUpdateInput>
    /**
     * Choose, which Resgate to update.
     */
    where: ResgateWhereUniqueInput
  }

  /**
   * Resgate updateMany
   */
  export type ResgateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resgates.
     */
    data: XOR<ResgateUpdateManyMutationInput, ResgateUncheckedUpdateManyInput>
    /**
     * Filter which Resgates to update
     */
    where?: ResgateWhereInput
    /**
     * Limit how many Resgates to update.
     */
    limit?: number
  }

  /**
   * Resgate updateManyAndReturn
   */
  export type ResgateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * The data used to update Resgates.
     */
    data: XOR<ResgateUpdateManyMutationInput, ResgateUncheckedUpdateManyInput>
    /**
     * Filter which Resgates to update
     */
    where?: ResgateWhereInput
    /**
     * Limit how many Resgates to update.
     */
    limit?: number
  }

  /**
   * Resgate upsert
   */
  export type ResgateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * The filter to search for the Resgate to update in case it exists.
     */
    where: ResgateWhereUniqueInput
    /**
     * In case the Resgate found by the `where` argument doesn't exist, create a new Resgate with this data.
     */
    create: XOR<ResgateCreateInput, ResgateUncheckedCreateInput>
    /**
     * In case the Resgate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResgateUpdateInput, ResgateUncheckedUpdateInput>
  }

  /**
   * Resgate delete
   */
  export type ResgateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
    /**
     * Filter which Resgate to delete.
     */
    where: ResgateWhereUniqueInput
  }

  /**
   * Resgate deleteMany
   */
  export type ResgateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resgates to delete
     */
    where?: ResgateWhereInput
    /**
     * Limit how many Resgates to delete.
     */
    limit?: number
  }

  /**
   * Resgate without action
   */
  export type ResgateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resgate
     */
    select?: ResgateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resgate
     */
    omit?: ResgateOmit<ExtArgs> | null
  }


  /**
   * Model empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaAvgAggregateOutputType = {
    id_empresa: number | null
    id_user: number | null
    ativo: number | null
  }

  export type EmpresaSumAggregateOutputType = {
    id_empresa: number | null
    id_user: number | null
    ativo: number | null
  }

  export type EmpresaMinAggregateOutputType = {
    id_empresa: number | null
    id_user: number | null
    nome_empresa: string | null
    cnpj: string | null
    data_cadastrou: Date | null
    ativo: number | null
    uid: string | null
    apikey: string | null
  }

  export type EmpresaMaxAggregateOutputType = {
    id_empresa: number | null
    id_user: number | null
    nome_empresa: string | null
    cnpj: string | null
    data_cadastrou: Date | null
    ativo: number | null
    uid: string | null
    apikey: string | null
  }

  export type EmpresaCountAggregateOutputType = {
    id_empresa: number
    id_user: number
    nome_empresa: number
    cnpj: number
    data_cadastrou: number
    ativo: number
    uid: number
    apikey: number
    _all: number
  }


  export type EmpresaAvgAggregateInputType = {
    id_empresa?: true
    id_user?: true
    ativo?: true
  }

  export type EmpresaSumAggregateInputType = {
    id_empresa?: true
    id_user?: true
    ativo?: true
  }

  export type EmpresaMinAggregateInputType = {
    id_empresa?: true
    id_user?: true
    nome_empresa?: true
    cnpj?: true
    data_cadastrou?: true
    ativo?: true
    uid?: true
    apikey?: true
  }

  export type EmpresaMaxAggregateInputType = {
    id_empresa?: true
    id_user?: true
    nome_empresa?: true
    cnpj?: true
    data_cadastrou?: true
    ativo?: true
    uid?: true
    apikey?: true
  }

  export type EmpresaCountAggregateInputType = {
    id_empresa?: true
    id_user?: true
    nome_empresa?: true
    cnpj?: true
    data_cadastrou?: true
    ativo?: true
    uid?: true
    apikey?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empresa to aggregate.
     */
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresaOrderByWithRelationInput | empresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpresaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpresaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type empresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empresaWhereInput
    orderBy?: empresaOrderByWithAggregationInput | empresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: empresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _avg?: EmpresaAvgAggregateInputType
    _sum?: EmpresaSumAggregateInputType
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    id_empresa: number
    id_user: number
    nome_empresa: string
    cnpj: string | null
    data_cadastrou: Date | null
    ativo: number | null
    uid: string
    apikey: string | null
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends empresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type empresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_empresa?: boolean
    id_user?: boolean
    nome_empresa?: boolean
    cnpj?: boolean
    data_cadastrou?: boolean
    ativo?: boolean
    uid?: boolean
    apikey?: boolean
  }, ExtArgs["result"]["empresa"]>

  export type empresaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_empresa?: boolean
    id_user?: boolean
    nome_empresa?: boolean
    cnpj?: boolean
    data_cadastrou?: boolean
    ativo?: boolean
    uid?: boolean
    apikey?: boolean
  }, ExtArgs["result"]["empresa"]>

  export type empresaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_empresa?: boolean
    id_user?: boolean
    nome_empresa?: boolean
    cnpj?: boolean
    data_cadastrou?: boolean
    ativo?: boolean
    uid?: boolean
    apikey?: boolean
  }, ExtArgs["result"]["empresa"]>

  export type empresaSelectScalar = {
    id_empresa?: boolean
    id_user?: boolean
    nome_empresa?: boolean
    cnpj?: boolean
    data_cadastrou?: boolean
    ativo?: boolean
    uid?: boolean
    apikey?: boolean
  }

  export type empresaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_empresa" | "id_user" | "nome_empresa" | "cnpj" | "data_cadastrou" | "ativo" | "uid" | "apikey", ExtArgs["result"]["empresa"]>

  export type $empresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "empresa"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_empresa: number
      id_user: number
      nome_empresa: string
      cnpj: string | null
      data_cadastrou: Date | null
      ativo: number | null
      uid: string
      apikey: string | null
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }

  type empresaGetPayload<S extends boolean | null | undefined | empresaDefaultArgs> = $Result.GetResult<Prisma.$empresaPayload, S>

  type empresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<empresaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface empresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['empresa'], meta: { name: 'empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {empresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends empresaFindUniqueArgs>(args: SelectSubset<T, empresaFindUniqueArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {empresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends empresaFindUniqueOrThrowArgs>(args: SelectSubset<T, empresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends empresaFindFirstArgs>(args?: SelectSubset<T, empresaFindFirstArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends empresaFindFirstOrThrowArgs>(args?: SelectSubset<T, empresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `id_empresa`
     * const empresaWithId_empresaOnly = await prisma.empresa.findMany({ select: { id_empresa: true } })
     * 
     */
    findMany<T extends empresaFindManyArgs>(args?: SelectSubset<T, empresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Empresa.
     * @param {empresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
     */
    create<T extends empresaCreateArgs>(args: SelectSubset<T, empresaCreateArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Empresas.
     * @param {empresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends empresaCreateManyArgs>(args?: SelectSubset<T, empresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Empresas and returns the data saved in the database.
     * @param {empresaCreateManyAndReturnArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Empresas and only return the `id_empresa`
     * const empresaWithId_empresaOnly = await prisma.empresa.createManyAndReturn({
     *   select: { id_empresa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends empresaCreateManyAndReturnArgs>(args?: SelectSubset<T, empresaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Empresa.
     * @param {empresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
     */
    delete<T extends empresaDeleteArgs>(args: SelectSubset<T, empresaDeleteArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Empresa.
     * @param {empresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends empresaUpdateArgs>(args: SelectSubset<T, empresaUpdateArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Empresas.
     * @param {empresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends empresaDeleteManyArgs>(args?: SelectSubset<T, empresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends empresaUpdateManyArgs>(args: SelectSubset<T, empresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas and returns the data updated in the database.
     * @param {empresaUpdateManyAndReturnArgs} args - Arguments to update many Empresas.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Empresas and only return the `id_empresa`
     * const empresaWithId_empresaOnly = await prisma.empresa.updateManyAndReturn({
     *   select: { id_empresa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends empresaUpdateManyAndReturnArgs>(args: SelectSubset<T, empresaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Empresa.
     * @param {empresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends empresaUpsertArgs>(args: SelectSubset<T, empresaUpsertArgs<ExtArgs>>): Prisma__empresaClient<$Result.GetResult<Prisma.$empresaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends empresaCountArgs>(
      args?: Subset<T, empresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends empresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empresaGroupByArgs['orderBy'] }
        : { orderBy?: empresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, empresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the empresa model
   */
  readonly fields: empresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__empresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the empresa model
   */
  interface empresaFieldRefs {
    readonly id_empresa: FieldRef<"empresa", 'Int'>
    readonly id_user: FieldRef<"empresa", 'Int'>
    readonly nome_empresa: FieldRef<"empresa", 'String'>
    readonly cnpj: FieldRef<"empresa", 'String'>
    readonly data_cadastrou: FieldRef<"empresa", 'DateTime'>
    readonly ativo: FieldRef<"empresa", 'Int'>
    readonly uid: FieldRef<"empresa", 'String'>
    readonly apikey: FieldRef<"empresa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * empresa findUnique
   */
  export type empresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * Filter, which empresa to fetch.
     */
    where: empresaWhereUniqueInput
  }

  /**
   * empresa findUniqueOrThrow
   */
  export type empresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * Filter, which empresa to fetch.
     */
    where: empresaWhereUniqueInput
  }

  /**
   * empresa findFirst
   */
  export type empresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * Filter, which empresa to fetch.
     */
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresaOrderByWithRelationInput | empresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empresas.
     */
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * empresa findFirstOrThrow
   */
  export type empresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * Filter, which empresa to fetch.
     */
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresaOrderByWithRelationInput | empresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empresas.
     */
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * empresa findMany
   */
  export type empresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * Filter, which empresas to fetch.
     */
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresaOrderByWithRelationInput | empresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empresas.
     */
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * empresa create
   */
  export type empresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * The data needed to create a empresa.
     */
    data: XOR<empresaCreateInput, empresaUncheckedCreateInput>
  }

  /**
   * empresa createMany
   */
  export type empresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many empresas.
     */
    data: empresaCreateManyInput | empresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * empresa createManyAndReturn
   */
  export type empresaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * The data used to create many empresas.
     */
    data: empresaCreateManyInput | empresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * empresa update
   */
  export type empresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * The data needed to update a empresa.
     */
    data: XOR<empresaUpdateInput, empresaUncheckedUpdateInput>
    /**
     * Choose, which empresa to update.
     */
    where: empresaWhereUniqueInput
  }

  /**
   * empresa updateMany
   */
  export type empresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update empresas.
     */
    data: XOR<empresaUpdateManyMutationInput, empresaUncheckedUpdateManyInput>
    /**
     * Filter which empresas to update
     */
    where?: empresaWhereInput
    /**
     * Limit how many empresas to update.
     */
    limit?: number
  }

  /**
   * empresa updateManyAndReturn
   */
  export type empresaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * The data used to update empresas.
     */
    data: XOR<empresaUpdateManyMutationInput, empresaUncheckedUpdateManyInput>
    /**
     * Filter which empresas to update
     */
    where?: empresaWhereInput
    /**
     * Limit how many empresas to update.
     */
    limit?: number
  }

  /**
   * empresa upsert
   */
  export type empresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * The filter to search for the empresa to update in case it exists.
     */
    where: empresaWhereUniqueInput
    /**
     * In case the empresa found by the `where` argument doesn't exist, create a new empresa with this data.
     */
    create: XOR<empresaCreateInput, empresaUncheckedCreateInput>
    /**
     * In case the empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empresaUpdateInput, empresaUncheckedUpdateInput>
  }

  /**
   * empresa delete
   */
  export type empresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
    /**
     * Filter which empresa to delete.
     */
    where: empresaWhereUniqueInput
  }

  /**
   * empresa deleteMany
   */
  export type empresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empresas to delete
     */
    where?: empresaWhereInput
    /**
     * Limit how many empresas to delete.
     */
    limit?: number
  }

  /**
   * empresa without action
   */
  export type empresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null
  }


  /**
   * Model campanha_formulario
   */

  export type AggregateCampanha_formulario = {
    _count: Campanha_formularioCountAggregateOutputType | null
    _avg: Campanha_formularioAvgAggregateOutputType | null
    _sum: Campanha_formularioSumAggregateOutputType | null
    _min: Campanha_formularioMinAggregateOutputType | null
    _max: Campanha_formularioMaxAggregateOutputType | null
  }

  export type Campanha_formularioAvgAggregateOutputType = {
    id_campanha_formulario: number | null
  }

  export type Campanha_formularioSumAggregateOutputType = {
    id_campanha_formulario: number | null
  }

  export type Campanha_formularioMinAggregateOutputType = {
    id_campanha_formulario: number | null
    token: string | null
    nome: string | null
    email: string | null
    cpf: string | null
    celular: string | null
    data_cadastrou: Date | null
  }

  export type Campanha_formularioMaxAggregateOutputType = {
    id_campanha_formulario: number | null
    token: string | null
    nome: string | null
    email: string | null
    cpf: string | null
    celular: string | null
    data_cadastrou: Date | null
  }

  export type Campanha_formularioCountAggregateOutputType = {
    id_campanha_formulario: number
    token: number
    nome: number
    email: number
    cpf: number
    celular: number
    data_cadastrou: number
    _all: number
  }


  export type Campanha_formularioAvgAggregateInputType = {
    id_campanha_formulario?: true
  }

  export type Campanha_formularioSumAggregateInputType = {
    id_campanha_formulario?: true
  }

  export type Campanha_formularioMinAggregateInputType = {
    id_campanha_formulario?: true
    token?: true
    nome?: true
    email?: true
    cpf?: true
    celular?: true
    data_cadastrou?: true
  }

  export type Campanha_formularioMaxAggregateInputType = {
    id_campanha_formulario?: true
    token?: true
    nome?: true
    email?: true
    cpf?: true
    celular?: true
    data_cadastrou?: true
  }

  export type Campanha_formularioCountAggregateInputType = {
    id_campanha_formulario?: true
    token?: true
    nome?: true
    email?: true
    cpf?: true
    celular?: true
    data_cadastrou?: true
    _all?: true
  }

  export type Campanha_formularioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanha_formulario to aggregate.
     */
    where?: campanha_formularioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanha_formularios to fetch.
     */
    orderBy?: campanha_formularioOrderByWithRelationInput | campanha_formularioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campanha_formularioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanha_formularios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanha_formularios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campanha_formularios
    **/
    _count?: true | Campanha_formularioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Campanha_formularioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Campanha_formularioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Campanha_formularioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Campanha_formularioMaxAggregateInputType
  }

  export type GetCampanha_formularioAggregateType<T extends Campanha_formularioAggregateArgs> = {
        [P in keyof T & keyof AggregateCampanha_formulario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampanha_formulario[P]>
      : GetScalarType<T[P], AggregateCampanha_formulario[P]>
  }




  export type campanha_formularioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campanha_formularioWhereInput
    orderBy?: campanha_formularioOrderByWithAggregationInput | campanha_formularioOrderByWithAggregationInput[]
    by: Campanha_formularioScalarFieldEnum[] | Campanha_formularioScalarFieldEnum
    having?: campanha_formularioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Campanha_formularioCountAggregateInputType | true
    _avg?: Campanha_formularioAvgAggregateInputType
    _sum?: Campanha_formularioSumAggregateInputType
    _min?: Campanha_formularioMinAggregateInputType
    _max?: Campanha_formularioMaxAggregateInputType
  }

  export type Campanha_formularioGroupByOutputType = {
    id_campanha_formulario: number
    token: string
    nome: string
    email: string
    cpf: string
    celular: string
    data_cadastrou: Date | null
    _count: Campanha_formularioCountAggregateOutputType | null
    _avg: Campanha_formularioAvgAggregateOutputType | null
    _sum: Campanha_formularioSumAggregateOutputType | null
    _min: Campanha_formularioMinAggregateOutputType | null
    _max: Campanha_formularioMaxAggregateOutputType | null
  }

  type GetCampanha_formularioGroupByPayload<T extends campanha_formularioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Campanha_formularioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Campanha_formularioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Campanha_formularioGroupByOutputType[P]>
            : GetScalarType<T[P], Campanha_formularioGroupByOutputType[P]>
        }
      >
    >


  export type campanha_formularioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha_formulario?: boolean
    token?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    celular?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["campanha_formulario"]>

  export type campanha_formularioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha_formulario?: boolean
    token?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    celular?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["campanha_formulario"]>

  export type campanha_formularioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha_formulario?: boolean
    token?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    celular?: boolean
    data_cadastrou?: boolean
  }, ExtArgs["result"]["campanha_formulario"]>

  export type campanha_formularioSelectScalar = {
    id_campanha_formulario?: boolean
    token?: boolean
    nome?: boolean
    email?: boolean
    cpf?: boolean
    celular?: boolean
    data_cadastrou?: boolean
  }

  export type campanha_formularioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_campanha_formulario" | "token" | "nome" | "email" | "cpf" | "celular" | "data_cadastrou", ExtArgs["result"]["campanha_formulario"]>

  export type $campanha_formularioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campanha_formulario"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_campanha_formulario: number
      token: string
      nome: string
      email: string
      cpf: string
      celular: string
      data_cadastrou: Date | null
    }, ExtArgs["result"]["campanha_formulario"]>
    composites: {}
  }

  type campanha_formularioGetPayload<S extends boolean | null | undefined | campanha_formularioDefaultArgs> = $Result.GetResult<Prisma.$campanha_formularioPayload, S>

  type campanha_formularioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<campanha_formularioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Campanha_formularioCountAggregateInputType | true
    }

  export interface campanha_formularioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campanha_formulario'], meta: { name: 'campanha_formulario' } }
    /**
     * Find zero or one Campanha_formulario that matches the filter.
     * @param {campanha_formularioFindUniqueArgs} args - Arguments to find a Campanha_formulario
     * @example
     * // Get one Campanha_formulario
     * const campanha_formulario = await prisma.campanha_formulario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campanha_formularioFindUniqueArgs>(args: SelectSubset<T, campanha_formularioFindUniqueArgs<ExtArgs>>): Prisma__campanha_formularioClient<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campanha_formulario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {campanha_formularioFindUniqueOrThrowArgs} args - Arguments to find a Campanha_formulario
     * @example
     * // Get one Campanha_formulario
     * const campanha_formulario = await prisma.campanha_formulario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campanha_formularioFindUniqueOrThrowArgs>(args: SelectSubset<T, campanha_formularioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campanha_formularioClient<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campanha_formulario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_formularioFindFirstArgs} args - Arguments to find a Campanha_formulario
     * @example
     * // Get one Campanha_formulario
     * const campanha_formulario = await prisma.campanha_formulario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campanha_formularioFindFirstArgs>(args?: SelectSubset<T, campanha_formularioFindFirstArgs<ExtArgs>>): Prisma__campanha_formularioClient<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campanha_formulario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_formularioFindFirstOrThrowArgs} args - Arguments to find a Campanha_formulario
     * @example
     * // Get one Campanha_formulario
     * const campanha_formulario = await prisma.campanha_formulario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campanha_formularioFindFirstOrThrowArgs>(args?: SelectSubset<T, campanha_formularioFindFirstOrThrowArgs<ExtArgs>>): Prisma__campanha_formularioClient<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campanha_formularios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_formularioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campanha_formularios
     * const campanha_formularios = await prisma.campanha_formulario.findMany()
     * 
     * // Get first 10 Campanha_formularios
     * const campanha_formularios = await prisma.campanha_formulario.findMany({ take: 10 })
     * 
     * // Only select the `id_campanha_formulario`
     * const campanha_formularioWithId_campanha_formularioOnly = await prisma.campanha_formulario.findMany({ select: { id_campanha_formulario: true } })
     * 
     */
    findMany<T extends campanha_formularioFindManyArgs>(args?: SelectSubset<T, campanha_formularioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campanha_formulario.
     * @param {campanha_formularioCreateArgs} args - Arguments to create a Campanha_formulario.
     * @example
     * // Create one Campanha_formulario
     * const Campanha_formulario = await prisma.campanha_formulario.create({
     *   data: {
     *     // ... data to create a Campanha_formulario
     *   }
     * })
     * 
     */
    create<T extends campanha_formularioCreateArgs>(args: SelectSubset<T, campanha_formularioCreateArgs<ExtArgs>>): Prisma__campanha_formularioClient<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campanha_formularios.
     * @param {campanha_formularioCreateManyArgs} args - Arguments to create many Campanha_formularios.
     * @example
     * // Create many Campanha_formularios
     * const campanha_formulario = await prisma.campanha_formulario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campanha_formularioCreateManyArgs>(args?: SelectSubset<T, campanha_formularioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campanha_formularios and returns the data saved in the database.
     * @param {campanha_formularioCreateManyAndReturnArgs} args - Arguments to create many Campanha_formularios.
     * @example
     * // Create many Campanha_formularios
     * const campanha_formulario = await prisma.campanha_formulario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campanha_formularios and only return the `id_campanha_formulario`
     * const campanha_formularioWithId_campanha_formularioOnly = await prisma.campanha_formulario.createManyAndReturn({
     *   select: { id_campanha_formulario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campanha_formularioCreateManyAndReturnArgs>(args?: SelectSubset<T, campanha_formularioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campanha_formulario.
     * @param {campanha_formularioDeleteArgs} args - Arguments to delete one Campanha_formulario.
     * @example
     * // Delete one Campanha_formulario
     * const Campanha_formulario = await prisma.campanha_formulario.delete({
     *   where: {
     *     // ... filter to delete one Campanha_formulario
     *   }
     * })
     * 
     */
    delete<T extends campanha_formularioDeleteArgs>(args: SelectSubset<T, campanha_formularioDeleteArgs<ExtArgs>>): Prisma__campanha_formularioClient<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campanha_formulario.
     * @param {campanha_formularioUpdateArgs} args - Arguments to update one Campanha_formulario.
     * @example
     * // Update one Campanha_formulario
     * const campanha_formulario = await prisma.campanha_formulario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campanha_formularioUpdateArgs>(args: SelectSubset<T, campanha_formularioUpdateArgs<ExtArgs>>): Prisma__campanha_formularioClient<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campanha_formularios.
     * @param {campanha_formularioDeleteManyArgs} args - Arguments to filter Campanha_formularios to delete.
     * @example
     * // Delete a few Campanha_formularios
     * const { count } = await prisma.campanha_formulario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campanha_formularioDeleteManyArgs>(args?: SelectSubset<T, campanha_formularioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanha_formularios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_formularioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campanha_formularios
     * const campanha_formulario = await prisma.campanha_formulario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campanha_formularioUpdateManyArgs>(args: SelectSubset<T, campanha_formularioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanha_formularios and returns the data updated in the database.
     * @param {campanha_formularioUpdateManyAndReturnArgs} args - Arguments to update many Campanha_formularios.
     * @example
     * // Update many Campanha_formularios
     * const campanha_formulario = await prisma.campanha_formulario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campanha_formularios and only return the `id_campanha_formulario`
     * const campanha_formularioWithId_campanha_formularioOnly = await prisma.campanha_formulario.updateManyAndReturn({
     *   select: { id_campanha_formulario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends campanha_formularioUpdateManyAndReturnArgs>(args: SelectSubset<T, campanha_formularioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campanha_formulario.
     * @param {campanha_formularioUpsertArgs} args - Arguments to update or create a Campanha_formulario.
     * @example
     * // Update or create a Campanha_formulario
     * const campanha_formulario = await prisma.campanha_formulario.upsert({
     *   create: {
     *     // ... data to create a Campanha_formulario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campanha_formulario we want to update
     *   }
     * })
     */
    upsert<T extends campanha_formularioUpsertArgs>(args: SelectSubset<T, campanha_formularioUpsertArgs<ExtArgs>>): Prisma__campanha_formularioClient<$Result.GetResult<Prisma.$campanha_formularioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campanha_formularios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_formularioCountArgs} args - Arguments to filter Campanha_formularios to count.
     * @example
     * // Count the number of Campanha_formularios
     * const count = await prisma.campanha_formulario.count({
     *   where: {
     *     // ... the filter for the Campanha_formularios we want to count
     *   }
     * })
    **/
    count<T extends campanha_formularioCountArgs>(
      args?: Subset<T, campanha_formularioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Campanha_formularioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campanha_formulario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campanha_formularioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Campanha_formularioAggregateArgs>(args: Subset<T, Campanha_formularioAggregateArgs>): Prisma.PrismaPromise<GetCampanha_formularioAggregateType<T>>

    /**
     * Group by Campanha_formulario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanha_formularioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campanha_formularioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campanha_formularioGroupByArgs['orderBy'] }
        : { orderBy?: campanha_formularioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campanha_formularioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampanha_formularioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campanha_formulario model
   */
  readonly fields: campanha_formularioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campanha_formulario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campanha_formularioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campanha_formulario model
   */
  interface campanha_formularioFieldRefs {
    readonly id_campanha_formulario: FieldRef<"campanha_formulario", 'Int'>
    readonly token: FieldRef<"campanha_formulario", 'String'>
    readonly nome: FieldRef<"campanha_formulario", 'String'>
    readonly email: FieldRef<"campanha_formulario", 'String'>
    readonly cpf: FieldRef<"campanha_formulario", 'String'>
    readonly celular: FieldRef<"campanha_formulario", 'String'>
    readonly data_cadastrou: FieldRef<"campanha_formulario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * campanha_formulario findUnique
   */
  export type campanha_formularioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * Filter, which campanha_formulario to fetch.
     */
    where: campanha_formularioWhereUniqueInput
  }

  /**
   * campanha_formulario findUniqueOrThrow
   */
  export type campanha_formularioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * Filter, which campanha_formulario to fetch.
     */
    where: campanha_formularioWhereUniqueInput
  }

  /**
   * campanha_formulario findFirst
   */
  export type campanha_formularioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * Filter, which campanha_formulario to fetch.
     */
    where?: campanha_formularioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanha_formularios to fetch.
     */
    orderBy?: campanha_formularioOrderByWithRelationInput | campanha_formularioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanha_formularios.
     */
    cursor?: campanha_formularioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanha_formularios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanha_formularios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanha_formularios.
     */
    distinct?: Campanha_formularioScalarFieldEnum | Campanha_formularioScalarFieldEnum[]
  }

  /**
   * campanha_formulario findFirstOrThrow
   */
  export type campanha_formularioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * Filter, which campanha_formulario to fetch.
     */
    where?: campanha_formularioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanha_formularios to fetch.
     */
    orderBy?: campanha_formularioOrderByWithRelationInput | campanha_formularioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanha_formularios.
     */
    cursor?: campanha_formularioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanha_formularios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanha_formularios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanha_formularios.
     */
    distinct?: Campanha_formularioScalarFieldEnum | Campanha_formularioScalarFieldEnum[]
  }

  /**
   * campanha_formulario findMany
   */
  export type campanha_formularioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * Filter, which campanha_formularios to fetch.
     */
    where?: campanha_formularioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanha_formularios to fetch.
     */
    orderBy?: campanha_formularioOrderByWithRelationInput | campanha_formularioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campanha_formularios.
     */
    cursor?: campanha_formularioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanha_formularios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanha_formularios.
     */
    skip?: number
    distinct?: Campanha_formularioScalarFieldEnum | Campanha_formularioScalarFieldEnum[]
  }

  /**
   * campanha_formulario create
   */
  export type campanha_formularioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * The data needed to create a campanha_formulario.
     */
    data: XOR<campanha_formularioCreateInput, campanha_formularioUncheckedCreateInput>
  }

  /**
   * campanha_formulario createMany
   */
  export type campanha_formularioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campanha_formularios.
     */
    data: campanha_formularioCreateManyInput | campanha_formularioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campanha_formulario createManyAndReturn
   */
  export type campanha_formularioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * The data used to create many campanha_formularios.
     */
    data: campanha_formularioCreateManyInput | campanha_formularioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campanha_formulario update
   */
  export type campanha_formularioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * The data needed to update a campanha_formulario.
     */
    data: XOR<campanha_formularioUpdateInput, campanha_formularioUncheckedUpdateInput>
    /**
     * Choose, which campanha_formulario to update.
     */
    where: campanha_formularioWhereUniqueInput
  }

  /**
   * campanha_formulario updateMany
   */
  export type campanha_formularioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campanha_formularios.
     */
    data: XOR<campanha_formularioUpdateManyMutationInput, campanha_formularioUncheckedUpdateManyInput>
    /**
     * Filter which campanha_formularios to update
     */
    where?: campanha_formularioWhereInput
    /**
     * Limit how many campanha_formularios to update.
     */
    limit?: number
  }

  /**
   * campanha_formulario updateManyAndReturn
   */
  export type campanha_formularioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * The data used to update campanha_formularios.
     */
    data: XOR<campanha_formularioUpdateManyMutationInput, campanha_formularioUncheckedUpdateManyInput>
    /**
     * Filter which campanha_formularios to update
     */
    where?: campanha_formularioWhereInput
    /**
     * Limit how many campanha_formularios to update.
     */
    limit?: number
  }

  /**
   * campanha_formulario upsert
   */
  export type campanha_formularioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * The filter to search for the campanha_formulario to update in case it exists.
     */
    where: campanha_formularioWhereUniqueInput
    /**
     * In case the campanha_formulario found by the `where` argument doesn't exist, create a new campanha_formulario with this data.
     */
    create: XOR<campanha_formularioCreateInput, campanha_formularioUncheckedCreateInput>
    /**
     * In case the campanha_formulario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campanha_formularioUpdateInput, campanha_formularioUncheckedUpdateInput>
  }

  /**
   * campanha_formulario delete
   */
  export type campanha_formularioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
    /**
     * Filter which campanha_formulario to delete.
     */
    where: campanha_formularioWhereUniqueInput
  }

  /**
   * campanha_formulario deleteMany
   */
  export type campanha_formularioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanha_formularios to delete
     */
    where?: campanha_formularioWhereInput
    /**
     * Limit how many campanha_formularios to delete.
     */
    limit?: number
  }

  /**
   * campanha_formulario without action
   */
  export type campanha_formularioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha_formulario
     */
    select?: campanha_formularioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha_formulario
     */
    omit?: campanha_formularioOmit<ExtArgs> | null
  }


  /**
   * Model campanha
   */

  export type AggregateCampanha = {
    _count: CampanhaCountAggregateOutputType | null
    _avg: CampanhaAvgAggregateOutputType | null
    _sum: CampanhaSumAggregateOutputType | null
    _min: CampanhaMinAggregateOutputType | null
    _max: CampanhaMaxAggregateOutputType | null
  }

  export type CampanhaAvgAggregateOutputType = {
    id_campanha: number | null
    id_empresa: number | null
    envia_msg: number | null
    ativo: number | null
    qtde_servico: number | null
    id_user: number | null
    gera_token: number | null
    qtde_token: number | null
    qtde_pontos: number | null
    id_campanha_msg: number | null
  }

  export type CampanhaSumAggregateOutputType = {
    id_campanha: number | null
    id_empresa: number | null
    envia_msg: number | null
    ativo: number | null
    qtde_servico: number | null
    id_user: number | null
    gera_token: number | null
    qtde_token: number | null
    qtde_pontos: number | null
    id_campanha_msg: number | null
  }

  export type CampanhaMinAggregateOutputType = {
    id_campanha: number | null
    id_empresa: number | null
    envia_msg: number | null
    recompensa: string | null
    nome_campanha: string | null
    data_inicio: Date | null
    data_fim: Date | null
    ativo: number | null
    qtde_servico: number | null
    descricao: string | null
    id_user: number | null
    gera_token: number | null
    nro_campanha_cliente: string | null
    qtde_token: number | null
    qtde_pontos: number | null
    id_campanha_msg: number | null
    mensagem_cliente: string | null
    uid: string | null
  }

  export type CampanhaMaxAggregateOutputType = {
    id_campanha: number | null
    id_empresa: number | null
    envia_msg: number | null
    recompensa: string | null
    nome_campanha: string | null
    data_inicio: Date | null
    data_fim: Date | null
    ativo: number | null
    qtde_servico: number | null
    descricao: string | null
    id_user: number | null
    gera_token: number | null
    nro_campanha_cliente: string | null
    qtde_token: number | null
    qtde_pontos: number | null
    id_campanha_msg: number | null
    mensagem_cliente: string | null
    uid: string | null
  }

  export type CampanhaCountAggregateOutputType = {
    id_campanha: number
    id_empresa: number
    envia_msg: number
    recompensa: number
    nome_campanha: number
    data_inicio: number
    data_fim: number
    ativo: number
    qtde_servico: number
    descricao: number
    id_user: number
    gera_token: number
    nro_campanha_cliente: number
    qtde_token: number
    qtde_pontos: number
    id_campanha_msg: number
    mensagem_cliente: number
    uid: number
    _all: number
  }


  export type CampanhaAvgAggregateInputType = {
    id_campanha?: true
    id_empresa?: true
    envia_msg?: true
    ativo?: true
    qtde_servico?: true
    id_user?: true
    gera_token?: true
    qtde_token?: true
    qtde_pontos?: true
    id_campanha_msg?: true
  }

  export type CampanhaSumAggregateInputType = {
    id_campanha?: true
    id_empresa?: true
    envia_msg?: true
    ativo?: true
    qtde_servico?: true
    id_user?: true
    gera_token?: true
    qtde_token?: true
    qtde_pontos?: true
    id_campanha_msg?: true
  }

  export type CampanhaMinAggregateInputType = {
    id_campanha?: true
    id_empresa?: true
    envia_msg?: true
    recompensa?: true
    nome_campanha?: true
    data_inicio?: true
    data_fim?: true
    ativo?: true
    qtde_servico?: true
    descricao?: true
    id_user?: true
    gera_token?: true
    nro_campanha_cliente?: true
    qtde_token?: true
    qtde_pontos?: true
    id_campanha_msg?: true
    mensagem_cliente?: true
    uid?: true
  }

  export type CampanhaMaxAggregateInputType = {
    id_campanha?: true
    id_empresa?: true
    envia_msg?: true
    recompensa?: true
    nome_campanha?: true
    data_inicio?: true
    data_fim?: true
    ativo?: true
    qtde_servico?: true
    descricao?: true
    id_user?: true
    gera_token?: true
    nro_campanha_cliente?: true
    qtde_token?: true
    qtde_pontos?: true
    id_campanha_msg?: true
    mensagem_cliente?: true
    uid?: true
  }

  export type CampanhaCountAggregateInputType = {
    id_campanha?: true
    id_empresa?: true
    envia_msg?: true
    recompensa?: true
    nome_campanha?: true
    data_inicio?: true
    data_fim?: true
    ativo?: true
    qtde_servico?: true
    descricao?: true
    id_user?: true
    gera_token?: true
    nro_campanha_cliente?: true
    qtde_token?: true
    qtde_pontos?: true
    id_campanha_msg?: true
    mensagem_cliente?: true
    uid?: true
    _all?: true
  }

  export type CampanhaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanha to aggregate.
     */
    where?: campanhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanhas to fetch.
     */
    orderBy?: campanhaOrderByWithRelationInput | campanhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campanhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campanhas
    **/
    _count?: true | CampanhaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampanhaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampanhaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampanhaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampanhaMaxAggregateInputType
  }

  export type GetCampanhaAggregateType<T extends CampanhaAggregateArgs> = {
        [P in keyof T & keyof AggregateCampanha]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampanha[P]>
      : GetScalarType<T[P], AggregateCampanha[P]>
  }




  export type campanhaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campanhaWhereInput
    orderBy?: campanhaOrderByWithAggregationInput | campanhaOrderByWithAggregationInput[]
    by: CampanhaScalarFieldEnum[] | CampanhaScalarFieldEnum
    having?: campanhaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampanhaCountAggregateInputType | true
    _avg?: CampanhaAvgAggregateInputType
    _sum?: CampanhaSumAggregateInputType
    _min?: CampanhaMinAggregateInputType
    _max?: CampanhaMaxAggregateInputType
  }

  export type CampanhaGroupByOutputType = {
    id_campanha: number
    id_empresa: number
    envia_msg: number | null
    recompensa: string | null
    nome_campanha: string
    data_inicio: Date | null
    data_fim: Date | null
    ativo: number | null
    qtde_servico: number
    descricao: string | null
    id_user: number | null
    gera_token: number | null
    nro_campanha_cliente: string | null
    qtde_token: number | null
    qtde_pontos: number | null
    id_campanha_msg: number | null
    mensagem_cliente: string | null
    uid: string
    _count: CampanhaCountAggregateOutputType | null
    _avg: CampanhaAvgAggregateOutputType | null
    _sum: CampanhaSumAggregateOutputType | null
    _min: CampanhaMinAggregateOutputType | null
    _max: CampanhaMaxAggregateOutputType | null
  }

  type GetCampanhaGroupByPayload<T extends campanhaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampanhaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampanhaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampanhaGroupByOutputType[P]>
            : GetScalarType<T[P], CampanhaGroupByOutputType[P]>
        }
      >
    >


  export type campanhaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha?: boolean
    id_empresa?: boolean
    envia_msg?: boolean
    recompensa?: boolean
    nome_campanha?: boolean
    data_inicio?: boolean
    data_fim?: boolean
    ativo?: boolean
    qtde_servico?: boolean
    descricao?: boolean
    id_user?: boolean
    gera_token?: boolean
    nro_campanha_cliente?: boolean
    qtde_token?: boolean
    qtde_pontos?: boolean
    id_campanha_msg?: boolean
    mensagem_cliente?: boolean
    uid?: boolean
  }, ExtArgs["result"]["campanha"]>

  export type campanhaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha?: boolean
    id_empresa?: boolean
    envia_msg?: boolean
    recompensa?: boolean
    nome_campanha?: boolean
    data_inicio?: boolean
    data_fim?: boolean
    ativo?: boolean
    qtde_servico?: boolean
    descricao?: boolean
    id_user?: boolean
    gera_token?: boolean
    nro_campanha_cliente?: boolean
    qtde_token?: boolean
    qtde_pontos?: boolean
    id_campanha_msg?: boolean
    mensagem_cliente?: boolean
    uid?: boolean
  }, ExtArgs["result"]["campanha"]>

  export type campanhaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_campanha?: boolean
    id_empresa?: boolean
    envia_msg?: boolean
    recompensa?: boolean
    nome_campanha?: boolean
    data_inicio?: boolean
    data_fim?: boolean
    ativo?: boolean
    qtde_servico?: boolean
    descricao?: boolean
    id_user?: boolean
    gera_token?: boolean
    nro_campanha_cliente?: boolean
    qtde_token?: boolean
    qtde_pontos?: boolean
    id_campanha_msg?: boolean
    mensagem_cliente?: boolean
    uid?: boolean
  }, ExtArgs["result"]["campanha"]>

  export type campanhaSelectScalar = {
    id_campanha?: boolean
    id_empresa?: boolean
    envia_msg?: boolean
    recompensa?: boolean
    nome_campanha?: boolean
    data_inicio?: boolean
    data_fim?: boolean
    ativo?: boolean
    qtde_servico?: boolean
    descricao?: boolean
    id_user?: boolean
    gera_token?: boolean
    nro_campanha_cliente?: boolean
    qtde_token?: boolean
    qtde_pontos?: boolean
    id_campanha_msg?: boolean
    mensagem_cliente?: boolean
    uid?: boolean
  }

  export type campanhaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_campanha" | "id_empresa" | "envia_msg" | "recompensa" | "nome_campanha" | "data_inicio" | "data_fim" | "ativo" | "qtde_servico" | "descricao" | "id_user" | "gera_token" | "nro_campanha_cliente" | "qtde_token" | "qtde_pontos" | "id_campanha_msg" | "mensagem_cliente" | "uid", ExtArgs["result"]["campanha"]>

  export type $campanhaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campanha"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_campanha: number
      id_empresa: number
      envia_msg: number | null
      recompensa: string | null
      nome_campanha: string
      data_inicio: Date | null
      data_fim: Date | null
      ativo: number | null
      qtde_servico: number
      descricao: string | null
      id_user: number | null
      gera_token: number | null
      nro_campanha_cliente: string | null
      qtde_token: number | null
      qtde_pontos: number | null
      id_campanha_msg: number | null
      mensagem_cliente: string | null
      uid: string
    }, ExtArgs["result"]["campanha"]>
    composites: {}
  }

  type campanhaGetPayload<S extends boolean | null | undefined | campanhaDefaultArgs> = $Result.GetResult<Prisma.$campanhaPayload, S>

  type campanhaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<campanhaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampanhaCountAggregateInputType | true
    }

  export interface campanhaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campanha'], meta: { name: 'campanha' } }
    /**
     * Find zero or one Campanha that matches the filter.
     * @param {campanhaFindUniqueArgs} args - Arguments to find a Campanha
     * @example
     * // Get one Campanha
     * const campanha = await prisma.campanha.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campanhaFindUniqueArgs>(args: SelectSubset<T, campanhaFindUniqueArgs<ExtArgs>>): Prisma__campanhaClient<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campanha that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {campanhaFindUniqueOrThrowArgs} args - Arguments to find a Campanha
     * @example
     * // Get one Campanha
     * const campanha = await prisma.campanha.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campanhaFindUniqueOrThrowArgs>(args: SelectSubset<T, campanhaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campanhaClient<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campanha that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanhaFindFirstArgs} args - Arguments to find a Campanha
     * @example
     * // Get one Campanha
     * const campanha = await prisma.campanha.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campanhaFindFirstArgs>(args?: SelectSubset<T, campanhaFindFirstArgs<ExtArgs>>): Prisma__campanhaClient<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campanha that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanhaFindFirstOrThrowArgs} args - Arguments to find a Campanha
     * @example
     * // Get one Campanha
     * const campanha = await prisma.campanha.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campanhaFindFirstOrThrowArgs>(args?: SelectSubset<T, campanhaFindFirstOrThrowArgs<ExtArgs>>): Prisma__campanhaClient<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campanhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanhaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campanhas
     * const campanhas = await prisma.campanha.findMany()
     * 
     * // Get first 10 Campanhas
     * const campanhas = await prisma.campanha.findMany({ take: 10 })
     * 
     * // Only select the `id_campanha`
     * const campanhaWithId_campanhaOnly = await prisma.campanha.findMany({ select: { id_campanha: true } })
     * 
     */
    findMany<T extends campanhaFindManyArgs>(args?: SelectSubset<T, campanhaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campanha.
     * @param {campanhaCreateArgs} args - Arguments to create a Campanha.
     * @example
     * // Create one Campanha
     * const Campanha = await prisma.campanha.create({
     *   data: {
     *     // ... data to create a Campanha
     *   }
     * })
     * 
     */
    create<T extends campanhaCreateArgs>(args: SelectSubset<T, campanhaCreateArgs<ExtArgs>>): Prisma__campanhaClient<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campanhas.
     * @param {campanhaCreateManyArgs} args - Arguments to create many Campanhas.
     * @example
     * // Create many Campanhas
     * const campanha = await prisma.campanha.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campanhaCreateManyArgs>(args?: SelectSubset<T, campanhaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campanhas and returns the data saved in the database.
     * @param {campanhaCreateManyAndReturnArgs} args - Arguments to create many Campanhas.
     * @example
     * // Create many Campanhas
     * const campanha = await prisma.campanha.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campanhas and only return the `id_campanha`
     * const campanhaWithId_campanhaOnly = await prisma.campanha.createManyAndReturn({
     *   select: { id_campanha: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campanhaCreateManyAndReturnArgs>(args?: SelectSubset<T, campanhaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campanha.
     * @param {campanhaDeleteArgs} args - Arguments to delete one Campanha.
     * @example
     * // Delete one Campanha
     * const Campanha = await prisma.campanha.delete({
     *   where: {
     *     // ... filter to delete one Campanha
     *   }
     * })
     * 
     */
    delete<T extends campanhaDeleteArgs>(args: SelectSubset<T, campanhaDeleteArgs<ExtArgs>>): Prisma__campanhaClient<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campanha.
     * @param {campanhaUpdateArgs} args - Arguments to update one Campanha.
     * @example
     * // Update one Campanha
     * const campanha = await prisma.campanha.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campanhaUpdateArgs>(args: SelectSubset<T, campanhaUpdateArgs<ExtArgs>>): Prisma__campanhaClient<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campanhas.
     * @param {campanhaDeleteManyArgs} args - Arguments to filter Campanhas to delete.
     * @example
     * // Delete a few Campanhas
     * const { count } = await prisma.campanha.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campanhaDeleteManyArgs>(args?: SelectSubset<T, campanhaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanhaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campanhas
     * const campanha = await prisma.campanha.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campanhaUpdateManyArgs>(args: SelectSubset<T, campanhaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanhas and returns the data updated in the database.
     * @param {campanhaUpdateManyAndReturnArgs} args - Arguments to update many Campanhas.
     * @example
     * // Update many Campanhas
     * const campanha = await prisma.campanha.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campanhas and only return the `id_campanha`
     * const campanhaWithId_campanhaOnly = await prisma.campanha.updateManyAndReturn({
     *   select: { id_campanha: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends campanhaUpdateManyAndReturnArgs>(args: SelectSubset<T, campanhaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campanha.
     * @param {campanhaUpsertArgs} args - Arguments to update or create a Campanha.
     * @example
     * // Update or create a Campanha
     * const campanha = await prisma.campanha.upsert({
     *   create: {
     *     // ... data to create a Campanha
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campanha we want to update
     *   }
     * })
     */
    upsert<T extends campanhaUpsertArgs>(args: SelectSubset<T, campanhaUpsertArgs<ExtArgs>>): Prisma__campanhaClient<$Result.GetResult<Prisma.$campanhaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campanhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanhaCountArgs} args - Arguments to filter Campanhas to count.
     * @example
     * // Count the number of Campanhas
     * const count = await prisma.campanha.count({
     *   where: {
     *     // ... the filter for the Campanhas we want to count
     *   }
     * })
    **/
    count<T extends campanhaCountArgs>(
      args?: Subset<T, campanhaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampanhaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campanha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampanhaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampanhaAggregateArgs>(args: Subset<T, CampanhaAggregateArgs>): Prisma.PrismaPromise<GetCampanhaAggregateType<T>>

    /**
     * Group by Campanha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanhaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campanhaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campanhaGroupByArgs['orderBy'] }
        : { orderBy?: campanhaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campanhaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampanhaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campanha model
   */
  readonly fields: campanhaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campanha.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campanhaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campanha model
   */
  interface campanhaFieldRefs {
    readonly id_campanha: FieldRef<"campanha", 'Int'>
    readonly id_empresa: FieldRef<"campanha", 'Int'>
    readonly envia_msg: FieldRef<"campanha", 'Int'>
    readonly recompensa: FieldRef<"campanha", 'String'>
    readonly nome_campanha: FieldRef<"campanha", 'String'>
    readonly data_inicio: FieldRef<"campanha", 'DateTime'>
    readonly data_fim: FieldRef<"campanha", 'DateTime'>
    readonly ativo: FieldRef<"campanha", 'Int'>
    readonly qtde_servico: FieldRef<"campanha", 'Int'>
    readonly descricao: FieldRef<"campanha", 'String'>
    readonly id_user: FieldRef<"campanha", 'Int'>
    readonly gera_token: FieldRef<"campanha", 'Int'>
    readonly nro_campanha_cliente: FieldRef<"campanha", 'String'>
    readonly qtde_token: FieldRef<"campanha", 'Int'>
    readonly qtde_pontos: FieldRef<"campanha", 'Int'>
    readonly id_campanha_msg: FieldRef<"campanha", 'Int'>
    readonly mensagem_cliente: FieldRef<"campanha", 'String'>
    readonly uid: FieldRef<"campanha", 'String'>
  }
    

  // Custom InputTypes
  /**
   * campanha findUnique
   */
  export type campanhaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * Filter, which campanha to fetch.
     */
    where: campanhaWhereUniqueInput
  }

  /**
   * campanha findUniqueOrThrow
   */
  export type campanhaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * Filter, which campanha to fetch.
     */
    where: campanhaWhereUniqueInput
  }

  /**
   * campanha findFirst
   */
  export type campanhaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * Filter, which campanha to fetch.
     */
    where?: campanhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanhas to fetch.
     */
    orderBy?: campanhaOrderByWithRelationInput | campanhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanhas.
     */
    cursor?: campanhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanhas.
     */
    distinct?: CampanhaScalarFieldEnum | CampanhaScalarFieldEnum[]
  }

  /**
   * campanha findFirstOrThrow
   */
  export type campanhaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * Filter, which campanha to fetch.
     */
    where?: campanhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanhas to fetch.
     */
    orderBy?: campanhaOrderByWithRelationInput | campanhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanhas.
     */
    cursor?: campanhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanhas.
     */
    distinct?: CampanhaScalarFieldEnum | CampanhaScalarFieldEnum[]
  }

  /**
   * campanha findMany
   */
  export type campanhaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * Filter, which campanhas to fetch.
     */
    where?: campanhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanhas to fetch.
     */
    orderBy?: campanhaOrderByWithRelationInput | campanhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campanhas.
     */
    cursor?: campanhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanhas.
     */
    skip?: number
    distinct?: CampanhaScalarFieldEnum | CampanhaScalarFieldEnum[]
  }

  /**
   * campanha create
   */
  export type campanhaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * The data needed to create a campanha.
     */
    data: XOR<campanhaCreateInput, campanhaUncheckedCreateInput>
  }

  /**
   * campanha createMany
   */
  export type campanhaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campanhas.
     */
    data: campanhaCreateManyInput | campanhaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campanha createManyAndReturn
   */
  export type campanhaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * The data used to create many campanhas.
     */
    data: campanhaCreateManyInput | campanhaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campanha update
   */
  export type campanhaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * The data needed to update a campanha.
     */
    data: XOR<campanhaUpdateInput, campanhaUncheckedUpdateInput>
    /**
     * Choose, which campanha to update.
     */
    where: campanhaWhereUniqueInput
  }

  /**
   * campanha updateMany
   */
  export type campanhaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campanhas.
     */
    data: XOR<campanhaUpdateManyMutationInput, campanhaUncheckedUpdateManyInput>
    /**
     * Filter which campanhas to update
     */
    where?: campanhaWhereInput
    /**
     * Limit how many campanhas to update.
     */
    limit?: number
  }

  /**
   * campanha updateManyAndReturn
   */
  export type campanhaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * The data used to update campanhas.
     */
    data: XOR<campanhaUpdateManyMutationInput, campanhaUncheckedUpdateManyInput>
    /**
     * Filter which campanhas to update
     */
    where?: campanhaWhereInput
    /**
     * Limit how many campanhas to update.
     */
    limit?: number
  }

  /**
   * campanha upsert
   */
  export type campanhaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * The filter to search for the campanha to update in case it exists.
     */
    where: campanhaWhereUniqueInput
    /**
     * In case the campanha found by the `where` argument doesn't exist, create a new campanha with this data.
     */
    create: XOR<campanhaCreateInput, campanhaUncheckedCreateInput>
    /**
     * In case the campanha was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campanhaUpdateInput, campanhaUncheckedUpdateInput>
  }

  /**
   * campanha delete
   */
  export type campanhaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
    /**
     * Filter which campanha to delete.
     */
    where: campanhaWhereUniqueInput
  }

  /**
   * campanha deleteMany
   */
  export type campanhaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanhas to delete
     */
    where?: campanhaWhereInput
    /**
     * Limit how many campanhas to delete.
     */
    limit?: number
  }

  /**
   * campanha without action
   */
  export type campanhaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanha
     */
    select?: campanhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campanha
     */
    omit?: campanhaOmit<ExtArgs> | null
  }


  /**
   * Model carimbo
   */

  export type AggregateCarimbo = {
    _count: CarimboCountAggregateOutputType | null
    _avg: CarimboAvgAggregateOutputType | null
    _sum: CarimboSumAggregateOutputType | null
    _min: CarimboMinAggregateOutputType | null
    _max: CarimboMaxAggregateOutputType | null
  }

  export type CarimboAvgAggregateOutputType = {
    id_carimbo: number | null
    id_user_carimbou: number | null
    id_user: number | null
    id_campanha: number | null
    qtde_carimbo: number | null
    id_resgate: number | null
  }

  export type CarimboSumAggregateOutputType = {
    id_carimbo: number | null
    id_user_carimbou: number | null
    id_user: number | null
    id_campanha: number | null
    qtde_carimbo: number | null
    id_resgate: number | null
  }

  export type CarimboMinAggregateOutputType = {
    id_carimbo: number | null
    id_user_carimbou: number | null
    id_user: number | null
    id_campanha: number | null
    data_carimbo: Date | null
    qtde_carimbo: number | null
    id_resgate: number | null
  }

  export type CarimboMaxAggregateOutputType = {
    id_carimbo: number | null
    id_user_carimbou: number | null
    id_user: number | null
    id_campanha: number | null
    data_carimbo: Date | null
    qtde_carimbo: number | null
    id_resgate: number | null
  }

  export type CarimboCountAggregateOutputType = {
    id_carimbo: number
    id_user_carimbou: number
    id_user: number
    id_campanha: number
    data_carimbo: number
    qtde_carimbo: number
    id_resgate: number
    _all: number
  }


  export type CarimboAvgAggregateInputType = {
    id_carimbo?: true
    id_user_carimbou?: true
    id_user?: true
    id_campanha?: true
    qtde_carimbo?: true
    id_resgate?: true
  }

  export type CarimboSumAggregateInputType = {
    id_carimbo?: true
    id_user_carimbou?: true
    id_user?: true
    id_campanha?: true
    qtde_carimbo?: true
    id_resgate?: true
  }

  export type CarimboMinAggregateInputType = {
    id_carimbo?: true
    id_user_carimbou?: true
    id_user?: true
    id_campanha?: true
    data_carimbo?: true
    qtde_carimbo?: true
    id_resgate?: true
  }

  export type CarimboMaxAggregateInputType = {
    id_carimbo?: true
    id_user_carimbou?: true
    id_user?: true
    id_campanha?: true
    data_carimbo?: true
    qtde_carimbo?: true
    id_resgate?: true
  }

  export type CarimboCountAggregateInputType = {
    id_carimbo?: true
    id_user_carimbou?: true
    id_user?: true
    id_campanha?: true
    data_carimbo?: true
    qtde_carimbo?: true
    id_resgate?: true
    _all?: true
  }

  export type CarimboAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which carimbo to aggregate.
     */
    where?: carimboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carimbos to fetch.
     */
    orderBy?: carimboOrderByWithRelationInput | carimboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: carimboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carimbos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carimbos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned carimbos
    **/
    _count?: true | CarimboCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarimboAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarimboSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarimboMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarimboMaxAggregateInputType
  }

  export type GetCarimboAggregateType<T extends CarimboAggregateArgs> = {
        [P in keyof T & keyof AggregateCarimbo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarimbo[P]>
      : GetScalarType<T[P], AggregateCarimbo[P]>
  }




  export type carimboGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: carimboWhereInput
    orderBy?: carimboOrderByWithAggregationInput | carimboOrderByWithAggregationInput[]
    by: CarimboScalarFieldEnum[] | CarimboScalarFieldEnum
    having?: carimboScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarimboCountAggregateInputType | true
    _avg?: CarimboAvgAggregateInputType
    _sum?: CarimboSumAggregateInputType
    _min?: CarimboMinAggregateInputType
    _max?: CarimboMaxAggregateInputType
  }

  export type CarimboGroupByOutputType = {
    id_carimbo: number
    id_user_carimbou: number
    id_user: number
    id_campanha: number
    data_carimbo: Date | null
    qtde_carimbo: number | null
    id_resgate: number | null
    _count: CarimboCountAggregateOutputType | null
    _avg: CarimboAvgAggregateOutputType | null
    _sum: CarimboSumAggregateOutputType | null
    _min: CarimboMinAggregateOutputType | null
    _max: CarimboMaxAggregateOutputType | null
  }

  type GetCarimboGroupByPayload<T extends carimboGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarimboGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarimboGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarimboGroupByOutputType[P]>
            : GetScalarType<T[P], CarimboGroupByOutputType[P]>
        }
      >
    >


  export type carimboSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_carimbo?: boolean
    id_user_carimbou?: boolean
    id_user?: boolean
    id_campanha?: boolean
    data_carimbo?: boolean
    qtde_carimbo?: boolean
    id_resgate?: boolean
  }, ExtArgs["result"]["carimbo"]>

  export type carimboSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_carimbo?: boolean
    id_user_carimbou?: boolean
    id_user?: boolean
    id_campanha?: boolean
    data_carimbo?: boolean
    qtde_carimbo?: boolean
    id_resgate?: boolean
  }, ExtArgs["result"]["carimbo"]>

  export type carimboSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_carimbo?: boolean
    id_user_carimbou?: boolean
    id_user?: boolean
    id_campanha?: boolean
    data_carimbo?: boolean
    qtde_carimbo?: boolean
    id_resgate?: boolean
  }, ExtArgs["result"]["carimbo"]>

  export type carimboSelectScalar = {
    id_carimbo?: boolean
    id_user_carimbou?: boolean
    id_user?: boolean
    id_campanha?: boolean
    data_carimbo?: boolean
    qtde_carimbo?: boolean
    id_resgate?: boolean
  }

  export type carimboOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_carimbo" | "id_user_carimbou" | "id_user" | "id_campanha" | "data_carimbo" | "qtde_carimbo" | "id_resgate", ExtArgs["result"]["carimbo"]>

  export type $carimboPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "carimbo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_carimbo: number
      id_user_carimbou: number
      id_user: number
      id_campanha: number
      data_carimbo: Date | null
      qtde_carimbo: number | null
      id_resgate: number | null
    }, ExtArgs["result"]["carimbo"]>
    composites: {}
  }

  type carimboGetPayload<S extends boolean | null | undefined | carimboDefaultArgs> = $Result.GetResult<Prisma.$carimboPayload, S>

  type carimboCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<carimboFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarimboCountAggregateInputType | true
    }

  export interface carimboDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['carimbo'], meta: { name: 'carimbo' } }
    /**
     * Find zero or one Carimbo that matches the filter.
     * @param {carimboFindUniqueArgs} args - Arguments to find a Carimbo
     * @example
     * // Get one Carimbo
     * const carimbo = await prisma.carimbo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends carimboFindUniqueArgs>(args: SelectSubset<T, carimboFindUniqueArgs<ExtArgs>>): Prisma__carimboClient<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Carimbo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {carimboFindUniqueOrThrowArgs} args - Arguments to find a Carimbo
     * @example
     * // Get one Carimbo
     * const carimbo = await prisma.carimbo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends carimboFindUniqueOrThrowArgs>(args: SelectSubset<T, carimboFindUniqueOrThrowArgs<ExtArgs>>): Prisma__carimboClient<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carimbo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carimboFindFirstArgs} args - Arguments to find a Carimbo
     * @example
     * // Get one Carimbo
     * const carimbo = await prisma.carimbo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends carimboFindFirstArgs>(args?: SelectSubset<T, carimboFindFirstArgs<ExtArgs>>): Prisma__carimboClient<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carimbo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carimboFindFirstOrThrowArgs} args - Arguments to find a Carimbo
     * @example
     * // Get one Carimbo
     * const carimbo = await prisma.carimbo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends carimboFindFirstOrThrowArgs>(args?: SelectSubset<T, carimboFindFirstOrThrowArgs<ExtArgs>>): Prisma__carimboClient<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carimbos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carimboFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carimbos
     * const carimbos = await prisma.carimbo.findMany()
     * 
     * // Get first 10 Carimbos
     * const carimbos = await prisma.carimbo.findMany({ take: 10 })
     * 
     * // Only select the `id_carimbo`
     * const carimboWithId_carimboOnly = await prisma.carimbo.findMany({ select: { id_carimbo: true } })
     * 
     */
    findMany<T extends carimboFindManyArgs>(args?: SelectSubset<T, carimboFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Carimbo.
     * @param {carimboCreateArgs} args - Arguments to create a Carimbo.
     * @example
     * // Create one Carimbo
     * const Carimbo = await prisma.carimbo.create({
     *   data: {
     *     // ... data to create a Carimbo
     *   }
     * })
     * 
     */
    create<T extends carimboCreateArgs>(args: SelectSubset<T, carimboCreateArgs<ExtArgs>>): Prisma__carimboClient<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carimbos.
     * @param {carimboCreateManyArgs} args - Arguments to create many Carimbos.
     * @example
     * // Create many Carimbos
     * const carimbo = await prisma.carimbo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends carimboCreateManyArgs>(args?: SelectSubset<T, carimboCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carimbos and returns the data saved in the database.
     * @param {carimboCreateManyAndReturnArgs} args - Arguments to create many Carimbos.
     * @example
     * // Create many Carimbos
     * const carimbo = await prisma.carimbo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carimbos and only return the `id_carimbo`
     * const carimboWithId_carimboOnly = await prisma.carimbo.createManyAndReturn({
     *   select: { id_carimbo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends carimboCreateManyAndReturnArgs>(args?: SelectSubset<T, carimboCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Carimbo.
     * @param {carimboDeleteArgs} args - Arguments to delete one Carimbo.
     * @example
     * // Delete one Carimbo
     * const Carimbo = await prisma.carimbo.delete({
     *   where: {
     *     // ... filter to delete one Carimbo
     *   }
     * })
     * 
     */
    delete<T extends carimboDeleteArgs>(args: SelectSubset<T, carimboDeleteArgs<ExtArgs>>): Prisma__carimboClient<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Carimbo.
     * @param {carimboUpdateArgs} args - Arguments to update one Carimbo.
     * @example
     * // Update one Carimbo
     * const carimbo = await prisma.carimbo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends carimboUpdateArgs>(args: SelectSubset<T, carimboUpdateArgs<ExtArgs>>): Prisma__carimboClient<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carimbos.
     * @param {carimboDeleteManyArgs} args - Arguments to filter Carimbos to delete.
     * @example
     * // Delete a few Carimbos
     * const { count } = await prisma.carimbo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends carimboDeleteManyArgs>(args?: SelectSubset<T, carimboDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carimbos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carimboUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carimbos
     * const carimbo = await prisma.carimbo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends carimboUpdateManyArgs>(args: SelectSubset<T, carimboUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carimbos and returns the data updated in the database.
     * @param {carimboUpdateManyAndReturnArgs} args - Arguments to update many Carimbos.
     * @example
     * // Update many Carimbos
     * const carimbo = await prisma.carimbo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carimbos and only return the `id_carimbo`
     * const carimboWithId_carimboOnly = await prisma.carimbo.updateManyAndReturn({
     *   select: { id_carimbo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends carimboUpdateManyAndReturnArgs>(args: SelectSubset<T, carimboUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Carimbo.
     * @param {carimboUpsertArgs} args - Arguments to update or create a Carimbo.
     * @example
     * // Update or create a Carimbo
     * const carimbo = await prisma.carimbo.upsert({
     *   create: {
     *     // ... data to create a Carimbo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carimbo we want to update
     *   }
     * })
     */
    upsert<T extends carimboUpsertArgs>(args: SelectSubset<T, carimboUpsertArgs<ExtArgs>>): Prisma__carimboClient<$Result.GetResult<Prisma.$carimboPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carimbos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carimboCountArgs} args - Arguments to filter Carimbos to count.
     * @example
     * // Count the number of Carimbos
     * const count = await prisma.carimbo.count({
     *   where: {
     *     // ... the filter for the Carimbos we want to count
     *   }
     * })
    **/
    count<T extends carimboCountArgs>(
      args?: Subset<T, carimboCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarimboCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carimbo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarimboAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarimboAggregateArgs>(args: Subset<T, CarimboAggregateArgs>): Prisma.PrismaPromise<GetCarimboAggregateType<T>>

    /**
     * Group by Carimbo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carimboGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends carimboGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: carimboGroupByArgs['orderBy'] }
        : { orderBy?: carimboGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, carimboGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarimboGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the carimbo model
   */
  readonly fields: carimboFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for carimbo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__carimboClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the carimbo model
   */
  interface carimboFieldRefs {
    readonly id_carimbo: FieldRef<"carimbo", 'Int'>
    readonly id_user_carimbou: FieldRef<"carimbo", 'Int'>
    readonly id_user: FieldRef<"carimbo", 'Int'>
    readonly id_campanha: FieldRef<"carimbo", 'Int'>
    readonly data_carimbo: FieldRef<"carimbo", 'DateTime'>
    readonly qtde_carimbo: FieldRef<"carimbo", 'Int'>
    readonly id_resgate: FieldRef<"carimbo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * carimbo findUnique
   */
  export type carimboFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * Filter, which carimbo to fetch.
     */
    where: carimboWhereUniqueInput
  }

  /**
   * carimbo findUniqueOrThrow
   */
  export type carimboFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * Filter, which carimbo to fetch.
     */
    where: carimboWhereUniqueInput
  }

  /**
   * carimbo findFirst
   */
  export type carimboFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * Filter, which carimbo to fetch.
     */
    where?: carimboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carimbos to fetch.
     */
    orderBy?: carimboOrderByWithRelationInput | carimboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carimbos.
     */
    cursor?: carimboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carimbos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carimbos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carimbos.
     */
    distinct?: CarimboScalarFieldEnum | CarimboScalarFieldEnum[]
  }

  /**
   * carimbo findFirstOrThrow
   */
  export type carimboFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * Filter, which carimbo to fetch.
     */
    where?: carimboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carimbos to fetch.
     */
    orderBy?: carimboOrderByWithRelationInput | carimboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carimbos.
     */
    cursor?: carimboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carimbos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carimbos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carimbos.
     */
    distinct?: CarimboScalarFieldEnum | CarimboScalarFieldEnum[]
  }

  /**
   * carimbo findMany
   */
  export type carimboFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * Filter, which carimbos to fetch.
     */
    where?: carimboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carimbos to fetch.
     */
    orderBy?: carimboOrderByWithRelationInput | carimboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing carimbos.
     */
    cursor?: carimboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carimbos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carimbos.
     */
    skip?: number
    distinct?: CarimboScalarFieldEnum | CarimboScalarFieldEnum[]
  }

  /**
   * carimbo create
   */
  export type carimboCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * The data needed to create a carimbo.
     */
    data: XOR<carimboCreateInput, carimboUncheckedCreateInput>
  }

  /**
   * carimbo createMany
   */
  export type carimboCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many carimbos.
     */
    data: carimboCreateManyInput | carimboCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * carimbo createManyAndReturn
   */
  export type carimboCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * The data used to create many carimbos.
     */
    data: carimboCreateManyInput | carimboCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * carimbo update
   */
  export type carimboUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * The data needed to update a carimbo.
     */
    data: XOR<carimboUpdateInput, carimboUncheckedUpdateInput>
    /**
     * Choose, which carimbo to update.
     */
    where: carimboWhereUniqueInput
  }

  /**
   * carimbo updateMany
   */
  export type carimboUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update carimbos.
     */
    data: XOR<carimboUpdateManyMutationInput, carimboUncheckedUpdateManyInput>
    /**
     * Filter which carimbos to update
     */
    where?: carimboWhereInput
    /**
     * Limit how many carimbos to update.
     */
    limit?: number
  }

  /**
   * carimbo updateManyAndReturn
   */
  export type carimboUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * The data used to update carimbos.
     */
    data: XOR<carimboUpdateManyMutationInput, carimboUncheckedUpdateManyInput>
    /**
     * Filter which carimbos to update
     */
    where?: carimboWhereInput
    /**
     * Limit how many carimbos to update.
     */
    limit?: number
  }

  /**
   * carimbo upsert
   */
  export type carimboUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * The filter to search for the carimbo to update in case it exists.
     */
    where: carimboWhereUniqueInput
    /**
     * In case the carimbo found by the `where` argument doesn't exist, create a new carimbo with this data.
     */
    create: XOR<carimboCreateInput, carimboUncheckedCreateInput>
    /**
     * In case the carimbo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<carimboUpdateInput, carimboUncheckedUpdateInput>
  }

  /**
   * carimbo delete
   */
  export type carimboDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
    /**
     * Filter which carimbo to delete.
     */
    where: carimboWhereUniqueInput
  }

  /**
   * carimbo deleteMany
   */
  export type carimboDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which carimbos to delete
     */
    where?: carimboWhereInput
    /**
     * Limit how many carimbos to delete.
     */
    limit?: number
  }

  /**
   * carimbo without action
   */
  export type carimboDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the carimbo
     */
    select?: carimboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the carimbo
     */
    omit?: carimboOmit<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    update_at: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    update_at: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    update_at: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    update_at?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    update_at?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    update_at?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    created_at: Date | null
    update_at: Date | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    update_at?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    update_at?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at" | "update_at", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date | null
      update_at: Date | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly created_at: FieldRef<"Category", 'DateTime'>
    readonly update_at: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    description: string | null
    banner: string | null
    created_at: Date | null
    update_at: Date | null
    category_id: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    description: string | null
    banner: string | null
    created_at: Date | null
    update_at: Date | null
    category_id: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    price: number
    description: number
    banner: number
    created_at: number
    update_at: number
    category_id: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    banner?: true
    created_at?: true
    update_at?: true
    category_id?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    banner?: true
    created_at?: true
    update_at?: true
    category_id?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    banner?: true
    created_at?: true
    update_at?: true
    category_id?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    price: string
    description: string
    banner: string
    created_at: Date | null
    update_at: Date | null
    category_id: string
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    banner?: boolean
    created_at?: boolean
    update_at?: boolean
    category_id?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    items?: boolean | Product$itemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    banner?: boolean
    created_at?: boolean
    update_at?: boolean
    category_id?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    banner?: boolean
    created_at?: boolean
    update_at?: boolean
    category_id?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    banner?: boolean
    created_at?: boolean
    update_at?: boolean
    category_id?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "description" | "banner" | "created_at" | "update_at" | "category_id", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    items?: boolean | Product$itemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: string
      description: string
      banner: string
      created_at: Date | null
      update_at: Date | null
      category_id: string
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Product$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly banner: FieldRef<"Product", 'String'>
    readonly created_at: FieldRef<"Product", 'DateTime'>
    readonly update_at: FieldRef<"Product", 'DateTime'>
    readonly category_id: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.items
   */
  export type Product$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    table: number | null
  }

  export type OrderSumAggregateOutputType = {
    table: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    table: number | null
    status: boolean | null
    draft: boolean | null
    name: string | null
    created_at: Date | null
    update_at: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    table: number | null
    status: boolean | null
    draft: boolean | null
    name: string | null
    created_at: Date | null
    update_at: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    table: number
    status: number
    draft: number
    name: number
    created_at: number
    update_at: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    table?: true
  }

  export type OrderSumAggregateInputType = {
    table?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    table?: true
    status?: true
    draft?: true
    name?: true
    created_at?: true
    update_at?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    table?: true
    status?: true
    draft?: true
    name?: true
    created_at?: true
    update_at?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    table?: true
    status?: true
    draft?: true
    name?: true
    created_at?: true
    update_at?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    table: number
    status: boolean
    draft: boolean
    name: string | null
    created_at: Date | null
    update_at: Date | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    table?: boolean
    status?: boolean
    draft?: boolean
    name?: boolean
    created_at?: boolean
    update_at?: boolean
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    table?: boolean
    status?: boolean
    draft?: boolean
    name?: boolean
    created_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    table?: boolean
    status?: boolean
    draft?: boolean
    name?: boolean
    created_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    table?: boolean
    status?: boolean
    draft?: boolean
    name?: boolean
    created_at?: boolean
    update_at?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "table" | "status" | "draft" | "name" | "created_at" | "update_at", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      table: number
      status: boolean
      draft: boolean
      name: string | null
      created_at: Date | null
      update_at: Date | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly table: FieldRef<"Order", 'Int'>
    readonly status: FieldRef<"Order", 'Boolean'>
    readonly draft: FieldRef<"Order", 'Boolean'>
    readonly name: FieldRef<"Order", 'String'>
    readonly created_at: FieldRef<"Order", 'DateTime'>
    readonly update_at: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    amount: number | null
  }

  export type ItemSumAggregateOutputType = {
    amount: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    amount: number | null
    created_at: Date | null
    update_at: Date | null
    order_id: string | null
    product_id: string | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    created_at: Date | null
    update_at: Date | null
    order_id: string | null
    product_id: string | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    amount: number
    created_at: number
    update_at: number
    order_id: number
    product_id: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    amount?: true
  }

  export type ItemSumAggregateInputType = {
    amount?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    amount?: true
    created_at?: true
    update_at?: true
    order_id?: true
    product_id?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    amount?: true
    created_at?: true
    update_at?: true
    order_id?: true
    product_id?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    amount?: true
    created_at?: true
    update_at?: true
    order_id?: true
    product_id?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    amount: number
    created_at: Date | null
    update_at: Date | null
    order_id: string
    product_id: string
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    created_at?: boolean
    update_at?: boolean
    order_id?: boolean
    product_id?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    created_at?: boolean
    update_at?: boolean
    order_id?: boolean
    product_id?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    created_at?: boolean
    update_at?: boolean
    order_id?: boolean
    product_id?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    amount?: boolean
    created_at?: boolean
    update_at?: boolean
    order_id?: boolean
    product_id?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "created_at" | "update_at" | "order_id" | "product_id", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      created_at: Date | null
      update_at: Date | null
      order_id: string
      product_id: string
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly amount: FieldRef<"Item", 'Int'>
    readonly created_at: FieldRef<"Item", 'DateTime'>
    readonly update_at: FieldRef<"Item", 'DateTime'>
    readonly order_id: FieldRef<"Item", 'String'>
    readonly product_id: FieldRef<"Item", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Telefone_compScalarFieldEnum: {
    id_telefone_comp: 'id_telefone_comp',
    id_dados_fisica: 'id_dados_fisica',
    ddd: 'ddd',
    telefone: 'telefone'
  };

  export type Telefone_compScalarFieldEnum = (typeof Telefone_compScalarFieldEnum)[keyof typeof Telefone_compScalarFieldEnum]


  export const Consulta_userScalarFieldEnum: {
    id_consulta_user: 'id_consulta_user',
    id_user: 'id_user',
    data_cadastrou: 'data_cadastrou',
    id_dados_fisica: 'id_dados_fisica'
  };

  export type Consulta_userScalarFieldEnum = (typeof Consulta_userScalarFieldEnum)[keyof typeof Consulta_userScalarFieldEnum]


  export const Consulta_saldoScalarFieldEnum: {
    id_consulta_sado: 'id_consulta_sado',
    id_user: 'id_user',
    data_cadastrou: 'data_cadastrou',
    saldo: 'saldo',
    saldo_contratado: 'saldo_contratado',
    data_atualizou: 'data_atualizou'
  };

  export type Consulta_saldoScalarFieldEnum = (typeof Consulta_saldoScalarFieldEnum)[keyof typeof Consulta_saldoScalarFieldEnum]


  export const Consulta_insere_logScalarFieldEnum: {
    id_consulta_insere: 'id_consulta_insere',
    id_user: 'id_user',
    data_cadastrou: 'data_cadastrou',
    debito: 'debito',
    fonte_propria: 'fonte_propria',
    consulta: 'consulta',
    id_dados_fisica: 'id_dados_fisica'
  };

  export type Consulta_insere_logScalarFieldEnum = (typeof Consulta_insere_logScalarFieldEnum)[keyof typeof Consulta_insere_logScalarFieldEnum]


  export const Dados_fisicaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    cpf: 'cpf',
    tipo_end: 'tipo_end',
    rua: 'rua',
    numero: 'numero',
    cidade: 'cidade',
    uf: 'uf',
    cep: 'cep',
    morto: 'morto',
    celular_ddd: 'celular_ddd',
    celular_number: 'celular_number',
    connect_whats: 'connect_whats',
    rg: 'rg',
    bairro: 'bairro',
    nome_mae: 'nome_mae',
    data_aniversaio: 'data_aniversaio'
  };

  export type Dados_fisicaScalarFieldEnum = (typeof Dados_fisicaScalarFieldEnum)[keyof typeof Dados_fisicaScalarFieldEnum]


  export const Crm_clienteScalarFieldEnum: {
    CODIGO_CLIENTE: 'CODIGO_CLIENTE',
    CPF: 'CPF',
    DATA_VENDA: 'DATA_VENDA',
    TICKET: 'TICKET',
    CODIGO_FILIAL: 'CODIGO_FILIAL',
    VALOR_PAGO: 'VALOR_PAGO',
    VALOR_TIKET: 'VALOR_TIKET',
    ULTIMA_COMPRA: 'ULTIMA_COMPRA',
    NOME_SOCIAL: 'NOME_SOCIAL',
    CLIENTE_VAREJO: 'CLIENTE_VAREJO',
    ANIVERSARIO: 'ANIVERSARIO',
    EMAIL: 'EMAIL',
    DDD_CELULAR: 'DDD_CELULAR',
    CELULAR: 'CELULAR',
    DATA_CADASTROU: 'DATA_CADASTROU'
  };

  export type Crm_clienteScalarFieldEnum = (typeof Crm_clienteScalarFieldEnum)[keyof typeof Crm_clienteScalarFieldEnum]


  export const Status_pedidoScalarFieldEnum: {
    id_status_pedido: 'id_status_pedido',
    nome_status: 'nome_status',
    id_empresa: 'id_empresa',
    ativo: 'ativo',
    data_cadastrou: 'data_cadastrou'
  };

  export type Status_pedidoScalarFieldEnum = (typeof Status_pedidoScalarFieldEnum)[keyof typeof Status_pedidoScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id_pedido: 'id_pedido',
    id_user: 'id_user',
    id_lista: 'id_lista',
    total: 'total',
    data_cadastrou: 'data_cadastrou'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const Pedido_itemScalarFieldEnum: {
    id_pedido_item: 'id_pedido_item',
    id_pedido: 'id_pedido',
    id_produto: 'id_produto',
    qtde: 'qtde',
    valor_unit: 'valor_unit',
    data_cadastrou: 'data_cadastrou'
  };

  export type Pedido_itemScalarFieldEnum = (typeof Pedido_itemScalarFieldEnum)[keyof typeof Pedido_itemScalarFieldEnum]


  export const Lista_produtoScalarFieldEnum: {
    id_lista_produto: 'id_lista_produto',
    id_produto: 'id_produto',
    id_lista: 'id_lista',
    id_empresa: 'id_empresa',
    qtde_para_venda: 'qtde_para_venda',
    qtde_disponivel: 'qtde_disponivel',
    data_cadastrou: 'data_cadastrou'
  };

  export type Lista_produtoScalarFieldEnum = (typeof Lista_produtoScalarFieldEnum)[keyof typeof Lista_produtoScalarFieldEnum]


  export const Campanha_tokenScalarFieldEnum: {
    id_campanha_token: 'id_campanha_token',
    id_campanha: 'id_campanha',
    token: 'token',
    utilizado: 'utilizado',
    gerado: 'gerado',
    data_cadastrou: 'data_cadastrou'
  };

  export type Campanha_tokenScalarFieldEnum = (typeof Campanha_tokenScalarFieldEnum)[keyof typeof Campanha_tokenScalarFieldEnum]


  export const UserempresaScalarFieldEnum: {
    id_user_empresa: 'id_user_empresa',
    id_empresa: 'id_empresa',
    id_user: 'id_user',
    data_cadastrou: 'data_cadastrou',
    role: 'role'
  };

  export type UserempresaScalarFieldEnum = (typeof UserempresaScalarFieldEnum)[keyof typeof UserempresaScalarFieldEnum]


  export const ListaScalarFieldEnum: {
    id_lista: 'id_lista',
    id_empresa: 'id_empresa',
    nome_lista: 'nome_lista',
    ativo: 'ativo',
    descricao: 'descricao',
    data_cadastrou: 'data_cadastrou',
    data_vigencia_inicio: 'data_vigencia_inicio',
    data_vigencia_fim: 'data_vigencia_fim',
    uid: 'uid'
  };

  export type ListaScalarFieldEnum = (typeof ListaScalarFieldEnum)[keyof typeof ListaScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id_categoria: 'id_categoria',
    id_empresa: 'id_empresa',
    nome_categoria: 'nome_categoria',
    ativo: 'ativo',
    data_cadastrou: 'data_cadastrou',
    data_update: 'data_update',
    icon: 'icon'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const ProdutoScalarFieldEnum: {
    id_produto: 'id_produto',
    id_empresa: 'id_empresa',
    id_categoria: 'id_categoria',
    nome_produto: 'nome_produto',
    valor: 'valor',
    ativo: 'ativo',
    data_cadastrou: 'data_cadastrou',
    descricao: 'descricao'
  };

  export type ProdutoScalarFieldEnum = (typeof ProdutoScalarFieldEnum)[keyof typeof ProdutoScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id_usuario: 'id_usuario',
    id_user: 'id_user',
    cpf: 'cpf',
    nome: 'nome',
    endereco: 'endereco',
    bairro: 'bairro',
    tipo: 'tipo',
    cidade: 'cidade',
    postalcode: 'postalcode',
    celular: 'celular',
    data_cadastrou: 'data_cadastrou',
    ativo: 'ativo',
    numero: 'numero',
    data_nascimento: 'data_nascimento',
    email: 'email',
    telefone: 'telefone'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const Campanha_msgScalarFieldEnum: {
    id_campanha_msg: 'id_campanha_msg',
    mensagem: 'mensagem',
    nome: 'nome',
    ativo: 'ativo',
    data_cadastrou: 'data_cadastrou',
    id_empresa: 'id_empresa',
    id_user: 'id_user'
  };

  export type Campanha_msgScalarFieldEnum = (typeof Campanha_msgScalarFieldEnum)[keyof typeof Campanha_msgScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    cpf: 'cpf',
    role: 'role',
    created_at: 'created_at',
    update_at: 'update_at',
    ativo: 'ativo',
    uid_user: 'uid_user'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ResgateScalarFieldEnum: {
    id_resgate: 'id_resgate',
    id_campanha: 'id_campanha',
    id_user: 'id_user',
    id_user_realizou: 'id_user_realizou',
    data_cadastrou: 'data_cadastrou',
    qtde_resgatado: 'qtde_resgatado'
  };

  export type ResgateScalarFieldEnum = (typeof ResgateScalarFieldEnum)[keyof typeof ResgateScalarFieldEnum]


  export const EmpresaScalarFieldEnum: {
    id_empresa: 'id_empresa',
    id_user: 'id_user',
    nome_empresa: 'nome_empresa',
    cnpj: 'cnpj',
    data_cadastrou: 'data_cadastrou',
    ativo: 'ativo',
    uid: 'uid',
    apikey: 'apikey'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const Campanha_formularioScalarFieldEnum: {
    id_campanha_formulario: 'id_campanha_formulario',
    token: 'token',
    nome: 'nome',
    email: 'email',
    cpf: 'cpf',
    celular: 'celular',
    data_cadastrou: 'data_cadastrou'
  };

  export type Campanha_formularioScalarFieldEnum = (typeof Campanha_formularioScalarFieldEnum)[keyof typeof Campanha_formularioScalarFieldEnum]


  export const CampanhaScalarFieldEnum: {
    id_campanha: 'id_campanha',
    id_empresa: 'id_empresa',
    envia_msg: 'envia_msg',
    recompensa: 'recompensa',
    nome_campanha: 'nome_campanha',
    data_inicio: 'data_inicio',
    data_fim: 'data_fim',
    ativo: 'ativo',
    qtde_servico: 'qtde_servico',
    descricao: 'descricao',
    id_user: 'id_user',
    gera_token: 'gera_token',
    nro_campanha_cliente: 'nro_campanha_cliente',
    qtde_token: 'qtde_token',
    qtde_pontos: 'qtde_pontos',
    id_campanha_msg: 'id_campanha_msg',
    mensagem_cliente: 'mensagem_cliente',
    uid: 'uid'
  };

  export type CampanhaScalarFieldEnum = (typeof CampanhaScalarFieldEnum)[keyof typeof CampanhaScalarFieldEnum]


  export const CarimboScalarFieldEnum: {
    id_carimbo: 'id_carimbo',
    id_user_carimbou: 'id_user_carimbou',
    id_user: 'id_user',
    id_campanha: 'id_campanha',
    data_carimbo: 'data_carimbo',
    qtde_carimbo: 'qtde_carimbo',
    id_resgate: 'id_resgate'
  };

  export type CarimboScalarFieldEnum = (typeof CarimboScalarFieldEnum)[keyof typeof CarimboScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    update_at: 'update_at'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    description: 'description',
    banner: 'banner',
    created_at: 'created_at',
    update_at: 'update_at',
    category_id: 'category_id'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    table: 'table',
    status: 'status',
    draft: 'draft',
    name: 'name',
    created_at: 'created_at',
    update_at: 'update_at'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    created_at: 'created_at',
    update_at: 'update_at',
    order_id: 'order_id',
    product_id: 'product_id'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type telefone_compWhereInput = {
    AND?: telefone_compWhereInput | telefone_compWhereInput[]
    OR?: telefone_compWhereInput[]
    NOT?: telefone_compWhereInput | telefone_compWhereInput[]
    id_telefone_comp?: IntFilter<"telefone_comp"> | number
    id_dados_fisica?: IntFilter<"telefone_comp"> | number
    ddd?: StringFilter<"telefone_comp"> | string
    telefone?: StringFilter<"telefone_comp"> | string
  }

  export type telefone_compOrderByWithRelationInput = {
    id_telefone_comp?: SortOrder
    id_dados_fisica?: SortOrder
    ddd?: SortOrder
    telefone?: SortOrder
  }

  export type telefone_compWhereUniqueInput = Prisma.AtLeast<{
    id_telefone_comp?: number
    AND?: telefone_compWhereInput | telefone_compWhereInput[]
    OR?: telefone_compWhereInput[]
    NOT?: telefone_compWhereInput | telefone_compWhereInput[]
    id_dados_fisica?: IntFilter<"telefone_comp"> | number
    ddd?: StringFilter<"telefone_comp"> | string
    telefone?: StringFilter<"telefone_comp"> | string
  }, "id_telefone_comp">

  export type telefone_compOrderByWithAggregationInput = {
    id_telefone_comp?: SortOrder
    id_dados_fisica?: SortOrder
    ddd?: SortOrder
    telefone?: SortOrder
    _count?: telefone_compCountOrderByAggregateInput
    _avg?: telefone_compAvgOrderByAggregateInput
    _max?: telefone_compMaxOrderByAggregateInput
    _min?: telefone_compMinOrderByAggregateInput
    _sum?: telefone_compSumOrderByAggregateInput
  }

  export type telefone_compScalarWhereWithAggregatesInput = {
    AND?: telefone_compScalarWhereWithAggregatesInput | telefone_compScalarWhereWithAggregatesInput[]
    OR?: telefone_compScalarWhereWithAggregatesInput[]
    NOT?: telefone_compScalarWhereWithAggregatesInput | telefone_compScalarWhereWithAggregatesInput[]
    id_telefone_comp?: IntWithAggregatesFilter<"telefone_comp"> | number
    id_dados_fisica?: IntWithAggregatesFilter<"telefone_comp"> | number
    ddd?: StringWithAggregatesFilter<"telefone_comp"> | string
    telefone?: StringWithAggregatesFilter<"telefone_comp"> | string
  }

  export type consulta_userWhereInput = {
    AND?: consulta_userWhereInput | consulta_userWhereInput[]
    OR?: consulta_userWhereInput[]
    NOT?: consulta_userWhereInput | consulta_userWhereInput[]
    id_consulta_user?: IntFilter<"consulta_user"> | number
    id_user?: IntFilter<"consulta_user"> | number
    data_cadastrou?: DateTimeNullableFilter<"consulta_user"> | Date | string | null
    id_dados_fisica?: IntFilter<"consulta_user"> | number
  }

  export type consulta_userOrderByWithRelationInput = {
    id_consulta_user?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_userWhereUniqueInput = Prisma.AtLeast<{
    id_consulta_user?: number
    AND?: consulta_userWhereInput | consulta_userWhereInput[]
    OR?: consulta_userWhereInput[]
    NOT?: consulta_userWhereInput | consulta_userWhereInput[]
    id_user?: IntFilter<"consulta_user"> | number
    data_cadastrou?: DateTimeNullableFilter<"consulta_user"> | Date | string | null
    id_dados_fisica?: IntFilter<"consulta_user"> | number
  }, "id_consulta_user">

  export type consulta_userOrderByWithAggregationInput = {
    id_consulta_user?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    id_dados_fisica?: SortOrder
    _count?: consulta_userCountOrderByAggregateInput
    _avg?: consulta_userAvgOrderByAggregateInput
    _max?: consulta_userMaxOrderByAggregateInput
    _min?: consulta_userMinOrderByAggregateInput
    _sum?: consulta_userSumOrderByAggregateInput
  }

  export type consulta_userScalarWhereWithAggregatesInput = {
    AND?: consulta_userScalarWhereWithAggregatesInput | consulta_userScalarWhereWithAggregatesInput[]
    OR?: consulta_userScalarWhereWithAggregatesInput[]
    NOT?: consulta_userScalarWhereWithAggregatesInput | consulta_userScalarWhereWithAggregatesInput[]
    id_consulta_user?: IntWithAggregatesFilter<"consulta_user"> | number
    id_user?: IntWithAggregatesFilter<"consulta_user"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"consulta_user"> | Date | string | null
    id_dados_fisica?: IntWithAggregatesFilter<"consulta_user"> | number
  }

  export type consulta_saldoWhereInput = {
    AND?: consulta_saldoWhereInput | consulta_saldoWhereInput[]
    OR?: consulta_saldoWhereInput[]
    NOT?: consulta_saldoWhereInput | consulta_saldoWhereInput[]
    id_consulta_sado?: IntFilter<"consulta_saldo"> | number
    id_user?: IntFilter<"consulta_saldo"> | number
    data_cadastrou?: DateTimeFilter<"consulta_saldo"> | Date | string
    saldo?: IntFilter<"consulta_saldo"> | number
    saldo_contratado?: IntFilter<"consulta_saldo"> | number
    data_atualizou?: DateTimeFilter<"consulta_saldo"> | Date | string
  }

  export type consulta_saldoOrderByWithRelationInput = {
    id_consulta_sado?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    saldo?: SortOrder
    saldo_contratado?: SortOrder
    data_atualizou?: SortOrder
  }

  export type consulta_saldoWhereUniqueInput = Prisma.AtLeast<{
    id_consulta_sado?: number
    AND?: consulta_saldoWhereInput | consulta_saldoWhereInput[]
    OR?: consulta_saldoWhereInput[]
    NOT?: consulta_saldoWhereInput | consulta_saldoWhereInput[]
    id_user?: IntFilter<"consulta_saldo"> | number
    data_cadastrou?: DateTimeFilter<"consulta_saldo"> | Date | string
    saldo?: IntFilter<"consulta_saldo"> | number
    saldo_contratado?: IntFilter<"consulta_saldo"> | number
    data_atualizou?: DateTimeFilter<"consulta_saldo"> | Date | string
  }, "id_consulta_sado">

  export type consulta_saldoOrderByWithAggregationInput = {
    id_consulta_sado?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    saldo?: SortOrder
    saldo_contratado?: SortOrder
    data_atualizou?: SortOrder
    _count?: consulta_saldoCountOrderByAggregateInput
    _avg?: consulta_saldoAvgOrderByAggregateInput
    _max?: consulta_saldoMaxOrderByAggregateInput
    _min?: consulta_saldoMinOrderByAggregateInput
    _sum?: consulta_saldoSumOrderByAggregateInput
  }

  export type consulta_saldoScalarWhereWithAggregatesInput = {
    AND?: consulta_saldoScalarWhereWithAggregatesInput | consulta_saldoScalarWhereWithAggregatesInput[]
    OR?: consulta_saldoScalarWhereWithAggregatesInput[]
    NOT?: consulta_saldoScalarWhereWithAggregatesInput | consulta_saldoScalarWhereWithAggregatesInput[]
    id_consulta_sado?: IntWithAggregatesFilter<"consulta_saldo"> | number
    id_user?: IntWithAggregatesFilter<"consulta_saldo"> | number
    data_cadastrou?: DateTimeWithAggregatesFilter<"consulta_saldo"> | Date | string
    saldo?: IntWithAggregatesFilter<"consulta_saldo"> | number
    saldo_contratado?: IntWithAggregatesFilter<"consulta_saldo"> | number
    data_atualizou?: DateTimeWithAggregatesFilter<"consulta_saldo"> | Date | string
  }

  export type consulta_insere_logWhereInput = {
    AND?: consulta_insere_logWhereInput | consulta_insere_logWhereInput[]
    OR?: consulta_insere_logWhereInput[]
    NOT?: consulta_insere_logWhereInput | consulta_insere_logWhereInput[]
    id_consulta_insere?: IntFilter<"consulta_insere_log"> | number
    id_user?: IntFilter<"consulta_insere_log"> | number
    data_cadastrou?: DateTimeNullableFilter<"consulta_insere_log"> | Date | string | null
    debito?: IntFilter<"consulta_insere_log"> | number
    fonte_propria?: IntFilter<"consulta_insere_log"> | number
    consulta?: StringFilter<"consulta_insere_log"> | string
    id_dados_fisica?: IntFilter<"consulta_insere_log"> | number
  }

  export type consulta_insere_logOrderByWithRelationInput = {
    id_consulta_insere?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    debito?: SortOrder
    fonte_propria?: SortOrder
    consulta?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_insere_logWhereUniqueInput = Prisma.AtLeast<{
    id_consulta_insere?: number
    AND?: consulta_insere_logWhereInput | consulta_insere_logWhereInput[]
    OR?: consulta_insere_logWhereInput[]
    NOT?: consulta_insere_logWhereInput | consulta_insere_logWhereInput[]
    id_user?: IntFilter<"consulta_insere_log"> | number
    data_cadastrou?: DateTimeNullableFilter<"consulta_insere_log"> | Date | string | null
    debito?: IntFilter<"consulta_insere_log"> | number
    fonte_propria?: IntFilter<"consulta_insere_log"> | number
    consulta?: StringFilter<"consulta_insere_log"> | string
    id_dados_fisica?: IntFilter<"consulta_insere_log"> | number
  }, "id_consulta_insere">

  export type consulta_insere_logOrderByWithAggregationInput = {
    id_consulta_insere?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    debito?: SortOrder
    fonte_propria?: SortOrder
    consulta?: SortOrder
    id_dados_fisica?: SortOrder
    _count?: consulta_insere_logCountOrderByAggregateInput
    _avg?: consulta_insere_logAvgOrderByAggregateInput
    _max?: consulta_insere_logMaxOrderByAggregateInput
    _min?: consulta_insere_logMinOrderByAggregateInput
    _sum?: consulta_insere_logSumOrderByAggregateInput
  }

  export type consulta_insere_logScalarWhereWithAggregatesInput = {
    AND?: consulta_insere_logScalarWhereWithAggregatesInput | consulta_insere_logScalarWhereWithAggregatesInput[]
    OR?: consulta_insere_logScalarWhereWithAggregatesInput[]
    NOT?: consulta_insere_logScalarWhereWithAggregatesInput | consulta_insere_logScalarWhereWithAggregatesInput[]
    id_consulta_insere?: IntWithAggregatesFilter<"consulta_insere_log"> | number
    id_user?: IntWithAggregatesFilter<"consulta_insere_log"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"consulta_insere_log"> | Date | string | null
    debito?: IntWithAggregatesFilter<"consulta_insere_log"> | number
    fonte_propria?: IntWithAggregatesFilter<"consulta_insere_log"> | number
    consulta?: StringWithAggregatesFilter<"consulta_insere_log"> | string
    id_dados_fisica?: IntWithAggregatesFilter<"consulta_insere_log"> | number
  }

  export type dados_fisicaWhereInput = {
    AND?: dados_fisicaWhereInput | dados_fisicaWhereInput[]
    OR?: dados_fisicaWhereInput[]
    NOT?: dados_fisicaWhereInput | dados_fisicaWhereInput[]
    id?: IntFilter<"dados_fisica"> | number
    nome?: StringFilter<"dados_fisica"> | string
    cpf?: StringFilter<"dados_fisica"> | string
    tipo_end?: StringNullableFilter<"dados_fisica"> | string | null
    rua?: StringNullableFilter<"dados_fisica"> | string | null
    numero?: StringNullableFilter<"dados_fisica"> | string | null
    cidade?: StringNullableFilter<"dados_fisica"> | string | null
    uf?: StringNullableFilter<"dados_fisica"> | string | null
    cep?: StringNullableFilter<"dados_fisica"> | string | null
    morto?: BoolFilter<"dados_fisica"> | boolean
    celular_ddd?: IntNullableFilter<"dados_fisica"> | number | null
    celular_number?: StringNullableFilter<"dados_fisica"> | string | null
    connect_whats?: DateTimeNullableFilter<"dados_fisica"> | Date | string | null
    rg?: StringNullableFilter<"dados_fisica"> | string | null
    bairro?: StringNullableFilter<"dados_fisica"> | string | null
    nome_mae?: StringNullableFilter<"dados_fisica"> | string | null
    data_aniversaio?: DateTimeNullableFilter<"dados_fisica"> | Date | string | null
  }

  export type dados_fisicaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    tipo_end?: SortOrderInput | SortOrder
    rua?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    morto?: SortOrder
    celular_ddd?: SortOrderInput | SortOrder
    celular_number?: SortOrderInput | SortOrder
    connect_whats?: SortOrderInput | SortOrder
    rg?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    nome_mae?: SortOrderInput | SortOrder
    data_aniversaio?: SortOrderInput | SortOrder
  }

  export type dados_fisicaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: dados_fisicaWhereInput | dados_fisicaWhereInput[]
    OR?: dados_fisicaWhereInput[]
    NOT?: dados_fisicaWhereInput | dados_fisicaWhereInput[]
    nome?: StringFilter<"dados_fisica"> | string
    cpf?: StringFilter<"dados_fisica"> | string
    tipo_end?: StringNullableFilter<"dados_fisica"> | string | null
    rua?: StringNullableFilter<"dados_fisica"> | string | null
    numero?: StringNullableFilter<"dados_fisica"> | string | null
    cidade?: StringNullableFilter<"dados_fisica"> | string | null
    uf?: StringNullableFilter<"dados_fisica"> | string | null
    cep?: StringNullableFilter<"dados_fisica"> | string | null
    morto?: BoolFilter<"dados_fisica"> | boolean
    celular_ddd?: IntNullableFilter<"dados_fisica"> | number | null
    celular_number?: StringNullableFilter<"dados_fisica"> | string | null
    connect_whats?: DateTimeNullableFilter<"dados_fisica"> | Date | string | null
    rg?: StringNullableFilter<"dados_fisica"> | string | null
    bairro?: StringNullableFilter<"dados_fisica"> | string | null
    nome_mae?: StringNullableFilter<"dados_fisica"> | string | null
    data_aniversaio?: DateTimeNullableFilter<"dados_fisica"> | Date | string | null
  }, "id">

  export type dados_fisicaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    tipo_end?: SortOrderInput | SortOrder
    rua?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    morto?: SortOrder
    celular_ddd?: SortOrderInput | SortOrder
    celular_number?: SortOrderInput | SortOrder
    connect_whats?: SortOrderInput | SortOrder
    rg?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    nome_mae?: SortOrderInput | SortOrder
    data_aniversaio?: SortOrderInput | SortOrder
    _count?: dados_fisicaCountOrderByAggregateInput
    _avg?: dados_fisicaAvgOrderByAggregateInput
    _max?: dados_fisicaMaxOrderByAggregateInput
    _min?: dados_fisicaMinOrderByAggregateInput
    _sum?: dados_fisicaSumOrderByAggregateInput
  }

  export type dados_fisicaScalarWhereWithAggregatesInput = {
    AND?: dados_fisicaScalarWhereWithAggregatesInput | dados_fisicaScalarWhereWithAggregatesInput[]
    OR?: dados_fisicaScalarWhereWithAggregatesInput[]
    NOT?: dados_fisicaScalarWhereWithAggregatesInput | dados_fisicaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"dados_fisica"> | number
    nome?: StringWithAggregatesFilter<"dados_fisica"> | string
    cpf?: StringWithAggregatesFilter<"dados_fisica"> | string
    tipo_end?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    rua?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    numero?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    cidade?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    uf?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    cep?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    morto?: BoolWithAggregatesFilter<"dados_fisica"> | boolean
    celular_ddd?: IntNullableWithAggregatesFilter<"dados_fisica"> | number | null
    celular_number?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    connect_whats?: DateTimeNullableWithAggregatesFilter<"dados_fisica"> | Date | string | null
    rg?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    bairro?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    nome_mae?: StringNullableWithAggregatesFilter<"dados_fisica"> | string | null
    data_aniversaio?: DateTimeNullableWithAggregatesFilter<"dados_fisica"> | Date | string | null
  }

  export type crm_clienteWhereInput = {
    AND?: crm_clienteWhereInput | crm_clienteWhereInput[]
    OR?: crm_clienteWhereInput[]
    NOT?: crm_clienteWhereInput | crm_clienteWhereInput[]
    CODIGO_CLIENTE?: StringFilter<"crm_cliente"> | string
    CPF?: StringFilter<"crm_cliente"> | string
    DATA_VENDA?: DateTimeFilter<"crm_cliente"> | Date | string
    TICKET?: StringFilter<"crm_cliente"> | string
    CODIGO_FILIAL?: StringFilter<"crm_cliente"> | string
    VALOR_PAGO?: DecimalFilter<"crm_cliente"> | Decimal | DecimalJsLike | number | string
    VALOR_TIKET?: DecimalFilter<"crm_cliente"> | Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA?: DateTimeFilter<"crm_cliente"> | Date | string
    NOME_SOCIAL?: StringFilter<"crm_cliente"> | string
    CLIENTE_VAREJO?: StringFilter<"crm_cliente"> | string
    ANIVERSARIO?: DateTimeFilter<"crm_cliente"> | Date | string
    EMAIL?: StringFilter<"crm_cliente"> | string
    DDD_CELULAR?: StringFilter<"crm_cliente"> | string
    CELULAR?: StringFilter<"crm_cliente"> | string
    DATA_CADASTROU?: StringFilter<"crm_cliente"> | string
  }

  export type crm_clienteOrderByWithRelationInput = {
    CODIGO_CLIENTE?: SortOrder
    CPF?: SortOrder
    DATA_VENDA?: SortOrder
    TICKET?: SortOrder
    CODIGO_FILIAL?: SortOrder
    VALOR_PAGO?: SortOrder
    VALOR_TIKET?: SortOrder
    ULTIMA_COMPRA?: SortOrder
    NOME_SOCIAL?: SortOrder
    CLIENTE_VAREJO?: SortOrder
    ANIVERSARIO?: SortOrder
    EMAIL?: SortOrder
    DDD_CELULAR?: SortOrder
    CELULAR?: SortOrder
    DATA_CADASTROU?: SortOrder
  }

  export type crm_clienteWhereUniqueInput = Prisma.AtLeast<{
    CODIGO_CLIENTE?: string
    AND?: crm_clienteWhereInput | crm_clienteWhereInput[]
    OR?: crm_clienteWhereInput[]
    NOT?: crm_clienteWhereInput | crm_clienteWhereInput[]
    CPF?: StringFilter<"crm_cliente"> | string
    DATA_VENDA?: DateTimeFilter<"crm_cliente"> | Date | string
    TICKET?: StringFilter<"crm_cliente"> | string
    CODIGO_FILIAL?: StringFilter<"crm_cliente"> | string
    VALOR_PAGO?: DecimalFilter<"crm_cliente"> | Decimal | DecimalJsLike | number | string
    VALOR_TIKET?: DecimalFilter<"crm_cliente"> | Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA?: DateTimeFilter<"crm_cliente"> | Date | string
    NOME_SOCIAL?: StringFilter<"crm_cliente"> | string
    CLIENTE_VAREJO?: StringFilter<"crm_cliente"> | string
    ANIVERSARIO?: DateTimeFilter<"crm_cliente"> | Date | string
    EMAIL?: StringFilter<"crm_cliente"> | string
    DDD_CELULAR?: StringFilter<"crm_cliente"> | string
    CELULAR?: StringFilter<"crm_cliente"> | string
    DATA_CADASTROU?: StringFilter<"crm_cliente"> | string
  }, "CODIGO_CLIENTE">

  export type crm_clienteOrderByWithAggregationInput = {
    CODIGO_CLIENTE?: SortOrder
    CPF?: SortOrder
    DATA_VENDA?: SortOrder
    TICKET?: SortOrder
    CODIGO_FILIAL?: SortOrder
    VALOR_PAGO?: SortOrder
    VALOR_TIKET?: SortOrder
    ULTIMA_COMPRA?: SortOrder
    NOME_SOCIAL?: SortOrder
    CLIENTE_VAREJO?: SortOrder
    ANIVERSARIO?: SortOrder
    EMAIL?: SortOrder
    DDD_CELULAR?: SortOrder
    CELULAR?: SortOrder
    DATA_CADASTROU?: SortOrder
    _count?: crm_clienteCountOrderByAggregateInput
    _avg?: crm_clienteAvgOrderByAggregateInput
    _max?: crm_clienteMaxOrderByAggregateInput
    _min?: crm_clienteMinOrderByAggregateInput
    _sum?: crm_clienteSumOrderByAggregateInput
  }

  export type crm_clienteScalarWhereWithAggregatesInput = {
    AND?: crm_clienteScalarWhereWithAggregatesInput | crm_clienteScalarWhereWithAggregatesInput[]
    OR?: crm_clienteScalarWhereWithAggregatesInput[]
    NOT?: crm_clienteScalarWhereWithAggregatesInput | crm_clienteScalarWhereWithAggregatesInput[]
    CODIGO_CLIENTE?: StringWithAggregatesFilter<"crm_cliente"> | string
    CPF?: StringWithAggregatesFilter<"crm_cliente"> | string
    DATA_VENDA?: DateTimeWithAggregatesFilter<"crm_cliente"> | Date | string
    TICKET?: StringWithAggregatesFilter<"crm_cliente"> | string
    CODIGO_FILIAL?: StringWithAggregatesFilter<"crm_cliente"> | string
    VALOR_PAGO?: DecimalWithAggregatesFilter<"crm_cliente"> | Decimal | DecimalJsLike | number | string
    VALOR_TIKET?: DecimalWithAggregatesFilter<"crm_cliente"> | Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA?: DateTimeWithAggregatesFilter<"crm_cliente"> | Date | string
    NOME_SOCIAL?: StringWithAggregatesFilter<"crm_cliente"> | string
    CLIENTE_VAREJO?: StringWithAggregatesFilter<"crm_cliente"> | string
    ANIVERSARIO?: DateTimeWithAggregatesFilter<"crm_cliente"> | Date | string
    EMAIL?: StringWithAggregatesFilter<"crm_cliente"> | string
    DDD_CELULAR?: StringWithAggregatesFilter<"crm_cliente"> | string
    CELULAR?: StringWithAggregatesFilter<"crm_cliente"> | string
    DATA_CADASTROU?: StringWithAggregatesFilter<"crm_cliente"> | string
  }

  export type status_pedidoWhereInput = {
    AND?: status_pedidoWhereInput | status_pedidoWhereInput[]
    OR?: status_pedidoWhereInput[]
    NOT?: status_pedidoWhereInput | status_pedidoWhereInput[]
    id_status_pedido?: IntFilter<"status_pedido"> | number
    nome_status?: StringFilter<"status_pedido"> | string
    id_empresa?: IntFilter<"status_pedido"> | number
    ativo?: IntFilter<"status_pedido"> | number
    data_cadastrou?: DateTimeNullableFilter<"status_pedido"> | Date | string | null
  }

  export type status_pedidoOrderByWithRelationInput = {
    id_status_pedido?: SortOrder
    nome_status?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
  }

  export type status_pedidoWhereUniqueInput = Prisma.AtLeast<{
    id_status_pedido?: number
    AND?: status_pedidoWhereInput | status_pedidoWhereInput[]
    OR?: status_pedidoWhereInput[]
    NOT?: status_pedidoWhereInput | status_pedidoWhereInput[]
    nome_status?: StringFilter<"status_pedido"> | string
    id_empresa?: IntFilter<"status_pedido"> | number
    ativo?: IntFilter<"status_pedido"> | number
    data_cadastrou?: DateTimeNullableFilter<"status_pedido"> | Date | string | null
  }, "id_status_pedido">

  export type status_pedidoOrderByWithAggregationInput = {
    id_status_pedido?: SortOrder
    nome_status?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    _count?: status_pedidoCountOrderByAggregateInput
    _avg?: status_pedidoAvgOrderByAggregateInput
    _max?: status_pedidoMaxOrderByAggregateInput
    _min?: status_pedidoMinOrderByAggregateInput
    _sum?: status_pedidoSumOrderByAggregateInput
  }

  export type status_pedidoScalarWhereWithAggregatesInput = {
    AND?: status_pedidoScalarWhereWithAggregatesInput | status_pedidoScalarWhereWithAggregatesInput[]
    OR?: status_pedidoScalarWhereWithAggregatesInput[]
    NOT?: status_pedidoScalarWhereWithAggregatesInput | status_pedidoScalarWhereWithAggregatesInput[]
    id_status_pedido?: IntWithAggregatesFilter<"status_pedido"> | number
    nome_status?: StringWithAggregatesFilter<"status_pedido"> | string
    id_empresa?: IntWithAggregatesFilter<"status_pedido"> | number
    ativo?: IntWithAggregatesFilter<"status_pedido"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"status_pedido"> | Date | string | null
  }

  export type pedidoWhereInput = {
    AND?: pedidoWhereInput | pedidoWhereInput[]
    OR?: pedidoWhereInput[]
    NOT?: pedidoWhereInput | pedidoWhereInput[]
    id_pedido?: IntFilter<"pedido"> | number
    id_user?: IntFilter<"pedido"> | number
    id_lista?: IntFilter<"pedido"> | number
    total?: FloatFilter<"pedido"> | number
    data_cadastrou?: DateTimeNullableFilter<"pedido"> | Date | string | null
  }

  export type pedidoOrderByWithRelationInput = {
    id_pedido?: SortOrder
    id_user?: SortOrder
    id_lista?: SortOrder
    total?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
  }

  export type pedidoWhereUniqueInput = Prisma.AtLeast<{
    id_pedido?: number
    AND?: pedidoWhereInput | pedidoWhereInput[]
    OR?: pedidoWhereInput[]
    NOT?: pedidoWhereInput | pedidoWhereInput[]
    id_user?: IntFilter<"pedido"> | number
    id_lista?: IntFilter<"pedido"> | number
    total?: FloatFilter<"pedido"> | number
    data_cadastrou?: DateTimeNullableFilter<"pedido"> | Date | string | null
  }, "id_pedido">

  export type pedidoOrderByWithAggregationInput = {
    id_pedido?: SortOrder
    id_user?: SortOrder
    id_lista?: SortOrder
    total?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    _count?: pedidoCountOrderByAggregateInput
    _avg?: pedidoAvgOrderByAggregateInput
    _max?: pedidoMaxOrderByAggregateInput
    _min?: pedidoMinOrderByAggregateInput
    _sum?: pedidoSumOrderByAggregateInput
  }

  export type pedidoScalarWhereWithAggregatesInput = {
    AND?: pedidoScalarWhereWithAggregatesInput | pedidoScalarWhereWithAggregatesInput[]
    OR?: pedidoScalarWhereWithAggregatesInput[]
    NOT?: pedidoScalarWhereWithAggregatesInput | pedidoScalarWhereWithAggregatesInput[]
    id_pedido?: IntWithAggregatesFilter<"pedido"> | number
    id_user?: IntWithAggregatesFilter<"pedido"> | number
    id_lista?: IntWithAggregatesFilter<"pedido"> | number
    total?: FloatWithAggregatesFilter<"pedido"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"pedido"> | Date | string | null
  }

  export type pedido_itemWhereInput = {
    AND?: pedido_itemWhereInput | pedido_itemWhereInput[]
    OR?: pedido_itemWhereInput[]
    NOT?: pedido_itemWhereInput | pedido_itemWhereInput[]
    id_pedido_item?: IntFilter<"pedido_item"> | number
    id_pedido?: IntFilter<"pedido_item"> | number
    id_produto?: IntFilter<"pedido_item"> | number
    qtde?: IntFilter<"pedido_item"> | number
    valor_unit?: FloatFilter<"pedido_item"> | number
    data_cadastrou?: DateTimeNullableFilter<"pedido_item"> | Date | string | null
  }

  export type pedido_itemOrderByWithRelationInput = {
    id_pedido_item?: SortOrder
    id_pedido?: SortOrder
    id_produto?: SortOrder
    qtde?: SortOrder
    valor_unit?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
  }

  export type pedido_itemWhereUniqueInput = Prisma.AtLeast<{
    id_pedido_item?: number
    AND?: pedido_itemWhereInput | pedido_itemWhereInput[]
    OR?: pedido_itemWhereInput[]
    NOT?: pedido_itemWhereInput | pedido_itemWhereInput[]
    id_pedido?: IntFilter<"pedido_item"> | number
    id_produto?: IntFilter<"pedido_item"> | number
    qtde?: IntFilter<"pedido_item"> | number
    valor_unit?: FloatFilter<"pedido_item"> | number
    data_cadastrou?: DateTimeNullableFilter<"pedido_item"> | Date | string | null
  }, "id_pedido_item">

  export type pedido_itemOrderByWithAggregationInput = {
    id_pedido_item?: SortOrder
    id_pedido?: SortOrder
    id_produto?: SortOrder
    qtde?: SortOrder
    valor_unit?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    _count?: pedido_itemCountOrderByAggregateInput
    _avg?: pedido_itemAvgOrderByAggregateInput
    _max?: pedido_itemMaxOrderByAggregateInput
    _min?: pedido_itemMinOrderByAggregateInput
    _sum?: pedido_itemSumOrderByAggregateInput
  }

  export type pedido_itemScalarWhereWithAggregatesInput = {
    AND?: pedido_itemScalarWhereWithAggregatesInput | pedido_itemScalarWhereWithAggregatesInput[]
    OR?: pedido_itemScalarWhereWithAggregatesInput[]
    NOT?: pedido_itemScalarWhereWithAggregatesInput | pedido_itemScalarWhereWithAggregatesInput[]
    id_pedido_item?: IntWithAggregatesFilter<"pedido_item"> | number
    id_pedido?: IntWithAggregatesFilter<"pedido_item"> | number
    id_produto?: IntWithAggregatesFilter<"pedido_item"> | number
    qtde?: IntWithAggregatesFilter<"pedido_item"> | number
    valor_unit?: FloatWithAggregatesFilter<"pedido_item"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"pedido_item"> | Date | string | null
  }

  export type lista_produtoWhereInput = {
    AND?: lista_produtoWhereInput | lista_produtoWhereInput[]
    OR?: lista_produtoWhereInput[]
    NOT?: lista_produtoWhereInput | lista_produtoWhereInput[]
    id_lista_produto?: IntFilter<"lista_produto"> | number
    id_produto?: IntFilter<"lista_produto"> | number
    id_lista?: IntFilter<"lista_produto"> | number
    id_empresa?: IntFilter<"lista_produto"> | number
    qtde_para_venda?: IntFilter<"lista_produto"> | number
    qtde_disponivel?: IntFilter<"lista_produto"> | number
    data_cadastrou?: DateTimeNullableFilter<"lista_produto"> | Date | string | null
  }

  export type lista_produtoOrderByWithRelationInput = {
    id_lista_produto?: SortOrder
    id_produto?: SortOrder
    id_lista?: SortOrder
    id_empresa?: SortOrder
    qtde_para_venda?: SortOrder
    qtde_disponivel?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
  }

  export type lista_produtoWhereUniqueInput = Prisma.AtLeast<{
    id_lista_produto?: number
    AND?: lista_produtoWhereInput | lista_produtoWhereInput[]
    OR?: lista_produtoWhereInput[]
    NOT?: lista_produtoWhereInput | lista_produtoWhereInput[]
    id_produto?: IntFilter<"lista_produto"> | number
    id_lista?: IntFilter<"lista_produto"> | number
    id_empresa?: IntFilter<"lista_produto"> | number
    qtde_para_venda?: IntFilter<"lista_produto"> | number
    qtde_disponivel?: IntFilter<"lista_produto"> | number
    data_cadastrou?: DateTimeNullableFilter<"lista_produto"> | Date | string | null
  }, "id_lista_produto">

  export type lista_produtoOrderByWithAggregationInput = {
    id_lista_produto?: SortOrder
    id_produto?: SortOrder
    id_lista?: SortOrder
    id_empresa?: SortOrder
    qtde_para_venda?: SortOrder
    qtde_disponivel?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    _count?: lista_produtoCountOrderByAggregateInput
    _avg?: lista_produtoAvgOrderByAggregateInput
    _max?: lista_produtoMaxOrderByAggregateInput
    _min?: lista_produtoMinOrderByAggregateInput
    _sum?: lista_produtoSumOrderByAggregateInput
  }

  export type lista_produtoScalarWhereWithAggregatesInput = {
    AND?: lista_produtoScalarWhereWithAggregatesInput | lista_produtoScalarWhereWithAggregatesInput[]
    OR?: lista_produtoScalarWhereWithAggregatesInput[]
    NOT?: lista_produtoScalarWhereWithAggregatesInput | lista_produtoScalarWhereWithAggregatesInput[]
    id_lista_produto?: IntWithAggregatesFilter<"lista_produto"> | number
    id_produto?: IntWithAggregatesFilter<"lista_produto"> | number
    id_lista?: IntWithAggregatesFilter<"lista_produto"> | number
    id_empresa?: IntWithAggregatesFilter<"lista_produto"> | number
    qtde_para_venda?: IntWithAggregatesFilter<"lista_produto"> | number
    qtde_disponivel?: IntWithAggregatesFilter<"lista_produto"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"lista_produto"> | Date | string | null
  }

  export type campanha_tokenWhereInput = {
    AND?: campanha_tokenWhereInput | campanha_tokenWhereInput[]
    OR?: campanha_tokenWhereInput[]
    NOT?: campanha_tokenWhereInput | campanha_tokenWhereInput[]
    id_campanha_token?: IntFilter<"campanha_token"> | number
    id_campanha?: IntFilter<"campanha_token"> | number
    token?: StringFilter<"campanha_token"> | string
    utilizado?: IntFilter<"campanha_token"> | number
    gerado?: IntFilter<"campanha_token"> | number
    data_cadastrou?: DateTimeNullableFilter<"campanha_token"> | Date | string | null
  }

  export type campanha_tokenOrderByWithRelationInput = {
    id_campanha_token?: SortOrder
    id_campanha?: SortOrder
    token?: SortOrder
    utilizado?: SortOrder
    gerado?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
  }

  export type campanha_tokenWhereUniqueInput = Prisma.AtLeast<{
    id_campanha_token?: number
    AND?: campanha_tokenWhereInput | campanha_tokenWhereInput[]
    OR?: campanha_tokenWhereInput[]
    NOT?: campanha_tokenWhereInput | campanha_tokenWhereInput[]
    id_campanha?: IntFilter<"campanha_token"> | number
    token?: StringFilter<"campanha_token"> | string
    utilizado?: IntFilter<"campanha_token"> | number
    gerado?: IntFilter<"campanha_token"> | number
    data_cadastrou?: DateTimeNullableFilter<"campanha_token"> | Date | string | null
  }, "id_campanha_token">

  export type campanha_tokenOrderByWithAggregationInput = {
    id_campanha_token?: SortOrder
    id_campanha?: SortOrder
    token?: SortOrder
    utilizado?: SortOrder
    gerado?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    _count?: campanha_tokenCountOrderByAggregateInput
    _avg?: campanha_tokenAvgOrderByAggregateInput
    _max?: campanha_tokenMaxOrderByAggregateInput
    _min?: campanha_tokenMinOrderByAggregateInput
    _sum?: campanha_tokenSumOrderByAggregateInput
  }

  export type campanha_tokenScalarWhereWithAggregatesInput = {
    AND?: campanha_tokenScalarWhereWithAggregatesInput | campanha_tokenScalarWhereWithAggregatesInput[]
    OR?: campanha_tokenScalarWhereWithAggregatesInput[]
    NOT?: campanha_tokenScalarWhereWithAggregatesInput | campanha_tokenScalarWhereWithAggregatesInput[]
    id_campanha_token?: IntWithAggregatesFilter<"campanha_token"> | number
    id_campanha?: IntWithAggregatesFilter<"campanha_token"> | number
    token?: StringWithAggregatesFilter<"campanha_token"> | string
    utilizado?: IntWithAggregatesFilter<"campanha_token"> | number
    gerado?: IntWithAggregatesFilter<"campanha_token"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"campanha_token"> | Date | string | null
  }

  export type userempresaWhereInput = {
    AND?: userempresaWhereInput | userempresaWhereInput[]
    OR?: userempresaWhereInput[]
    NOT?: userempresaWhereInput | userempresaWhereInput[]
    id_user_empresa?: IntFilter<"userempresa"> | number
    id_empresa?: IntFilter<"userempresa"> | number
    id_user?: IntFilter<"userempresa"> | number
    data_cadastrou?: DateTimeNullableFilter<"userempresa"> | Date | string | null
    role?: IntNullableFilter<"userempresa"> | number | null
  }

  export type userempresaOrderByWithRelationInput = {
    id_user_empresa?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
  }

  export type userempresaWhereUniqueInput = Prisma.AtLeast<{
    id_user_empresa?: number
    AND?: userempresaWhereInput | userempresaWhereInput[]
    OR?: userempresaWhereInput[]
    NOT?: userempresaWhereInput | userempresaWhereInput[]
    id_empresa?: IntFilter<"userempresa"> | number
    id_user?: IntFilter<"userempresa"> | number
    data_cadastrou?: DateTimeNullableFilter<"userempresa"> | Date | string | null
    role?: IntNullableFilter<"userempresa"> | number | null
  }, "id_user_empresa">

  export type userempresaOrderByWithAggregationInput = {
    id_user_empresa?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    _count?: userempresaCountOrderByAggregateInput
    _avg?: userempresaAvgOrderByAggregateInput
    _max?: userempresaMaxOrderByAggregateInput
    _min?: userempresaMinOrderByAggregateInput
    _sum?: userempresaSumOrderByAggregateInput
  }

  export type userempresaScalarWhereWithAggregatesInput = {
    AND?: userempresaScalarWhereWithAggregatesInput | userempresaScalarWhereWithAggregatesInput[]
    OR?: userempresaScalarWhereWithAggregatesInput[]
    NOT?: userempresaScalarWhereWithAggregatesInput | userempresaScalarWhereWithAggregatesInput[]
    id_user_empresa?: IntWithAggregatesFilter<"userempresa"> | number
    id_empresa?: IntWithAggregatesFilter<"userempresa"> | number
    id_user?: IntWithAggregatesFilter<"userempresa"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"userempresa"> | Date | string | null
    role?: IntNullableWithAggregatesFilter<"userempresa"> | number | null
  }

  export type listaWhereInput = {
    AND?: listaWhereInput | listaWhereInput[]
    OR?: listaWhereInput[]
    NOT?: listaWhereInput | listaWhereInput[]
    id_lista?: IntFilter<"lista"> | number
    id_empresa?: IntFilter<"lista"> | number
    nome_lista?: StringFilter<"lista"> | string
    ativo?: IntNullableFilter<"lista"> | number | null
    descricao?: StringFilter<"lista"> | string
    data_cadastrou?: DateTimeNullableFilter<"lista"> | Date | string | null
    data_vigencia_inicio?: DateTimeNullableFilter<"lista"> | Date | string | null
    data_vigencia_fim?: DateTimeNullableFilter<"lista"> | Date | string | null
    uid?: StringNullableFilter<"lista"> | string | null
  }

  export type listaOrderByWithRelationInput = {
    id_lista?: SortOrder
    id_empresa?: SortOrder
    nome_lista?: SortOrder
    ativo?: SortOrderInput | SortOrder
    descricao?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    data_vigencia_inicio?: SortOrderInput | SortOrder
    data_vigencia_fim?: SortOrderInput | SortOrder
    uid?: SortOrderInput | SortOrder
  }

  export type listaWhereUniqueInput = Prisma.AtLeast<{
    id_lista?: number
    AND?: listaWhereInput | listaWhereInput[]
    OR?: listaWhereInput[]
    NOT?: listaWhereInput | listaWhereInput[]
    id_empresa?: IntFilter<"lista"> | number
    nome_lista?: StringFilter<"lista"> | string
    ativo?: IntNullableFilter<"lista"> | number | null
    descricao?: StringFilter<"lista"> | string
    data_cadastrou?: DateTimeNullableFilter<"lista"> | Date | string | null
    data_vigencia_inicio?: DateTimeNullableFilter<"lista"> | Date | string | null
    data_vigencia_fim?: DateTimeNullableFilter<"lista"> | Date | string | null
    uid?: StringNullableFilter<"lista"> | string | null
  }, "id_lista">

  export type listaOrderByWithAggregationInput = {
    id_lista?: SortOrder
    id_empresa?: SortOrder
    nome_lista?: SortOrder
    ativo?: SortOrderInput | SortOrder
    descricao?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    data_vigencia_inicio?: SortOrderInput | SortOrder
    data_vigencia_fim?: SortOrderInput | SortOrder
    uid?: SortOrderInput | SortOrder
    _count?: listaCountOrderByAggregateInput
    _avg?: listaAvgOrderByAggregateInput
    _max?: listaMaxOrderByAggregateInput
    _min?: listaMinOrderByAggregateInput
    _sum?: listaSumOrderByAggregateInput
  }

  export type listaScalarWhereWithAggregatesInput = {
    AND?: listaScalarWhereWithAggregatesInput | listaScalarWhereWithAggregatesInput[]
    OR?: listaScalarWhereWithAggregatesInput[]
    NOT?: listaScalarWhereWithAggregatesInput | listaScalarWhereWithAggregatesInput[]
    id_lista?: IntWithAggregatesFilter<"lista"> | number
    id_empresa?: IntWithAggregatesFilter<"lista"> | number
    nome_lista?: StringWithAggregatesFilter<"lista"> | string
    ativo?: IntNullableWithAggregatesFilter<"lista"> | number | null
    descricao?: StringWithAggregatesFilter<"lista"> | string
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"lista"> | Date | string | null
    data_vigencia_inicio?: DateTimeNullableWithAggregatesFilter<"lista"> | Date | string | null
    data_vigencia_fim?: DateTimeNullableWithAggregatesFilter<"lista"> | Date | string | null
    uid?: StringNullableWithAggregatesFilter<"lista"> | string | null
  }

  export type categoriaWhereInput = {
    AND?: categoriaWhereInput | categoriaWhereInput[]
    OR?: categoriaWhereInput[]
    NOT?: categoriaWhereInput | categoriaWhereInput[]
    id_categoria?: IntFilter<"categoria"> | number
    id_empresa?: IntFilter<"categoria"> | number
    nome_categoria?: StringFilter<"categoria"> | string
    ativo?: IntFilter<"categoria"> | number
    data_cadastrou?: DateTimeNullableFilter<"categoria"> | Date | string | null
    data_update?: DateTimeNullableFilter<"categoria"> | Date | string | null
    icon?: StringNullableFilter<"categoria"> | string | null
    produtos?: ProdutoListRelationFilter
  }

  export type categoriaOrderByWithRelationInput = {
    id_categoria?: SortOrder
    id_empresa?: SortOrder
    nome_categoria?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    data_update?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    produtos?: produtoOrderByRelationAggregateInput
  }

  export type categoriaWhereUniqueInput = Prisma.AtLeast<{
    id_categoria?: number
    AND?: categoriaWhereInput | categoriaWhereInput[]
    OR?: categoriaWhereInput[]
    NOT?: categoriaWhereInput | categoriaWhereInput[]
    id_empresa?: IntFilter<"categoria"> | number
    nome_categoria?: StringFilter<"categoria"> | string
    ativo?: IntFilter<"categoria"> | number
    data_cadastrou?: DateTimeNullableFilter<"categoria"> | Date | string | null
    data_update?: DateTimeNullableFilter<"categoria"> | Date | string | null
    icon?: StringNullableFilter<"categoria"> | string | null
    produtos?: ProdutoListRelationFilter
  }, "id_categoria">

  export type categoriaOrderByWithAggregationInput = {
    id_categoria?: SortOrder
    id_empresa?: SortOrder
    nome_categoria?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    data_update?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    _count?: categoriaCountOrderByAggregateInput
    _avg?: categoriaAvgOrderByAggregateInput
    _max?: categoriaMaxOrderByAggregateInput
    _min?: categoriaMinOrderByAggregateInput
    _sum?: categoriaSumOrderByAggregateInput
  }

  export type categoriaScalarWhereWithAggregatesInput = {
    AND?: categoriaScalarWhereWithAggregatesInput | categoriaScalarWhereWithAggregatesInput[]
    OR?: categoriaScalarWhereWithAggregatesInput[]
    NOT?: categoriaScalarWhereWithAggregatesInput | categoriaScalarWhereWithAggregatesInput[]
    id_categoria?: IntWithAggregatesFilter<"categoria"> | number
    id_empresa?: IntWithAggregatesFilter<"categoria"> | number
    nome_categoria?: StringWithAggregatesFilter<"categoria"> | string
    ativo?: IntWithAggregatesFilter<"categoria"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"categoria"> | Date | string | null
    data_update?: DateTimeNullableWithAggregatesFilter<"categoria"> | Date | string | null
    icon?: StringNullableWithAggregatesFilter<"categoria"> | string | null
  }

  export type produtoWhereInput = {
    AND?: produtoWhereInput | produtoWhereInput[]
    OR?: produtoWhereInput[]
    NOT?: produtoWhereInput | produtoWhereInput[]
    id_produto?: IntFilter<"produto"> | number
    id_empresa?: IntFilter<"produto"> | number
    id_categoria?: IntFilter<"produto"> | number
    nome_produto?: StringFilter<"produto"> | string
    valor?: FloatFilter<"produto"> | number
    ativo?: IntFilter<"produto"> | number
    data_cadastrou?: DateTimeNullableFilter<"produto"> | Date | string | null
    descricao?: StringFilter<"produto"> | string
    categoria?: XOR<CategoriaScalarRelationFilter, categoriaWhereInput>
  }

  export type produtoOrderByWithRelationInput = {
    id_produto?: SortOrder
    id_empresa?: SortOrder
    id_categoria?: SortOrder
    nome_produto?: SortOrder
    valor?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    descricao?: SortOrder
    categoria?: categoriaOrderByWithRelationInput
  }

  export type produtoWhereUniqueInput = Prisma.AtLeast<{
    id_produto?: number
    AND?: produtoWhereInput | produtoWhereInput[]
    OR?: produtoWhereInput[]
    NOT?: produtoWhereInput | produtoWhereInput[]
    id_empresa?: IntFilter<"produto"> | number
    id_categoria?: IntFilter<"produto"> | number
    nome_produto?: StringFilter<"produto"> | string
    valor?: FloatFilter<"produto"> | number
    ativo?: IntFilter<"produto"> | number
    data_cadastrou?: DateTimeNullableFilter<"produto"> | Date | string | null
    descricao?: StringFilter<"produto"> | string
    categoria?: XOR<CategoriaScalarRelationFilter, categoriaWhereInput>
  }, "id_produto">

  export type produtoOrderByWithAggregationInput = {
    id_produto?: SortOrder
    id_empresa?: SortOrder
    id_categoria?: SortOrder
    nome_produto?: SortOrder
    valor?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    descricao?: SortOrder
    _count?: produtoCountOrderByAggregateInput
    _avg?: produtoAvgOrderByAggregateInput
    _max?: produtoMaxOrderByAggregateInput
    _min?: produtoMinOrderByAggregateInput
    _sum?: produtoSumOrderByAggregateInput
  }

  export type produtoScalarWhereWithAggregatesInput = {
    AND?: produtoScalarWhereWithAggregatesInput | produtoScalarWhereWithAggregatesInput[]
    OR?: produtoScalarWhereWithAggregatesInput[]
    NOT?: produtoScalarWhereWithAggregatesInput | produtoScalarWhereWithAggregatesInput[]
    id_produto?: IntWithAggregatesFilter<"produto"> | number
    id_empresa?: IntWithAggregatesFilter<"produto"> | number
    id_categoria?: IntWithAggregatesFilter<"produto"> | number
    nome_produto?: StringWithAggregatesFilter<"produto"> | string
    valor?: FloatWithAggregatesFilter<"produto"> | number
    ativo?: IntWithAggregatesFilter<"produto"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"produto"> | Date | string | null
    descricao?: StringWithAggregatesFilter<"produto"> | string
  }

  export type usuarioWhereInput = {
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    id_usuario?: IntFilter<"usuario"> | number
    id_user?: IntFilter<"usuario"> | number
    cpf?: StringFilter<"usuario"> | string
    nome?: StringFilter<"usuario"> | string
    endereco?: StringFilter<"usuario"> | string
    bairro?: StringFilter<"usuario"> | string
    tipo?: StringFilter<"usuario"> | string
    cidade?: StringFilter<"usuario"> | string
    postalcode?: StringFilter<"usuario"> | string
    celular?: StringFilter<"usuario"> | string
    data_cadastrou?: DateTimeNullableFilter<"usuario"> | Date | string | null
    ativo?: IntNullableFilter<"usuario"> | number | null
    numero?: StringFilter<"usuario"> | string
    data_nascimento?: DateTimeNullableFilter<"usuario"> | Date | string | null
    email?: StringNullableFilter<"usuario"> | string | null
    telefone?: StringNullableFilter<"usuario"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type usuarioOrderByWithRelationInput = {
    id_usuario?: SortOrder
    id_user?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    bairro?: SortOrder
    tipo?: SortOrder
    cidade?: SortOrder
    postalcode?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    numero?: SortOrder
    data_nascimento?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type usuarioWhereUniqueInput = Prisma.AtLeast<{
    id_usuario?: number
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    id_user?: IntFilter<"usuario"> | number
    cpf?: StringFilter<"usuario"> | string
    nome?: StringFilter<"usuario"> | string
    endereco?: StringFilter<"usuario"> | string
    bairro?: StringFilter<"usuario"> | string
    tipo?: StringFilter<"usuario"> | string
    cidade?: StringFilter<"usuario"> | string
    postalcode?: StringFilter<"usuario"> | string
    celular?: StringFilter<"usuario"> | string
    data_cadastrou?: DateTimeNullableFilter<"usuario"> | Date | string | null
    ativo?: IntNullableFilter<"usuario"> | number | null
    numero?: StringFilter<"usuario"> | string
    data_nascimento?: DateTimeNullableFilter<"usuario"> | Date | string | null
    email?: StringNullableFilter<"usuario"> | string | null
    telefone?: StringNullableFilter<"usuario"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id_usuario">

  export type usuarioOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    id_user?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    bairro?: SortOrder
    tipo?: SortOrder
    cidade?: SortOrder
    postalcode?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    numero?: SortOrder
    data_nascimento?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    OR?: usuarioScalarWhereWithAggregatesInput[]
    NOT?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"usuario"> | number
    id_user?: IntWithAggregatesFilter<"usuario"> | number
    cpf?: StringWithAggregatesFilter<"usuario"> | string
    nome?: StringWithAggregatesFilter<"usuario"> | string
    endereco?: StringWithAggregatesFilter<"usuario"> | string
    bairro?: StringWithAggregatesFilter<"usuario"> | string
    tipo?: StringWithAggregatesFilter<"usuario"> | string
    cidade?: StringWithAggregatesFilter<"usuario"> | string
    postalcode?: StringWithAggregatesFilter<"usuario"> | string
    celular?: StringWithAggregatesFilter<"usuario"> | string
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"usuario"> | Date | string | null
    ativo?: IntNullableWithAggregatesFilter<"usuario"> | number | null
    numero?: StringWithAggregatesFilter<"usuario"> | string
    data_nascimento?: DateTimeNullableWithAggregatesFilter<"usuario"> | Date | string | null
    email?: StringNullableWithAggregatesFilter<"usuario"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"usuario"> | string | null
  }

  export type Campanha_msgWhereInput = {
    AND?: Campanha_msgWhereInput | Campanha_msgWhereInput[]
    OR?: Campanha_msgWhereInput[]
    NOT?: Campanha_msgWhereInput | Campanha_msgWhereInput[]
    id_campanha_msg?: IntFilter<"Campanha_msg"> | number
    mensagem?: StringFilter<"Campanha_msg"> | string
    nome?: StringFilter<"Campanha_msg"> | string
    ativo?: IntNullableFilter<"Campanha_msg"> | number | null
    data_cadastrou?: DateTimeNullableFilter<"Campanha_msg"> | Date | string | null
    id_empresa?: IntFilter<"Campanha_msg"> | number
    id_user?: IntFilter<"Campanha_msg"> | number
  }

  export type Campanha_msgOrderByWithRelationInput = {
    id_campanha_msg?: SortOrder
    mensagem?: SortOrder
    nome?: SortOrder
    ativo?: SortOrderInput | SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
  }

  export type Campanha_msgWhereUniqueInput = Prisma.AtLeast<{
    id_campanha_msg?: number
    AND?: Campanha_msgWhereInput | Campanha_msgWhereInput[]
    OR?: Campanha_msgWhereInput[]
    NOT?: Campanha_msgWhereInput | Campanha_msgWhereInput[]
    mensagem?: StringFilter<"Campanha_msg"> | string
    nome?: StringFilter<"Campanha_msg"> | string
    ativo?: IntNullableFilter<"Campanha_msg"> | number | null
    data_cadastrou?: DateTimeNullableFilter<"Campanha_msg"> | Date | string | null
    id_empresa?: IntFilter<"Campanha_msg"> | number
    id_user?: IntFilter<"Campanha_msg"> | number
  }, "id_campanha_msg">

  export type Campanha_msgOrderByWithAggregationInput = {
    id_campanha_msg?: SortOrder
    mensagem?: SortOrder
    nome?: SortOrder
    ativo?: SortOrderInput | SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
    _count?: Campanha_msgCountOrderByAggregateInput
    _avg?: Campanha_msgAvgOrderByAggregateInput
    _max?: Campanha_msgMaxOrderByAggregateInput
    _min?: Campanha_msgMinOrderByAggregateInput
    _sum?: Campanha_msgSumOrderByAggregateInput
  }

  export type Campanha_msgScalarWhereWithAggregatesInput = {
    AND?: Campanha_msgScalarWhereWithAggregatesInput | Campanha_msgScalarWhereWithAggregatesInput[]
    OR?: Campanha_msgScalarWhereWithAggregatesInput[]
    NOT?: Campanha_msgScalarWhereWithAggregatesInput | Campanha_msgScalarWhereWithAggregatesInput[]
    id_campanha_msg?: IntWithAggregatesFilter<"Campanha_msg"> | number
    mensagem?: StringWithAggregatesFilter<"Campanha_msg"> | string
    nome?: StringWithAggregatesFilter<"Campanha_msg"> | string
    ativo?: IntNullableWithAggregatesFilter<"Campanha_msg"> | number | null
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"Campanha_msg"> | Date | string | null
    id_empresa?: IntWithAggregatesFilter<"Campanha_msg"> | number
    id_user?: IntWithAggregatesFilter<"Campanha_msg"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    cpf?: StringNullableFilter<"User"> | string | null
    role?: IntNullableFilter<"User"> | number | null
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    update_at?: DateTimeNullableFilter<"User"> | Date | string | null
    ativo?: IntFilter<"User"> | number
    uid_user?: StringNullableFilter<"User"> | string | null
    usuario?: UsuarioListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    cpf?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    ativo?: SortOrder
    uid_user?: SortOrderInput | SortOrder
    usuario?: usuarioOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    cpf?: StringNullableFilter<"User"> | string | null
    role?: IntNullableFilter<"User"> | number | null
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    update_at?: DateTimeNullableFilter<"User"> | Date | string | null
    ativo?: IntFilter<"User"> | number
    uid_user?: StringNullableFilter<"User"> | string | null
    usuario?: UsuarioListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    cpf?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    ativo?: SortOrder
    uid_user?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    cpf?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: IntNullableWithAggregatesFilter<"User"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    update_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    ativo?: IntWithAggregatesFilter<"User"> | number
    uid_user?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ResgateWhereInput = {
    AND?: ResgateWhereInput | ResgateWhereInput[]
    OR?: ResgateWhereInput[]
    NOT?: ResgateWhereInput | ResgateWhereInput[]
    id_resgate?: IntFilter<"Resgate"> | number
    id_campanha?: IntFilter<"Resgate"> | number
    id_user?: IntFilter<"Resgate"> | number
    id_user_realizou?: IntFilter<"Resgate"> | number
    data_cadastrou?: DateTimeNullableFilter<"Resgate"> | Date | string | null
    qtde_resgatado?: IntFilter<"Resgate"> | number
  }

  export type ResgateOrderByWithRelationInput = {
    id_resgate?: SortOrder
    id_campanha?: SortOrder
    id_user?: SortOrder
    id_user_realizou?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    qtde_resgatado?: SortOrder
  }

  export type ResgateWhereUniqueInput = Prisma.AtLeast<{
    id_resgate?: number
    AND?: ResgateWhereInput | ResgateWhereInput[]
    OR?: ResgateWhereInput[]
    NOT?: ResgateWhereInput | ResgateWhereInput[]
    id_campanha?: IntFilter<"Resgate"> | number
    id_user?: IntFilter<"Resgate"> | number
    id_user_realizou?: IntFilter<"Resgate"> | number
    data_cadastrou?: DateTimeNullableFilter<"Resgate"> | Date | string | null
    qtde_resgatado?: IntFilter<"Resgate"> | number
  }, "id_resgate">

  export type ResgateOrderByWithAggregationInput = {
    id_resgate?: SortOrder
    id_campanha?: SortOrder
    id_user?: SortOrder
    id_user_realizou?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    qtde_resgatado?: SortOrder
    _count?: ResgateCountOrderByAggregateInput
    _avg?: ResgateAvgOrderByAggregateInput
    _max?: ResgateMaxOrderByAggregateInput
    _min?: ResgateMinOrderByAggregateInput
    _sum?: ResgateSumOrderByAggregateInput
  }

  export type ResgateScalarWhereWithAggregatesInput = {
    AND?: ResgateScalarWhereWithAggregatesInput | ResgateScalarWhereWithAggregatesInput[]
    OR?: ResgateScalarWhereWithAggregatesInput[]
    NOT?: ResgateScalarWhereWithAggregatesInput | ResgateScalarWhereWithAggregatesInput[]
    id_resgate?: IntWithAggregatesFilter<"Resgate"> | number
    id_campanha?: IntWithAggregatesFilter<"Resgate"> | number
    id_user?: IntWithAggregatesFilter<"Resgate"> | number
    id_user_realizou?: IntWithAggregatesFilter<"Resgate"> | number
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"Resgate"> | Date | string | null
    qtde_resgatado?: IntWithAggregatesFilter<"Resgate"> | number
  }

  export type empresaWhereInput = {
    AND?: empresaWhereInput | empresaWhereInput[]
    OR?: empresaWhereInput[]
    NOT?: empresaWhereInput | empresaWhereInput[]
    id_empresa?: IntFilter<"empresa"> | number
    id_user?: IntFilter<"empresa"> | number
    nome_empresa?: StringFilter<"empresa"> | string
    cnpj?: StringNullableFilter<"empresa"> | string | null
    data_cadastrou?: DateTimeNullableFilter<"empresa"> | Date | string | null
    ativo?: IntNullableFilter<"empresa"> | number | null
    uid?: UuidFilter<"empresa"> | string
    apikey?: StringNullableFilter<"empresa"> | string | null
  }

  export type empresaOrderByWithRelationInput = {
    id_empresa?: SortOrder
    id_user?: SortOrder
    nome_empresa?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    uid?: SortOrder
    apikey?: SortOrderInput | SortOrder
  }

  export type empresaWhereUniqueInput = Prisma.AtLeast<{
    id_empresa?: number
    AND?: empresaWhereInput | empresaWhereInput[]
    OR?: empresaWhereInput[]
    NOT?: empresaWhereInput | empresaWhereInput[]
    id_user?: IntFilter<"empresa"> | number
    nome_empresa?: StringFilter<"empresa"> | string
    cnpj?: StringNullableFilter<"empresa"> | string | null
    data_cadastrou?: DateTimeNullableFilter<"empresa"> | Date | string | null
    ativo?: IntNullableFilter<"empresa"> | number | null
    uid?: UuidFilter<"empresa"> | string
    apikey?: StringNullableFilter<"empresa"> | string | null
  }, "id_empresa">

  export type empresaOrderByWithAggregationInput = {
    id_empresa?: SortOrder
    id_user?: SortOrder
    nome_empresa?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    uid?: SortOrder
    apikey?: SortOrderInput | SortOrder
    _count?: empresaCountOrderByAggregateInput
    _avg?: empresaAvgOrderByAggregateInput
    _max?: empresaMaxOrderByAggregateInput
    _min?: empresaMinOrderByAggregateInput
    _sum?: empresaSumOrderByAggregateInput
  }

  export type empresaScalarWhereWithAggregatesInput = {
    AND?: empresaScalarWhereWithAggregatesInput | empresaScalarWhereWithAggregatesInput[]
    OR?: empresaScalarWhereWithAggregatesInput[]
    NOT?: empresaScalarWhereWithAggregatesInput | empresaScalarWhereWithAggregatesInput[]
    id_empresa?: IntWithAggregatesFilter<"empresa"> | number
    id_user?: IntWithAggregatesFilter<"empresa"> | number
    nome_empresa?: StringWithAggregatesFilter<"empresa"> | string
    cnpj?: StringNullableWithAggregatesFilter<"empresa"> | string | null
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"empresa"> | Date | string | null
    ativo?: IntNullableWithAggregatesFilter<"empresa"> | number | null
    uid?: UuidWithAggregatesFilter<"empresa"> | string
    apikey?: StringNullableWithAggregatesFilter<"empresa"> | string | null
  }

  export type campanha_formularioWhereInput = {
    AND?: campanha_formularioWhereInput | campanha_formularioWhereInput[]
    OR?: campanha_formularioWhereInput[]
    NOT?: campanha_formularioWhereInput | campanha_formularioWhereInput[]
    id_campanha_formulario?: IntFilter<"campanha_formulario"> | number
    token?: StringFilter<"campanha_formulario"> | string
    nome?: StringFilter<"campanha_formulario"> | string
    email?: StringFilter<"campanha_formulario"> | string
    cpf?: StringFilter<"campanha_formulario"> | string
    celular?: StringFilter<"campanha_formulario"> | string
    data_cadastrou?: DateTimeNullableFilter<"campanha_formulario"> | Date | string | null
  }

  export type campanha_formularioOrderByWithRelationInput = {
    id_campanha_formulario?: SortOrder
    token?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
  }

  export type campanha_formularioWhereUniqueInput = Prisma.AtLeast<{
    id_campanha_formulario?: number
    AND?: campanha_formularioWhereInput | campanha_formularioWhereInput[]
    OR?: campanha_formularioWhereInput[]
    NOT?: campanha_formularioWhereInput | campanha_formularioWhereInput[]
    token?: StringFilter<"campanha_formulario"> | string
    nome?: StringFilter<"campanha_formulario"> | string
    email?: StringFilter<"campanha_formulario"> | string
    cpf?: StringFilter<"campanha_formulario"> | string
    celular?: StringFilter<"campanha_formulario"> | string
    data_cadastrou?: DateTimeNullableFilter<"campanha_formulario"> | Date | string | null
  }, "id_campanha_formulario">

  export type campanha_formularioOrderByWithAggregationInput = {
    id_campanha_formulario?: SortOrder
    token?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrderInput | SortOrder
    _count?: campanha_formularioCountOrderByAggregateInput
    _avg?: campanha_formularioAvgOrderByAggregateInput
    _max?: campanha_formularioMaxOrderByAggregateInput
    _min?: campanha_formularioMinOrderByAggregateInput
    _sum?: campanha_formularioSumOrderByAggregateInput
  }

  export type campanha_formularioScalarWhereWithAggregatesInput = {
    AND?: campanha_formularioScalarWhereWithAggregatesInput | campanha_formularioScalarWhereWithAggregatesInput[]
    OR?: campanha_formularioScalarWhereWithAggregatesInput[]
    NOT?: campanha_formularioScalarWhereWithAggregatesInput | campanha_formularioScalarWhereWithAggregatesInput[]
    id_campanha_formulario?: IntWithAggregatesFilter<"campanha_formulario"> | number
    token?: StringWithAggregatesFilter<"campanha_formulario"> | string
    nome?: StringWithAggregatesFilter<"campanha_formulario"> | string
    email?: StringWithAggregatesFilter<"campanha_formulario"> | string
    cpf?: StringWithAggregatesFilter<"campanha_formulario"> | string
    celular?: StringWithAggregatesFilter<"campanha_formulario"> | string
    data_cadastrou?: DateTimeNullableWithAggregatesFilter<"campanha_formulario"> | Date | string | null
  }

  export type campanhaWhereInput = {
    AND?: campanhaWhereInput | campanhaWhereInput[]
    OR?: campanhaWhereInput[]
    NOT?: campanhaWhereInput | campanhaWhereInput[]
    id_campanha?: IntFilter<"campanha"> | number
    id_empresa?: IntFilter<"campanha"> | number
    envia_msg?: IntNullableFilter<"campanha"> | number | null
    recompensa?: StringNullableFilter<"campanha"> | string | null
    nome_campanha?: StringFilter<"campanha"> | string
    data_inicio?: DateTimeNullableFilter<"campanha"> | Date | string | null
    data_fim?: DateTimeNullableFilter<"campanha"> | Date | string | null
    ativo?: IntNullableFilter<"campanha"> | number | null
    qtde_servico?: IntFilter<"campanha"> | number
    descricao?: StringNullableFilter<"campanha"> | string | null
    id_user?: IntNullableFilter<"campanha"> | number | null
    gera_token?: IntNullableFilter<"campanha"> | number | null
    nro_campanha_cliente?: StringNullableFilter<"campanha"> | string | null
    qtde_token?: IntNullableFilter<"campanha"> | number | null
    qtde_pontos?: IntNullableFilter<"campanha"> | number | null
    id_campanha_msg?: IntNullableFilter<"campanha"> | number | null
    mensagem_cliente?: StringNullableFilter<"campanha"> | string | null
    uid?: UuidFilter<"campanha"> | string
  }

  export type campanhaOrderByWithRelationInput = {
    id_campanha?: SortOrder
    id_empresa?: SortOrder
    envia_msg?: SortOrderInput | SortOrder
    recompensa?: SortOrderInput | SortOrder
    nome_campanha?: SortOrder
    data_inicio?: SortOrderInput | SortOrder
    data_fim?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    qtde_servico?: SortOrder
    descricao?: SortOrderInput | SortOrder
    id_user?: SortOrderInput | SortOrder
    gera_token?: SortOrderInput | SortOrder
    nro_campanha_cliente?: SortOrderInput | SortOrder
    qtde_token?: SortOrderInput | SortOrder
    qtde_pontos?: SortOrderInput | SortOrder
    id_campanha_msg?: SortOrderInput | SortOrder
    mensagem_cliente?: SortOrderInput | SortOrder
    uid?: SortOrder
  }

  export type campanhaWhereUniqueInput = Prisma.AtLeast<{
    id_campanha?: number
    AND?: campanhaWhereInput | campanhaWhereInput[]
    OR?: campanhaWhereInput[]
    NOT?: campanhaWhereInput | campanhaWhereInput[]
    id_empresa?: IntFilter<"campanha"> | number
    envia_msg?: IntNullableFilter<"campanha"> | number | null
    recompensa?: StringNullableFilter<"campanha"> | string | null
    nome_campanha?: StringFilter<"campanha"> | string
    data_inicio?: DateTimeNullableFilter<"campanha"> | Date | string | null
    data_fim?: DateTimeNullableFilter<"campanha"> | Date | string | null
    ativo?: IntNullableFilter<"campanha"> | number | null
    qtde_servico?: IntFilter<"campanha"> | number
    descricao?: StringNullableFilter<"campanha"> | string | null
    id_user?: IntNullableFilter<"campanha"> | number | null
    gera_token?: IntNullableFilter<"campanha"> | number | null
    nro_campanha_cliente?: StringNullableFilter<"campanha"> | string | null
    qtde_token?: IntNullableFilter<"campanha"> | number | null
    qtde_pontos?: IntNullableFilter<"campanha"> | number | null
    id_campanha_msg?: IntNullableFilter<"campanha"> | number | null
    mensagem_cliente?: StringNullableFilter<"campanha"> | string | null
    uid?: UuidFilter<"campanha"> | string
  }, "id_campanha">

  export type campanhaOrderByWithAggregationInput = {
    id_campanha?: SortOrder
    id_empresa?: SortOrder
    envia_msg?: SortOrderInput | SortOrder
    recompensa?: SortOrderInput | SortOrder
    nome_campanha?: SortOrder
    data_inicio?: SortOrderInput | SortOrder
    data_fim?: SortOrderInput | SortOrder
    ativo?: SortOrderInput | SortOrder
    qtde_servico?: SortOrder
    descricao?: SortOrderInput | SortOrder
    id_user?: SortOrderInput | SortOrder
    gera_token?: SortOrderInput | SortOrder
    nro_campanha_cliente?: SortOrderInput | SortOrder
    qtde_token?: SortOrderInput | SortOrder
    qtde_pontos?: SortOrderInput | SortOrder
    id_campanha_msg?: SortOrderInput | SortOrder
    mensagem_cliente?: SortOrderInput | SortOrder
    uid?: SortOrder
    _count?: campanhaCountOrderByAggregateInput
    _avg?: campanhaAvgOrderByAggregateInput
    _max?: campanhaMaxOrderByAggregateInput
    _min?: campanhaMinOrderByAggregateInput
    _sum?: campanhaSumOrderByAggregateInput
  }

  export type campanhaScalarWhereWithAggregatesInput = {
    AND?: campanhaScalarWhereWithAggregatesInput | campanhaScalarWhereWithAggregatesInput[]
    OR?: campanhaScalarWhereWithAggregatesInput[]
    NOT?: campanhaScalarWhereWithAggregatesInput | campanhaScalarWhereWithAggregatesInput[]
    id_campanha?: IntWithAggregatesFilter<"campanha"> | number
    id_empresa?: IntWithAggregatesFilter<"campanha"> | number
    envia_msg?: IntNullableWithAggregatesFilter<"campanha"> | number | null
    recompensa?: StringNullableWithAggregatesFilter<"campanha"> | string | null
    nome_campanha?: StringWithAggregatesFilter<"campanha"> | string
    data_inicio?: DateTimeNullableWithAggregatesFilter<"campanha"> | Date | string | null
    data_fim?: DateTimeNullableWithAggregatesFilter<"campanha"> | Date | string | null
    ativo?: IntNullableWithAggregatesFilter<"campanha"> | number | null
    qtde_servico?: IntWithAggregatesFilter<"campanha"> | number
    descricao?: StringNullableWithAggregatesFilter<"campanha"> | string | null
    id_user?: IntNullableWithAggregatesFilter<"campanha"> | number | null
    gera_token?: IntNullableWithAggregatesFilter<"campanha"> | number | null
    nro_campanha_cliente?: StringNullableWithAggregatesFilter<"campanha"> | string | null
    qtde_token?: IntNullableWithAggregatesFilter<"campanha"> | number | null
    qtde_pontos?: IntNullableWithAggregatesFilter<"campanha"> | number | null
    id_campanha_msg?: IntNullableWithAggregatesFilter<"campanha"> | number | null
    mensagem_cliente?: StringNullableWithAggregatesFilter<"campanha"> | string | null
    uid?: UuidWithAggregatesFilter<"campanha"> | string
  }

  export type carimboWhereInput = {
    AND?: carimboWhereInput | carimboWhereInput[]
    OR?: carimboWhereInput[]
    NOT?: carimboWhereInput | carimboWhereInput[]
    id_carimbo?: IntFilter<"carimbo"> | number
    id_user_carimbou?: IntFilter<"carimbo"> | number
    id_user?: IntFilter<"carimbo"> | number
    id_campanha?: IntFilter<"carimbo"> | number
    data_carimbo?: DateTimeNullableFilter<"carimbo"> | Date | string | null
    qtde_carimbo?: IntNullableFilter<"carimbo"> | number | null
    id_resgate?: IntNullableFilter<"carimbo"> | number | null
  }

  export type carimboOrderByWithRelationInput = {
    id_carimbo?: SortOrder
    id_user_carimbou?: SortOrder
    id_user?: SortOrder
    id_campanha?: SortOrder
    data_carimbo?: SortOrderInput | SortOrder
    qtde_carimbo?: SortOrderInput | SortOrder
    id_resgate?: SortOrderInput | SortOrder
  }

  export type carimboWhereUniqueInput = Prisma.AtLeast<{
    id_carimbo?: number
    AND?: carimboWhereInput | carimboWhereInput[]
    OR?: carimboWhereInput[]
    NOT?: carimboWhereInput | carimboWhereInput[]
    id_user_carimbou?: IntFilter<"carimbo"> | number
    id_user?: IntFilter<"carimbo"> | number
    id_campanha?: IntFilter<"carimbo"> | number
    data_carimbo?: DateTimeNullableFilter<"carimbo"> | Date | string | null
    qtde_carimbo?: IntNullableFilter<"carimbo"> | number | null
    id_resgate?: IntNullableFilter<"carimbo"> | number | null
  }, "id_carimbo">

  export type carimboOrderByWithAggregationInput = {
    id_carimbo?: SortOrder
    id_user_carimbou?: SortOrder
    id_user?: SortOrder
    id_campanha?: SortOrder
    data_carimbo?: SortOrderInput | SortOrder
    qtde_carimbo?: SortOrderInput | SortOrder
    id_resgate?: SortOrderInput | SortOrder
    _count?: carimboCountOrderByAggregateInput
    _avg?: carimboAvgOrderByAggregateInput
    _max?: carimboMaxOrderByAggregateInput
    _min?: carimboMinOrderByAggregateInput
    _sum?: carimboSumOrderByAggregateInput
  }

  export type carimboScalarWhereWithAggregatesInput = {
    AND?: carimboScalarWhereWithAggregatesInput | carimboScalarWhereWithAggregatesInput[]
    OR?: carimboScalarWhereWithAggregatesInput[]
    NOT?: carimboScalarWhereWithAggregatesInput | carimboScalarWhereWithAggregatesInput[]
    id_carimbo?: IntWithAggregatesFilter<"carimbo"> | number
    id_user_carimbou?: IntWithAggregatesFilter<"carimbo"> | number
    id_user?: IntWithAggregatesFilter<"carimbo"> | number
    id_campanha?: IntWithAggregatesFilter<"carimbo"> | number
    data_carimbo?: DateTimeNullableWithAggregatesFilter<"carimbo"> | Date | string | null
    qtde_carimbo?: IntNullableWithAggregatesFilter<"carimbo"> | number | null
    id_resgate?: IntNullableWithAggregatesFilter<"carimbo"> | number | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    created_at?: DateTimeNullableFilter<"Category"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Category"> | Date | string | null
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    created_at?: DateTimeNullableFilter<"Category"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Category"> | Date | string | null
    products?: ProductListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
    update_at?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    price?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    banner?: StringFilter<"Product"> | string
    created_at?: DateTimeNullableFilter<"Product"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Product"> | Date | string | null
    category_id?: StringFilter<"Product"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    items?: ItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    category_id?: SortOrder
    category?: CategoryOrderByWithRelationInput
    items?: ItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    price?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    banner?: StringFilter<"Product"> | string
    created_at?: DateTimeNullableFilter<"Product"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Product"> | Date | string | null
    category_id?: StringFilter<"Product"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    items?: ItemListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    category_id?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    price?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    banner?: StringWithAggregatesFilter<"Product"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    update_at?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    category_id?: StringWithAggregatesFilter<"Product"> | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    table?: IntFilter<"Order"> | number
    status?: BoolFilter<"Order"> | boolean
    draft?: BoolFilter<"Order"> | boolean
    name?: StringNullableFilter<"Order"> | string | null
    created_at?: DateTimeNullableFilter<"Order"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Order"> | Date | string | null
    items?: ItemListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    table?: SortOrder
    status?: SortOrder
    draft?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    items?: ItemOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    table?: IntFilter<"Order"> | number
    status?: BoolFilter<"Order"> | boolean
    draft?: BoolFilter<"Order"> | boolean
    name?: StringNullableFilter<"Order"> | string | null
    created_at?: DateTimeNullableFilter<"Order"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Order"> | Date | string | null
    items?: ItemListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    table?: SortOrder
    status?: SortOrder
    draft?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    table?: IntWithAggregatesFilter<"Order"> | number
    status?: BoolWithAggregatesFilter<"Order"> | boolean
    draft?: BoolWithAggregatesFilter<"Order"> | boolean
    name?: StringNullableWithAggregatesFilter<"Order"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    update_at?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    amount?: IntFilter<"Item"> | number
    created_at?: DateTimeNullableFilter<"Item"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Item"> | Date | string | null
    order_id?: StringFilter<"Item"> | string
    product_id?: StringFilter<"Item"> | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    amount?: IntFilter<"Item"> | number
    created_at?: DateTimeNullableFilter<"Item"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Item"> | Date | string | null
    order_id?: StringFilter<"Item"> | string
    product_id?: StringFilter<"Item"> | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrderInput | SortOrder
    update_at?: SortOrderInput | SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    amount?: IntWithAggregatesFilter<"Item"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"Item"> | Date | string | null
    update_at?: DateTimeNullableWithAggregatesFilter<"Item"> | Date | string | null
    order_id?: StringWithAggregatesFilter<"Item"> | string
    product_id?: StringWithAggregatesFilter<"Item"> | string
  }

  export type telefone_compCreateInput = {
    id_dados_fisica: number
    ddd: string
    telefone: string
  }

  export type telefone_compUncheckedCreateInput = {
    id_telefone_comp?: number
    id_dados_fisica: number
    ddd: string
    telefone: string
  }

  export type telefone_compUpdateInput = {
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
    ddd?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
  }

  export type telefone_compUncheckedUpdateInput = {
    id_telefone_comp?: IntFieldUpdateOperationsInput | number
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
    ddd?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
  }

  export type telefone_compCreateManyInput = {
    id_telefone_comp?: number
    id_dados_fisica: number
    ddd: string
    telefone: string
  }

  export type telefone_compUpdateManyMutationInput = {
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
    ddd?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
  }

  export type telefone_compUncheckedUpdateManyInput = {
    id_telefone_comp?: IntFieldUpdateOperationsInput | number
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
    ddd?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
  }

  export type consulta_userCreateInput = {
    id_user: number
    data_cadastrou?: Date | string | null
    id_dados_fisica: number
  }

  export type consulta_userUncheckedCreateInput = {
    id_consulta_user?: number
    id_user: number
    data_cadastrou?: Date | string | null
    id_dados_fisica: number
  }

  export type consulta_userUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
  }

  export type consulta_userUncheckedUpdateInput = {
    id_consulta_user?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
  }

  export type consulta_userCreateManyInput = {
    id_consulta_user?: number
    id_user: number
    data_cadastrou?: Date | string | null
    id_dados_fisica: number
  }

  export type consulta_userUpdateManyMutationInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
  }

  export type consulta_userUncheckedUpdateManyInput = {
    id_consulta_user?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
  }

  export type consulta_saldoCreateInput = {
    id_user: number
    data_cadastrou: Date | string
    saldo: number
    saldo_contratado: number
    data_atualizou: Date | string
  }

  export type consulta_saldoUncheckedCreateInput = {
    id_consulta_sado?: number
    id_user: number
    data_cadastrou: Date | string
    saldo: number
    saldo_contratado: number
    data_atualizou: Date | string
  }

  export type consulta_saldoUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: DateTimeFieldUpdateOperationsInput | Date | string
    saldo?: IntFieldUpdateOperationsInput | number
    saldo_contratado?: IntFieldUpdateOperationsInput | number
    data_atualizou?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consulta_saldoUncheckedUpdateInput = {
    id_consulta_sado?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: DateTimeFieldUpdateOperationsInput | Date | string
    saldo?: IntFieldUpdateOperationsInput | number
    saldo_contratado?: IntFieldUpdateOperationsInput | number
    data_atualizou?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consulta_saldoCreateManyInput = {
    id_consulta_sado?: number
    id_user: number
    data_cadastrou: Date | string
    saldo: number
    saldo_contratado: number
    data_atualizou: Date | string
  }

  export type consulta_saldoUpdateManyMutationInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: DateTimeFieldUpdateOperationsInput | Date | string
    saldo?: IntFieldUpdateOperationsInput | number
    saldo_contratado?: IntFieldUpdateOperationsInput | number
    data_atualizou?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consulta_saldoUncheckedUpdateManyInput = {
    id_consulta_sado?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: DateTimeFieldUpdateOperationsInput | Date | string
    saldo?: IntFieldUpdateOperationsInput | number
    saldo_contratado?: IntFieldUpdateOperationsInput | number
    data_atualizou?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consulta_insere_logCreateInput = {
    id_user: number
    data_cadastrou?: Date | string | null
    debito: number
    fonte_propria: number
    consulta: string
    id_dados_fisica: number
  }

  export type consulta_insere_logUncheckedCreateInput = {
    id_consulta_insere?: number
    id_user: number
    data_cadastrou?: Date | string | null
    debito: number
    fonte_propria: number
    consulta: string
    id_dados_fisica: number
  }

  export type consulta_insere_logUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debito?: IntFieldUpdateOperationsInput | number
    fonte_propria?: IntFieldUpdateOperationsInput | number
    consulta?: StringFieldUpdateOperationsInput | string
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
  }

  export type consulta_insere_logUncheckedUpdateInput = {
    id_consulta_insere?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debito?: IntFieldUpdateOperationsInput | number
    fonte_propria?: IntFieldUpdateOperationsInput | number
    consulta?: StringFieldUpdateOperationsInput | string
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
  }

  export type consulta_insere_logCreateManyInput = {
    id_consulta_insere?: number
    id_user: number
    data_cadastrou?: Date | string | null
    debito: number
    fonte_propria: number
    consulta: string
    id_dados_fisica: number
  }

  export type consulta_insere_logUpdateManyMutationInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debito?: IntFieldUpdateOperationsInput | number
    fonte_propria?: IntFieldUpdateOperationsInput | number
    consulta?: StringFieldUpdateOperationsInput | string
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
  }

  export type consulta_insere_logUncheckedUpdateManyInput = {
    id_consulta_insere?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debito?: IntFieldUpdateOperationsInput | number
    fonte_propria?: IntFieldUpdateOperationsInput | number
    consulta?: StringFieldUpdateOperationsInput | string
    id_dados_fisica?: IntFieldUpdateOperationsInput | number
  }

  export type dados_fisicaCreateInput = {
    nome: string
    cpf: string
    tipo_end?: string | null
    rua?: string | null
    numero?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    morto?: boolean
    celular_ddd?: number | null
    celular_number?: string | null
    connect_whats?: Date | string | null
    rg?: string | null
    bairro?: string | null
    nome_mae?: string | null
    data_aniversaio?: Date | string | null
  }

  export type dados_fisicaUncheckedCreateInput = {
    id?: number
    nome: string
    cpf: string
    tipo_end?: string | null
    rua?: string | null
    numero?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    morto?: boolean
    celular_ddd?: number | null
    celular_number?: string | null
    connect_whats?: Date | string | null
    rg?: string | null
    bairro?: string | null
    nome_mae?: string | null
    data_aniversaio?: Date | string | null
  }

  export type dados_fisicaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    tipo_end?: NullableStringFieldUpdateOperationsInput | string | null
    rua?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    morto?: BoolFieldUpdateOperationsInput | boolean
    celular_ddd?: NullableIntFieldUpdateOperationsInput | number | null
    celular_number?: NullableStringFieldUpdateOperationsInput | string | null
    connect_whats?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    nome_mae?: NullableStringFieldUpdateOperationsInput | string | null
    data_aniversaio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type dados_fisicaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    tipo_end?: NullableStringFieldUpdateOperationsInput | string | null
    rua?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    morto?: BoolFieldUpdateOperationsInput | boolean
    celular_ddd?: NullableIntFieldUpdateOperationsInput | number | null
    celular_number?: NullableStringFieldUpdateOperationsInput | string | null
    connect_whats?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    nome_mae?: NullableStringFieldUpdateOperationsInput | string | null
    data_aniversaio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type dados_fisicaCreateManyInput = {
    id?: number
    nome: string
    cpf: string
    tipo_end?: string | null
    rua?: string | null
    numero?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    morto?: boolean
    celular_ddd?: number | null
    celular_number?: string | null
    connect_whats?: Date | string | null
    rg?: string | null
    bairro?: string | null
    nome_mae?: string | null
    data_aniversaio?: Date | string | null
  }

  export type dados_fisicaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    tipo_end?: NullableStringFieldUpdateOperationsInput | string | null
    rua?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    morto?: BoolFieldUpdateOperationsInput | boolean
    celular_ddd?: NullableIntFieldUpdateOperationsInput | number | null
    celular_number?: NullableStringFieldUpdateOperationsInput | string | null
    connect_whats?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    nome_mae?: NullableStringFieldUpdateOperationsInput | string | null
    data_aniversaio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type dados_fisicaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    tipo_end?: NullableStringFieldUpdateOperationsInput | string | null
    rua?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    morto?: BoolFieldUpdateOperationsInput | boolean
    celular_ddd?: NullableIntFieldUpdateOperationsInput | number | null
    celular_number?: NullableStringFieldUpdateOperationsInput | string | null
    connect_whats?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    nome_mae?: NullableStringFieldUpdateOperationsInput | string | null
    data_aniversaio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type crm_clienteCreateInput = {
    CODIGO_CLIENTE: string
    CPF: string
    DATA_VENDA: Date | string
    TICKET: string
    CODIGO_FILIAL: string
    VALOR_PAGO: Decimal | DecimalJsLike | number | string
    VALOR_TIKET: Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA: Date | string
    NOME_SOCIAL: string
    CLIENTE_VAREJO: string
    ANIVERSARIO: Date | string
    EMAIL: string
    DDD_CELULAR: string
    CELULAR: string
    DATA_CADASTROU: string
  }

  export type crm_clienteUncheckedCreateInput = {
    CODIGO_CLIENTE: string
    CPF: string
    DATA_VENDA: Date | string
    TICKET: string
    CODIGO_FILIAL: string
    VALOR_PAGO: Decimal | DecimalJsLike | number | string
    VALOR_TIKET: Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA: Date | string
    NOME_SOCIAL: string
    CLIENTE_VAREJO: string
    ANIVERSARIO: Date | string
    EMAIL: string
    DDD_CELULAR: string
    CELULAR: string
    DATA_CADASTROU: string
  }

  export type crm_clienteUpdateInput = {
    CODIGO_CLIENTE?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    DATA_VENDA?: DateTimeFieldUpdateOperationsInput | Date | string
    TICKET?: StringFieldUpdateOperationsInput | string
    CODIGO_FILIAL?: StringFieldUpdateOperationsInput | string
    VALOR_PAGO?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    VALOR_TIKET?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA?: DateTimeFieldUpdateOperationsInput | Date | string
    NOME_SOCIAL?: StringFieldUpdateOperationsInput | string
    CLIENTE_VAREJO?: StringFieldUpdateOperationsInput | string
    ANIVERSARIO?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAIL?: StringFieldUpdateOperationsInput | string
    DDD_CELULAR?: StringFieldUpdateOperationsInput | string
    CELULAR?: StringFieldUpdateOperationsInput | string
    DATA_CADASTROU?: StringFieldUpdateOperationsInput | string
  }

  export type crm_clienteUncheckedUpdateInput = {
    CODIGO_CLIENTE?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    DATA_VENDA?: DateTimeFieldUpdateOperationsInput | Date | string
    TICKET?: StringFieldUpdateOperationsInput | string
    CODIGO_FILIAL?: StringFieldUpdateOperationsInput | string
    VALOR_PAGO?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    VALOR_TIKET?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA?: DateTimeFieldUpdateOperationsInput | Date | string
    NOME_SOCIAL?: StringFieldUpdateOperationsInput | string
    CLIENTE_VAREJO?: StringFieldUpdateOperationsInput | string
    ANIVERSARIO?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAIL?: StringFieldUpdateOperationsInput | string
    DDD_CELULAR?: StringFieldUpdateOperationsInput | string
    CELULAR?: StringFieldUpdateOperationsInput | string
    DATA_CADASTROU?: StringFieldUpdateOperationsInput | string
  }

  export type crm_clienteCreateManyInput = {
    CODIGO_CLIENTE: string
    CPF: string
    DATA_VENDA: Date | string
    TICKET: string
    CODIGO_FILIAL: string
    VALOR_PAGO: Decimal | DecimalJsLike | number | string
    VALOR_TIKET: Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA: Date | string
    NOME_SOCIAL: string
    CLIENTE_VAREJO: string
    ANIVERSARIO: Date | string
    EMAIL: string
    DDD_CELULAR: string
    CELULAR: string
    DATA_CADASTROU: string
  }

  export type crm_clienteUpdateManyMutationInput = {
    CODIGO_CLIENTE?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    DATA_VENDA?: DateTimeFieldUpdateOperationsInput | Date | string
    TICKET?: StringFieldUpdateOperationsInput | string
    CODIGO_FILIAL?: StringFieldUpdateOperationsInput | string
    VALOR_PAGO?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    VALOR_TIKET?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA?: DateTimeFieldUpdateOperationsInput | Date | string
    NOME_SOCIAL?: StringFieldUpdateOperationsInput | string
    CLIENTE_VAREJO?: StringFieldUpdateOperationsInput | string
    ANIVERSARIO?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAIL?: StringFieldUpdateOperationsInput | string
    DDD_CELULAR?: StringFieldUpdateOperationsInput | string
    CELULAR?: StringFieldUpdateOperationsInput | string
    DATA_CADASTROU?: StringFieldUpdateOperationsInput | string
  }

  export type crm_clienteUncheckedUpdateManyInput = {
    CODIGO_CLIENTE?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    DATA_VENDA?: DateTimeFieldUpdateOperationsInput | Date | string
    TICKET?: StringFieldUpdateOperationsInput | string
    CODIGO_FILIAL?: StringFieldUpdateOperationsInput | string
    VALOR_PAGO?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    VALOR_TIKET?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ULTIMA_COMPRA?: DateTimeFieldUpdateOperationsInput | Date | string
    NOME_SOCIAL?: StringFieldUpdateOperationsInput | string
    CLIENTE_VAREJO?: StringFieldUpdateOperationsInput | string
    ANIVERSARIO?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAIL?: StringFieldUpdateOperationsInput | string
    DDD_CELULAR?: StringFieldUpdateOperationsInput | string
    CELULAR?: StringFieldUpdateOperationsInput | string
    DATA_CADASTROU?: StringFieldUpdateOperationsInput | string
  }

  export type status_pedidoCreateInput = {
    nome_status: string
    id_empresa: number
    ativo: number
    data_cadastrou?: Date | string | null
  }

  export type status_pedidoUncheckedCreateInput = {
    id_status_pedido?: number
    nome_status: string
    id_empresa: number
    ativo: number
    data_cadastrou?: Date | string | null
  }

  export type status_pedidoUpdateInput = {
    nome_status?: StringFieldUpdateOperationsInput | string
    id_empresa?: IntFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type status_pedidoUncheckedUpdateInput = {
    id_status_pedido?: IntFieldUpdateOperationsInput | number
    nome_status?: StringFieldUpdateOperationsInput | string
    id_empresa?: IntFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type status_pedidoCreateManyInput = {
    id_status_pedido?: number
    nome_status: string
    id_empresa: number
    ativo: number
    data_cadastrou?: Date | string | null
  }

  export type status_pedidoUpdateManyMutationInput = {
    nome_status?: StringFieldUpdateOperationsInput | string
    id_empresa?: IntFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type status_pedidoUncheckedUpdateManyInput = {
    id_status_pedido?: IntFieldUpdateOperationsInput | number
    nome_status?: StringFieldUpdateOperationsInput | string
    id_empresa?: IntFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pedidoCreateInput = {
    id_user: number
    id_lista: number
    total: number
    data_cadastrou?: Date | string | null
  }

  export type pedidoUncheckedCreateInput = {
    id_pedido?: number
    id_user: number
    id_lista: number
    total: number
    data_cadastrou?: Date | string | null
  }

  export type pedidoUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    id_lista?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pedidoUncheckedUpdateInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_lista?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pedidoCreateManyInput = {
    id_pedido?: number
    id_user: number
    id_lista: number
    total: number
    data_cadastrou?: Date | string | null
  }

  export type pedidoUpdateManyMutationInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    id_lista?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pedidoUncheckedUpdateManyInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_lista?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pedido_itemCreateInput = {
    id_pedido: number
    id_produto: number
    qtde: number
    valor_unit: number
    data_cadastrou?: Date | string | null
  }

  export type pedido_itemUncheckedCreateInput = {
    id_pedido_item?: number
    id_pedido: number
    id_produto: number
    qtde: number
    valor_unit: number
    data_cadastrou?: Date | string | null
  }

  export type pedido_itemUpdateInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    id_produto?: IntFieldUpdateOperationsInput | number
    qtde?: IntFieldUpdateOperationsInput | number
    valor_unit?: FloatFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pedido_itemUncheckedUpdateInput = {
    id_pedido_item?: IntFieldUpdateOperationsInput | number
    id_pedido?: IntFieldUpdateOperationsInput | number
    id_produto?: IntFieldUpdateOperationsInput | number
    qtde?: IntFieldUpdateOperationsInput | number
    valor_unit?: FloatFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pedido_itemCreateManyInput = {
    id_pedido_item?: number
    id_pedido: number
    id_produto: number
    qtde: number
    valor_unit: number
    data_cadastrou?: Date | string | null
  }

  export type pedido_itemUpdateManyMutationInput = {
    id_pedido?: IntFieldUpdateOperationsInput | number
    id_produto?: IntFieldUpdateOperationsInput | number
    qtde?: IntFieldUpdateOperationsInput | number
    valor_unit?: FloatFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pedido_itemUncheckedUpdateManyInput = {
    id_pedido_item?: IntFieldUpdateOperationsInput | number
    id_pedido?: IntFieldUpdateOperationsInput | number
    id_produto?: IntFieldUpdateOperationsInput | number
    qtde?: IntFieldUpdateOperationsInput | number
    valor_unit?: FloatFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lista_produtoCreateInput = {
    id_produto: number
    id_lista: number
    id_empresa: number
    qtde_para_venda: number
    qtde_disponivel: number
    data_cadastrou?: Date | string | null
  }

  export type lista_produtoUncheckedCreateInput = {
    id_lista_produto?: number
    id_produto: number
    id_lista: number
    id_empresa: number
    qtde_para_venda: number
    qtde_disponivel: number
    data_cadastrou?: Date | string | null
  }

  export type lista_produtoUpdateInput = {
    id_produto?: IntFieldUpdateOperationsInput | number
    id_lista?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    qtde_para_venda?: IntFieldUpdateOperationsInput | number
    qtde_disponivel?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lista_produtoUncheckedUpdateInput = {
    id_lista_produto?: IntFieldUpdateOperationsInput | number
    id_produto?: IntFieldUpdateOperationsInput | number
    id_lista?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    qtde_para_venda?: IntFieldUpdateOperationsInput | number
    qtde_disponivel?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lista_produtoCreateManyInput = {
    id_lista_produto?: number
    id_produto: number
    id_lista: number
    id_empresa: number
    qtde_para_venda: number
    qtde_disponivel: number
    data_cadastrou?: Date | string | null
  }

  export type lista_produtoUpdateManyMutationInput = {
    id_produto?: IntFieldUpdateOperationsInput | number
    id_lista?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    qtde_para_venda?: IntFieldUpdateOperationsInput | number
    qtde_disponivel?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lista_produtoUncheckedUpdateManyInput = {
    id_lista_produto?: IntFieldUpdateOperationsInput | number
    id_produto?: IntFieldUpdateOperationsInput | number
    id_lista?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    qtde_para_venda?: IntFieldUpdateOperationsInput | number
    qtde_disponivel?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanha_tokenCreateInput = {
    id_campanha: number
    token: string
    utilizado: number
    gerado: number
    data_cadastrou?: Date | string | null
  }

  export type campanha_tokenUncheckedCreateInput = {
    id_campanha_token?: number
    id_campanha: number
    token: string
    utilizado: number
    gerado: number
    data_cadastrou?: Date | string | null
  }

  export type campanha_tokenUpdateInput = {
    id_campanha?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    utilizado?: IntFieldUpdateOperationsInput | number
    gerado?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanha_tokenUncheckedUpdateInput = {
    id_campanha_token?: IntFieldUpdateOperationsInput | number
    id_campanha?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    utilizado?: IntFieldUpdateOperationsInput | number
    gerado?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanha_tokenCreateManyInput = {
    id_campanha_token?: number
    id_campanha: number
    token: string
    utilizado: number
    gerado: number
    data_cadastrou?: Date | string | null
  }

  export type campanha_tokenUpdateManyMutationInput = {
    id_campanha?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    utilizado?: IntFieldUpdateOperationsInput | number
    gerado?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanha_tokenUncheckedUpdateManyInput = {
    id_campanha_token?: IntFieldUpdateOperationsInput | number
    id_campanha?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    utilizado?: IntFieldUpdateOperationsInput | number
    gerado?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userempresaCreateInput = {
    id_empresa: number
    id_user: number
    data_cadastrou?: Date | string | null
    role?: number | null
  }

  export type userempresaUncheckedCreateInput = {
    id_user_empresa?: number
    id_empresa: number
    id_user: number
    data_cadastrou?: Date | string | null
    role?: number | null
  }

  export type userempresaUpdateInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userempresaUncheckedUpdateInput = {
    id_user_empresa?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userempresaCreateManyInput = {
    id_user_empresa?: number
    id_empresa: number
    id_user: number
    data_cadastrou?: Date | string | null
    role?: number | null
  }

  export type userempresaUpdateManyMutationInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userempresaUncheckedUpdateManyInput = {
    id_user_empresa?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type listaCreateInput = {
    id_empresa: number
    nome_lista: string
    ativo?: number | null
    descricao: string
    data_cadastrou?: Date | string | null
    data_vigencia_inicio?: Date | string | null
    data_vigencia_fim?: Date | string | null
    uid?: string | null
  }

  export type listaUncheckedCreateInput = {
    id_lista?: number
    id_empresa: number
    nome_lista: string
    ativo?: number | null
    descricao: string
    data_cadastrou?: Date | string | null
    data_vigencia_inicio?: Date | string | null
    data_vigencia_fim?: Date | string | null
    uid?: string | null
  }

  export type listaUpdateInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_lista?: StringFieldUpdateOperationsInput | string
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    descricao?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_vigencia_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_vigencia_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type listaUncheckedUpdateInput = {
    id_lista?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_lista?: StringFieldUpdateOperationsInput | string
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    descricao?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_vigencia_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_vigencia_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type listaCreateManyInput = {
    id_lista?: number
    id_empresa: number
    nome_lista: string
    ativo?: number | null
    descricao: string
    data_cadastrou?: Date | string | null
    data_vigencia_inicio?: Date | string | null
    data_vigencia_fim?: Date | string | null
    uid?: string | null
  }

  export type listaUpdateManyMutationInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_lista?: StringFieldUpdateOperationsInput | string
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    descricao?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_vigencia_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_vigencia_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type listaUncheckedUpdateManyInput = {
    id_lista?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_lista?: StringFieldUpdateOperationsInput | string
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    descricao?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_vigencia_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_vigencia_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriaCreateInput = {
    id_empresa: number
    nome_categoria: string
    ativo: number
    data_cadastrou?: Date | string | null
    data_update?: Date | string | null
    icon?: string | null
    produtos?: produtoCreateNestedManyWithoutCategoriaInput
  }

  export type categoriaUncheckedCreateInput = {
    id_categoria?: number
    id_empresa: number
    nome_categoria: string
    ativo: number
    data_cadastrou?: Date | string | null
    data_update?: Date | string | null
    icon?: string | null
    produtos?: produtoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type categoriaUpdateInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_categoria?: StringFieldUpdateOperationsInput | string
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    produtos?: produtoUpdateManyWithoutCategoriaNestedInput
  }

  export type categoriaUncheckedUpdateInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_categoria?: StringFieldUpdateOperationsInput | string
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    produtos?: produtoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type categoriaCreateManyInput = {
    id_categoria?: number
    id_empresa: number
    nome_categoria: string
    ativo: number
    data_cadastrou?: Date | string | null
    data_update?: Date | string | null
    icon?: string | null
  }

  export type categoriaUpdateManyMutationInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_categoria?: StringFieldUpdateOperationsInput | string
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriaUncheckedUpdateManyInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_categoria?: StringFieldUpdateOperationsInput | string
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type produtoCreateInput = {
    id_empresa: number
    nome_produto: string
    valor: number
    ativo: number
    data_cadastrou?: Date | string | null
    descricao: string
    categoria: categoriaCreateNestedOneWithoutProdutosInput
  }

  export type produtoUncheckedCreateInput = {
    id_produto?: number
    id_empresa: number
    id_categoria: number
    nome_produto: string
    valor: number
    ativo: number
    data_cadastrou?: Date | string | null
    descricao: string
  }

  export type produtoUpdateInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_produto?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    categoria?: categoriaUpdateOneRequiredWithoutProdutosNestedInput
  }

  export type produtoUncheckedUpdateInput = {
    id_produto?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    nome_produto?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type produtoCreateManyInput = {
    id_produto?: number
    id_empresa: number
    id_categoria: number
    nome_produto: string
    valor: number
    ativo: number
    data_cadastrou?: Date | string | null
    descricao: string
  }

  export type produtoUpdateManyMutationInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_produto?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type produtoUncheckedUpdateManyInput = {
    id_produto?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    nome_produto?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type usuarioCreateInput = {
    cpf: string
    nome: string
    endereco: string
    bairro: string
    tipo: string
    cidade: string
    postalcode: string
    celular: string
    data_cadastrou?: Date | string | null
    ativo?: number | null
    numero: string
    data_nascimento?: Date | string | null
    email?: string | null
    telefone?: string | null
    user: UserCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    id_usuario?: number
    id_user: number
    cpf: string
    nome: string
    endereco: string
    bairro: string
    tipo: string
    cidade: string
    postalcode: string
    celular: string
    data_cadastrou?: Date | string | null
    ativo?: number | null
    numero: string
    data_nascimento?: Date | string | null
    email?: string | null
    telefone?: string | null
  }

  export type usuarioUpdateInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    postalcode?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    numero?: StringFieldUpdateOperationsInput | string
    data_nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    postalcode?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    numero?: StringFieldUpdateOperationsInput | string
    data_nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioCreateManyInput = {
    id_usuario?: number
    id_user: number
    cpf: string
    nome: string
    endereco: string
    bairro: string
    tipo: string
    cidade: string
    postalcode: string
    celular: string
    data_cadastrou?: Date | string | null
    ativo?: number | null
    numero: string
    data_nascimento?: Date | string | null
    email?: string | null
    telefone?: string | null
  }

  export type usuarioUpdateManyMutationInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    postalcode?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    numero?: StringFieldUpdateOperationsInput | string
    data_nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    postalcode?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    numero?: StringFieldUpdateOperationsInput | string
    data_nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Campanha_msgCreateInput = {
    mensagem: string
    nome: string
    ativo?: number | null
    data_cadastrou?: Date | string | null
    id_empresa: number
    id_user: number
  }

  export type Campanha_msgUncheckedCreateInput = {
    id_campanha_msg?: number
    mensagem: string
    nome: string
    ativo?: number | null
    data_cadastrou?: Date | string | null
    id_empresa: number
    id_user: number
  }

  export type Campanha_msgUpdateInput = {
    mensagem?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type Campanha_msgUncheckedUpdateInput = {
    id_campanha_msg?: IntFieldUpdateOperationsInput | number
    mensagem?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type Campanha_msgCreateManyInput = {
    id_campanha_msg?: number
    mensagem: string
    nome: string
    ativo?: number | null
    data_cadastrou?: Date | string | null
    id_empresa: number
    id_user: number
  }

  export type Campanha_msgUpdateManyMutationInput = {
    mensagem?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type Campanha_msgUncheckedUpdateManyInput = {
    id_campanha_msg?: IntFieldUpdateOperationsInput | number
    mensagem?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    name: string
    email?: string | null
    password: string
    cpf?: string | null
    role?: number | null
    created_at?: Date | string | null
    update_at?: Date | string | null
    ativo?: number
    uid_user?: string | null
    usuario?: usuarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email?: string | null
    password: string
    cpf?: string | null
    role?: number | null
    created_at?: Date | string | null
    update_at?: Date | string | null
    ativo?: number
    uid_user?: string | null
    usuario?: usuarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: IntFieldUpdateOperationsInput | number
    uid_user?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: IntFieldUpdateOperationsInput | number
    uid_user?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email?: string | null
    password: string
    cpf?: string | null
    role?: number | null
    created_at?: Date | string | null
    update_at?: Date | string | null
    ativo?: number
    uid_user?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: IntFieldUpdateOperationsInput | number
    uid_user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: IntFieldUpdateOperationsInput | number
    uid_user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResgateCreateInput = {
    id_campanha: number
    id_user: number
    id_user_realizou: number
    data_cadastrou?: Date | string | null
    qtde_resgatado: number
  }

  export type ResgateUncheckedCreateInput = {
    id_resgate?: number
    id_campanha: number
    id_user: number
    id_user_realizou: number
    data_cadastrou?: Date | string | null
    qtde_resgatado: number
  }

  export type ResgateUpdateInput = {
    id_campanha?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_user_realizou?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qtde_resgatado?: IntFieldUpdateOperationsInput | number
  }

  export type ResgateUncheckedUpdateInput = {
    id_resgate?: IntFieldUpdateOperationsInput | number
    id_campanha?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_user_realizou?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qtde_resgatado?: IntFieldUpdateOperationsInput | number
  }

  export type ResgateCreateManyInput = {
    id_resgate?: number
    id_campanha: number
    id_user: number
    id_user_realizou: number
    data_cadastrou?: Date | string | null
    qtde_resgatado: number
  }

  export type ResgateUpdateManyMutationInput = {
    id_campanha?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_user_realizou?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qtde_resgatado?: IntFieldUpdateOperationsInput | number
  }

  export type ResgateUncheckedUpdateManyInput = {
    id_resgate?: IntFieldUpdateOperationsInput | number
    id_campanha?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_user_realizou?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qtde_resgatado?: IntFieldUpdateOperationsInput | number
  }

  export type empresaCreateInput = {
    id_user: number
    nome_empresa: string
    cnpj?: string | null
    data_cadastrou?: Date | string | null
    ativo?: number | null
    uid?: string
    apikey?: string | null
  }

  export type empresaUncheckedCreateInput = {
    id_empresa?: number
    id_user: number
    nome_empresa: string
    cnpj?: string | null
    data_cadastrou?: Date | string | null
    ativo?: number | null
    uid?: string
    apikey?: string | null
  }

  export type empresaUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    nome_empresa?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    uid?: StringFieldUpdateOperationsInput | string
    apikey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empresaUncheckedUpdateInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    nome_empresa?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    uid?: StringFieldUpdateOperationsInput | string
    apikey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empresaCreateManyInput = {
    id_empresa?: number
    id_user: number
    nome_empresa: string
    cnpj?: string | null
    data_cadastrou?: Date | string | null
    ativo?: number | null
    uid?: string
    apikey?: string | null
  }

  export type empresaUpdateManyMutationInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    nome_empresa?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    uid?: StringFieldUpdateOperationsInput | string
    apikey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empresaUncheckedUpdateManyInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    nome_empresa?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    uid?: StringFieldUpdateOperationsInput | string
    apikey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campanha_formularioCreateInput = {
    token: string
    nome: string
    email: string
    cpf: string
    celular: string
    data_cadastrou?: Date | string | null
  }

  export type campanha_formularioUncheckedCreateInput = {
    id_campanha_formulario?: number
    token: string
    nome: string
    email: string
    cpf: string
    celular: string
    data_cadastrou?: Date | string | null
  }

  export type campanha_formularioUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanha_formularioUncheckedUpdateInput = {
    id_campanha_formulario?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanha_formularioCreateManyInput = {
    id_campanha_formulario?: number
    token: string
    nome: string
    email: string
    cpf: string
    celular: string
    data_cadastrou?: Date | string | null
  }

  export type campanha_formularioUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanha_formularioUncheckedUpdateManyInput = {
    id_campanha_formulario?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanhaCreateInput = {
    id_empresa: number
    envia_msg?: number | null
    recompensa?: string | null
    nome_campanha: string
    data_inicio?: Date | string | null
    data_fim?: Date | string | null
    ativo?: number | null
    qtde_servico: number
    descricao?: string | null
    id_user?: number | null
    gera_token?: number | null
    nro_campanha_cliente?: string | null
    qtde_token?: number | null
    qtde_pontos?: number | null
    id_campanha_msg?: number | null
    mensagem_cliente?: string | null
    uid?: string
  }

  export type campanhaUncheckedCreateInput = {
    id_campanha?: number
    id_empresa: number
    envia_msg?: number | null
    recompensa?: string | null
    nome_campanha: string
    data_inicio?: Date | string | null
    data_fim?: Date | string | null
    ativo?: number | null
    qtde_servico: number
    descricao?: string | null
    id_user?: number | null
    gera_token?: number | null
    nro_campanha_cliente?: string | null
    qtde_token?: number | null
    qtde_pontos?: number | null
    id_campanha_msg?: number | null
    mensagem_cliente?: string | null
    uid?: string
  }

  export type campanhaUpdateInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    envia_msg?: NullableIntFieldUpdateOperationsInput | number | null
    recompensa?: NullableStringFieldUpdateOperationsInput | string | null
    nome_campanha?: StringFieldUpdateOperationsInput | string
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    qtde_servico?: IntFieldUpdateOperationsInput | number
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: NullableIntFieldUpdateOperationsInput | number | null
    gera_token?: NullableIntFieldUpdateOperationsInput | number | null
    nro_campanha_cliente?: NullableStringFieldUpdateOperationsInput | string | null
    qtde_token?: NullableIntFieldUpdateOperationsInput | number | null
    qtde_pontos?: NullableIntFieldUpdateOperationsInput | number | null
    id_campanha_msg?: NullableIntFieldUpdateOperationsInput | number | null
    mensagem_cliente?: NullableStringFieldUpdateOperationsInput | string | null
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type campanhaUncheckedUpdateInput = {
    id_campanha?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    envia_msg?: NullableIntFieldUpdateOperationsInput | number | null
    recompensa?: NullableStringFieldUpdateOperationsInput | string | null
    nome_campanha?: StringFieldUpdateOperationsInput | string
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    qtde_servico?: IntFieldUpdateOperationsInput | number
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: NullableIntFieldUpdateOperationsInput | number | null
    gera_token?: NullableIntFieldUpdateOperationsInput | number | null
    nro_campanha_cliente?: NullableStringFieldUpdateOperationsInput | string | null
    qtde_token?: NullableIntFieldUpdateOperationsInput | number | null
    qtde_pontos?: NullableIntFieldUpdateOperationsInput | number | null
    id_campanha_msg?: NullableIntFieldUpdateOperationsInput | number | null
    mensagem_cliente?: NullableStringFieldUpdateOperationsInput | string | null
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type campanhaCreateManyInput = {
    id_campanha?: number
    id_empresa: number
    envia_msg?: number | null
    recompensa?: string | null
    nome_campanha: string
    data_inicio?: Date | string | null
    data_fim?: Date | string | null
    ativo?: number | null
    qtde_servico: number
    descricao?: string | null
    id_user?: number | null
    gera_token?: number | null
    nro_campanha_cliente?: string | null
    qtde_token?: number | null
    qtde_pontos?: number | null
    id_campanha_msg?: number | null
    mensagem_cliente?: string | null
    uid?: string
  }

  export type campanhaUpdateManyMutationInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    envia_msg?: NullableIntFieldUpdateOperationsInput | number | null
    recompensa?: NullableStringFieldUpdateOperationsInput | string | null
    nome_campanha?: StringFieldUpdateOperationsInput | string
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    qtde_servico?: IntFieldUpdateOperationsInput | number
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: NullableIntFieldUpdateOperationsInput | number | null
    gera_token?: NullableIntFieldUpdateOperationsInput | number | null
    nro_campanha_cliente?: NullableStringFieldUpdateOperationsInput | string | null
    qtde_token?: NullableIntFieldUpdateOperationsInput | number | null
    qtde_pontos?: NullableIntFieldUpdateOperationsInput | number | null
    id_campanha_msg?: NullableIntFieldUpdateOperationsInput | number | null
    mensagem_cliente?: NullableStringFieldUpdateOperationsInput | string | null
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type campanhaUncheckedUpdateManyInput = {
    id_campanha?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    envia_msg?: NullableIntFieldUpdateOperationsInput | number | null
    recompensa?: NullableStringFieldUpdateOperationsInput | string | null
    nome_campanha?: StringFieldUpdateOperationsInput | string
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    qtde_servico?: IntFieldUpdateOperationsInput | number
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: NullableIntFieldUpdateOperationsInput | number | null
    gera_token?: NullableIntFieldUpdateOperationsInput | number | null
    nro_campanha_cliente?: NullableStringFieldUpdateOperationsInput | string | null
    qtde_token?: NullableIntFieldUpdateOperationsInput | number | null
    qtde_pontos?: NullableIntFieldUpdateOperationsInput | number | null
    id_campanha_msg?: NullableIntFieldUpdateOperationsInput | number | null
    mensagem_cliente?: NullableStringFieldUpdateOperationsInput | string | null
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type carimboCreateInput = {
    id_user_carimbou: number
    id_user: number
    id_campanha: number
    data_carimbo?: Date | string | null
    qtde_carimbo?: number | null
    id_resgate?: number | null
  }

  export type carimboUncheckedCreateInput = {
    id_carimbo?: number
    id_user_carimbou: number
    id_user: number
    id_campanha: number
    data_carimbo?: Date | string | null
    qtde_carimbo?: number | null
    id_resgate?: number | null
  }

  export type carimboUpdateInput = {
    id_user_carimbou?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_campanha?: IntFieldUpdateOperationsInput | number
    data_carimbo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qtde_carimbo?: NullableIntFieldUpdateOperationsInput | number | null
    id_resgate?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type carimboUncheckedUpdateInput = {
    id_carimbo?: IntFieldUpdateOperationsInput | number
    id_user_carimbou?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_campanha?: IntFieldUpdateOperationsInput | number
    data_carimbo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qtde_carimbo?: NullableIntFieldUpdateOperationsInput | number | null
    id_resgate?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type carimboCreateManyInput = {
    id_carimbo?: number
    id_user_carimbou: number
    id_user: number
    id_campanha: number
    data_carimbo?: Date | string | null
    qtde_carimbo?: number | null
    id_resgate?: number | null
  }

  export type carimboUpdateManyMutationInput = {
    id_user_carimbou?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_campanha?: IntFieldUpdateOperationsInput | number
    data_carimbo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qtde_carimbo?: NullableIntFieldUpdateOperationsInput | number | null
    id_resgate?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type carimboUncheckedUpdateManyInput = {
    id_carimbo?: IntFieldUpdateOperationsInput | number
    id_user_carimbou?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    id_campanha?: IntFieldUpdateOperationsInput | number
    data_carimbo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qtde_carimbo?: NullableIntFieldUpdateOperationsInput | number | null
    id_resgate?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    created_at?: Date | string | null
    update_at?: Date | string | null
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string | null
    update_at?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string | null
    update_at?: Date | string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    price: string
    description: string
    banner: string
    created_at?: Date | string | null
    update_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    items?: ItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    price: string
    description: string
    banner: string
    created_at?: Date | string | null
    update_at?: Date | string | null
    category_id: string
    items?: ItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    items?: ItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    price: string
    description: string
    banner: string
    created_at?: Date | string | null
    update_at?: Date | string | null
    category_id: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateInput = {
    id?: string
    table: number
    status?: boolean
    draft?: boolean
    name?: string | null
    created_at?: Date | string | null
    update_at?: Date | string | null
    items?: ItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    table: number
    status?: boolean
    draft?: boolean
    name?: string | null
    created_at?: Date | string | null
    update_at?: Date | string | null
    items?: ItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    draft?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    draft?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    table: number
    status?: boolean
    draft?: boolean
    name?: string | null
    created_at?: Date | string | null
    update_at?: Date | string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    draft?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    draft?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCreateInput = {
    id?: string
    amount: number
    created_at?: Date | string | null
    update_at?: Date | string | null
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    amount: number
    created_at?: Date | string | null
    update_at?: Date | string | null
    order_id: string
    product_id: string
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateManyInput = {
    id?: string
    amount: number
    created_at?: Date | string | null
    update_at?: Date | string | null
    order_id: string
    product_id: string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type telefone_compCountOrderByAggregateInput = {
    id_telefone_comp?: SortOrder
    id_dados_fisica?: SortOrder
    ddd?: SortOrder
    telefone?: SortOrder
  }

  export type telefone_compAvgOrderByAggregateInput = {
    id_telefone_comp?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type telefone_compMaxOrderByAggregateInput = {
    id_telefone_comp?: SortOrder
    id_dados_fisica?: SortOrder
    ddd?: SortOrder
    telefone?: SortOrder
  }

  export type telefone_compMinOrderByAggregateInput = {
    id_telefone_comp?: SortOrder
    id_dados_fisica?: SortOrder
    ddd?: SortOrder
    telefone?: SortOrder
  }

  export type telefone_compSumOrderByAggregateInput = {
    id_telefone_comp?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type consulta_userCountOrderByAggregateInput = {
    id_consulta_user?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_userAvgOrderByAggregateInput = {
    id_consulta_user?: SortOrder
    id_user?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_userMaxOrderByAggregateInput = {
    id_consulta_user?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_userMinOrderByAggregateInput = {
    id_consulta_user?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_userSumOrderByAggregateInput = {
    id_consulta_user?: SortOrder
    id_user?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type consulta_saldoCountOrderByAggregateInput = {
    id_consulta_sado?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    saldo?: SortOrder
    saldo_contratado?: SortOrder
    data_atualizou?: SortOrder
  }

  export type consulta_saldoAvgOrderByAggregateInput = {
    id_consulta_sado?: SortOrder
    id_user?: SortOrder
    saldo?: SortOrder
    saldo_contratado?: SortOrder
  }

  export type consulta_saldoMaxOrderByAggregateInput = {
    id_consulta_sado?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    saldo?: SortOrder
    saldo_contratado?: SortOrder
    data_atualizou?: SortOrder
  }

  export type consulta_saldoMinOrderByAggregateInput = {
    id_consulta_sado?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    saldo?: SortOrder
    saldo_contratado?: SortOrder
    data_atualizou?: SortOrder
  }

  export type consulta_saldoSumOrderByAggregateInput = {
    id_consulta_sado?: SortOrder
    id_user?: SortOrder
    saldo?: SortOrder
    saldo_contratado?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type consulta_insere_logCountOrderByAggregateInput = {
    id_consulta_insere?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    debito?: SortOrder
    fonte_propria?: SortOrder
    consulta?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_insere_logAvgOrderByAggregateInput = {
    id_consulta_insere?: SortOrder
    id_user?: SortOrder
    debito?: SortOrder
    fonte_propria?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_insere_logMaxOrderByAggregateInput = {
    id_consulta_insere?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    debito?: SortOrder
    fonte_propria?: SortOrder
    consulta?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_insere_logMinOrderByAggregateInput = {
    id_consulta_insere?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    debito?: SortOrder
    fonte_propria?: SortOrder
    consulta?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type consulta_insere_logSumOrderByAggregateInput = {
    id_consulta_insere?: SortOrder
    id_user?: SortOrder
    debito?: SortOrder
    fonte_propria?: SortOrder
    id_dados_fisica?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type dados_fisicaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    tipo_end?: SortOrder
    rua?: SortOrder
    numero?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    cep?: SortOrder
    morto?: SortOrder
    celular_ddd?: SortOrder
    celular_number?: SortOrder
    connect_whats?: SortOrder
    rg?: SortOrder
    bairro?: SortOrder
    nome_mae?: SortOrder
    data_aniversaio?: SortOrder
  }

  export type dados_fisicaAvgOrderByAggregateInput = {
    id?: SortOrder
    celular_ddd?: SortOrder
  }

  export type dados_fisicaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    tipo_end?: SortOrder
    rua?: SortOrder
    numero?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    cep?: SortOrder
    morto?: SortOrder
    celular_ddd?: SortOrder
    celular_number?: SortOrder
    connect_whats?: SortOrder
    rg?: SortOrder
    bairro?: SortOrder
    nome_mae?: SortOrder
    data_aniversaio?: SortOrder
  }

  export type dados_fisicaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    tipo_end?: SortOrder
    rua?: SortOrder
    numero?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    cep?: SortOrder
    morto?: SortOrder
    celular_ddd?: SortOrder
    celular_number?: SortOrder
    connect_whats?: SortOrder
    rg?: SortOrder
    bairro?: SortOrder
    nome_mae?: SortOrder
    data_aniversaio?: SortOrder
  }

  export type dados_fisicaSumOrderByAggregateInput = {
    id?: SortOrder
    celular_ddd?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type crm_clienteCountOrderByAggregateInput = {
    CODIGO_CLIENTE?: SortOrder
    CPF?: SortOrder
    DATA_VENDA?: SortOrder
    TICKET?: SortOrder
    CODIGO_FILIAL?: SortOrder
    VALOR_PAGO?: SortOrder
    VALOR_TIKET?: SortOrder
    ULTIMA_COMPRA?: SortOrder
    NOME_SOCIAL?: SortOrder
    CLIENTE_VAREJO?: SortOrder
    ANIVERSARIO?: SortOrder
    EMAIL?: SortOrder
    DDD_CELULAR?: SortOrder
    CELULAR?: SortOrder
    DATA_CADASTROU?: SortOrder
  }

  export type crm_clienteAvgOrderByAggregateInput = {
    VALOR_PAGO?: SortOrder
    VALOR_TIKET?: SortOrder
  }

  export type crm_clienteMaxOrderByAggregateInput = {
    CODIGO_CLIENTE?: SortOrder
    CPF?: SortOrder
    DATA_VENDA?: SortOrder
    TICKET?: SortOrder
    CODIGO_FILIAL?: SortOrder
    VALOR_PAGO?: SortOrder
    VALOR_TIKET?: SortOrder
    ULTIMA_COMPRA?: SortOrder
    NOME_SOCIAL?: SortOrder
    CLIENTE_VAREJO?: SortOrder
    ANIVERSARIO?: SortOrder
    EMAIL?: SortOrder
    DDD_CELULAR?: SortOrder
    CELULAR?: SortOrder
    DATA_CADASTROU?: SortOrder
  }

  export type crm_clienteMinOrderByAggregateInput = {
    CODIGO_CLIENTE?: SortOrder
    CPF?: SortOrder
    DATA_VENDA?: SortOrder
    TICKET?: SortOrder
    CODIGO_FILIAL?: SortOrder
    VALOR_PAGO?: SortOrder
    VALOR_TIKET?: SortOrder
    ULTIMA_COMPRA?: SortOrder
    NOME_SOCIAL?: SortOrder
    CLIENTE_VAREJO?: SortOrder
    ANIVERSARIO?: SortOrder
    EMAIL?: SortOrder
    DDD_CELULAR?: SortOrder
    CELULAR?: SortOrder
    DATA_CADASTROU?: SortOrder
  }

  export type crm_clienteSumOrderByAggregateInput = {
    VALOR_PAGO?: SortOrder
    VALOR_TIKET?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type status_pedidoCountOrderByAggregateInput = {
    id_status_pedido?: SortOrder
    nome_status?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type status_pedidoAvgOrderByAggregateInput = {
    id_status_pedido?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
  }

  export type status_pedidoMaxOrderByAggregateInput = {
    id_status_pedido?: SortOrder
    nome_status?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type status_pedidoMinOrderByAggregateInput = {
    id_status_pedido?: SortOrder
    nome_status?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type status_pedidoSumOrderByAggregateInput = {
    id_status_pedido?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type pedidoCountOrderByAggregateInput = {
    id_pedido?: SortOrder
    id_user?: SortOrder
    id_lista?: SortOrder
    total?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type pedidoAvgOrderByAggregateInput = {
    id_pedido?: SortOrder
    id_user?: SortOrder
    id_lista?: SortOrder
    total?: SortOrder
  }

  export type pedidoMaxOrderByAggregateInput = {
    id_pedido?: SortOrder
    id_user?: SortOrder
    id_lista?: SortOrder
    total?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type pedidoMinOrderByAggregateInput = {
    id_pedido?: SortOrder
    id_user?: SortOrder
    id_lista?: SortOrder
    total?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type pedidoSumOrderByAggregateInput = {
    id_pedido?: SortOrder
    id_user?: SortOrder
    id_lista?: SortOrder
    total?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type pedido_itemCountOrderByAggregateInput = {
    id_pedido_item?: SortOrder
    id_pedido?: SortOrder
    id_produto?: SortOrder
    qtde?: SortOrder
    valor_unit?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type pedido_itemAvgOrderByAggregateInput = {
    id_pedido_item?: SortOrder
    id_pedido?: SortOrder
    id_produto?: SortOrder
    qtde?: SortOrder
    valor_unit?: SortOrder
  }

  export type pedido_itemMaxOrderByAggregateInput = {
    id_pedido_item?: SortOrder
    id_pedido?: SortOrder
    id_produto?: SortOrder
    qtde?: SortOrder
    valor_unit?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type pedido_itemMinOrderByAggregateInput = {
    id_pedido_item?: SortOrder
    id_pedido?: SortOrder
    id_produto?: SortOrder
    qtde?: SortOrder
    valor_unit?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type pedido_itemSumOrderByAggregateInput = {
    id_pedido_item?: SortOrder
    id_pedido?: SortOrder
    id_produto?: SortOrder
    qtde?: SortOrder
    valor_unit?: SortOrder
  }

  export type lista_produtoCountOrderByAggregateInput = {
    id_lista_produto?: SortOrder
    id_produto?: SortOrder
    id_lista?: SortOrder
    id_empresa?: SortOrder
    qtde_para_venda?: SortOrder
    qtde_disponivel?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type lista_produtoAvgOrderByAggregateInput = {
    id_lista_produto?: SortOrder
    id_produto?: SortOrder
    id_lista?: SortOrder
    id_empresa?: SortOrder
    qtde_para_venda?: SortOrder
    qtde_disponivel?: SortOrder
  }

  export type lista_produtoMaxOrderByAggregateInput = {
    id_lista_produto?: SortOrder
    id_produto?: SortOrder
    id_lista?: SortOrder
    id_empresa?: SortOrder
    qtde_para_venda?: SortOrder
    qtde_disponivel?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type lista_produtoMinOrderByAggregateInput = {
    id_lista_produto?: SortOrder
    id_produto?: SortOrder
    id_lista?: SortOrder
    id_empresa?: SortOrder
    qtde_para_venda?: SortOrder
    qtde_disponivel?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type lista_produtoSumOrderByAggregateInput = {
    id_lista_produto?: SortOrder
    id_produto?: SortOrder
    id_lista?: SortOrder
    id_empresa?: SortOrder
    qtde_para_venda?: SortOrder
    qtde_disponivel?: SortOrder
  }

  export type campanha_tokenCountOrderByAggregateInput = {
    id_campanha_token?: SortOrder
    id_campanha?: SortOrder
    token?: SortOrder
    utilizado?: SortOrder
    gerado?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type campanha_tokenAvgOrderByAggregateInput = {
    id_campanha_token?: SortOrder
    id_campanha?: SortOrder
    utilizado?: SortOrder
    gerado?: SortOrder
  }

  export type campanha_tokenMaxOrderByAggregateInput = {
    id_campanha_token?: SortOrder
    id_campanha?: SortOrder
    token?: SortOrder
    utilizado?: SortOrder
    gerado?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type campanha_tokenMinOrderByAggregateInput = {
    id_campanha_token?: SortOrder
    id_campanha?: SortOrder
    token?: SortOrder
    utilizado?: SortOrder
    gerado?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type campanha_tokenSumOrderByAggregateInput = {
    id_campanha_token?: SortOrder
    id_campanha?: SortOrder
    utilizado?: SortOrder
    gerado?: SortOrder
  }

  export type userempresaCountOrderByAggregateInput = {
    id_user_empresa?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    role?: SortOrder
  }

  export type userempresaAvgOrderByAggregateInput = {
    id_user_empresa?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
    role?: SortOrder
  }

  export type userempresaMaxOrderByAggregateInput = {
    id_user_empresa?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    role?: SortOrder
  }

  export type userempresaMinOrderByAggregateInput = {
    id_user_empresa?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
    data_cadastrou?: SortOrder
    role?: SortOrder
  }

  export type userempresaSumOrderByAggregateInput = {
    id_user_empresa?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
    role?: SortOrder
  }

  export type listaCountOrderByAggregateInput = {
    id_lista?: SortOrder
    id_empresa?: SortOrder
    nome_lista?: SortOrder
    ativo?: SortOrder
    descricao?: SortOrder
    data_cadastrou?: SortOrder
    data_vigencia_inicio?: SortOrder
    data_vigencia_fim?: SortOrder
    uid?: SortOrder
  }

  export type listaAvgOrderByAggregateInput = {
    id_lista?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
  }

  export type listaMaxOrderByAggregateInput = {
    id_lista?: SortOrder
    id_empresa?: SortOrder
    nome_lista?: SortOrder
    ativo?: SortOrder
    descricao?: SortOrder
    data_cadastrou?: SortOrder
    data_vigencia_inicio?: SortOrder
    data_vigencia_fim?: SortOrder
    uid?: SortOrder
  }

  export type listaMinOrderByAggregateInput = {
    id_lista?: SortOrder
    id_empresa?: SortOrder
    nome_lista?: SortOrder
    ativo?: SortOrder
    descricao?: SortOrder
    data_cadastrou?: SortOrder
    data_vigencia_inicio?: SortOrder
    data_vigencia_fim?: SortOrder
    uid?: SortOrder
  }

  export type listaSumOrderByAggregateInput = {
    id_lista?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
  }

  export type ProdutoListRelationFilter = {
    every?: produtoWhereInput
    some?: produtoWhereInput
    none?: produtoWhereInput
  }

  export type produtoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriaCountOrderByAggregateInput = {
    id_categoria?: SortOrder
    id_empresa?: SortOrder
    nome_categoria?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
    data_update?: SortOrder
    icon?: SortOrder
  }

  export type categoriaAvgOrderByAggregateInput = {
    id_categoria?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
  }

  export type categoriaMaxOrderByAggregateInput = {
    id_categoria?: SortOrder
    id_empresa?: SortOrder
    nome_categoria?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
    data_update?: SortOrder
    icon?: SortOrder
  }

  export type categoriaMinOrderByAggregateInput = {
    id_categoria?: SortOrder
    id_empresa?: SortOrder
    nome_categoria?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
    data_update?: SortOrder
    icon?: SortOrder
  }

  export type categoriaSumOrderByAggregateInput = {
    id_categoria?: SortOrder
    id_empresa?: SortOrder
    ativo?: SortOrder
  }

  export type CategoriaScalarRelationFilter = {
    is?: categoriaWhereInput
    isNot?: categoriaWhereInput
  }

  export type produtoCountOrderByAggregateInput = {
    id_produto?: SortOrder
    id_empresa?: SortOrder
    id_categoria?: SortOrder
    nome_produto?: SortOrder
    valor?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
    descricao?: SortOrder
  }

  export type produtoAvgOrderByAggregateInput = {
    id_produto?: SortOrder
    id_empresa?: SortOrder
    id_categoria?: SortOrder
    valor?: SortOrder
    ativo?: SortOrder
  }

  export type produtoMaxOrderByAggregateInput = {
    id_produto?: SortOrder
    id_empresa?: SortOrder
    id_categoria?: SortOrder
    nome_produto?: SortOrder
    valor?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
    descricao?: SortOrder
  }

  export type produtoMinOrderByAggregateInput = {
    id_produto?: SortOrder
    id_empresa?: SortOrder
    id_categoria?: SortOrder
    nome_produto?: SortOrder
    valor?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
    descricao?: SortOrder
  }

  export type produtoSumOrderByAggregateInput = {
    id_produto?: SortOrder
    id_empresa?: SortOrder
    id_categoria?: SortOrder
    valor?: SortOrder
    ativo?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type usuarioCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_user?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    bairro?: SortOrder
    tipo?: SortOrder
    cidade?: SortOrder
    postalcode?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrder
    ativo?: SortOrder
    numero?: SortOrder
    data_nascimento?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_user?: SortOrder
    ativo?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_user?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    bairro?: SortOrder
    tipo?: SortOrder
    cidade?: SortOrder
    postalcode?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrder
    ativo?: SortOrder
    numero?: SortOrder
    data_nascimento?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_user?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    bairro?: SortOrder
    tipo?: SortOrder
    cidade?: SortOrder
    postalcode?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrder
    ativo?: SortOrder
    numero?: SortOrder
    data_nascimento?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_user?: SortOrder
    ativo?: SortOrder
  }

  export type Campanha_msgCountOrderByAggregateInput = {
    id_campanha_msg?: SortOrder
    mensagem?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
  }

  export type Campanha_msgAvgOrderByAggregateInput = {
    id_campanha_msg?: SortOrder
    ativo?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
  }

  export type Campanha_msgMaxOrderByAggregateInput = {
    id_campanha_msg?: SortOrder
    mensagem?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
  }

  export type Campanha_msgMinOrderByAggregateInput = {
    id_campanha_msg?: SortOrder
    mensagem?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    data_cadastrou?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
  }

  export type Campanha_msgSumOrderByAggregateInput = {
    id_campanha_msg?: SortOrder
    ativo?: SortOrder
    id_empresa?: SortOrder
    id_user?: SortOrder
  }

  export type UsuarioListRelationFilter = {
    every?: usuarioWhereInput
    some?: usuarioWhereInput
    none?: usuarioWhereInput
  }

  export type usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cpf?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
    ativo?: SortOrder
    uid_user?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    ativo?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cpf?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
    ativo?: SortOrder
    uid_user?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cpf?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
    ativo?: SortOrder
    uid_user?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    ativo?: SortOrder
  }

  export type ResgateCountOrderByAggregateInput = {
    id_resgate?: SortOrder
    id_campanha?: SortOrder
    id_user?: SortOrder
    id_user_realizou?: SortOrder
    data_cadastrou?: SortOrder
    qtde_resgatado?: SortOrder
  }

  export type ResgateAvgOrderByAggregateInput = {
    id_resgate?: SortOrder
    id_campanha?: SortOrder
    id_user?: SortOrder
    id_user_realizou?: SortOrder
    qtde_resgatado?: SortOrder
  }

  export type ResgateMaxOrderByAggregateInput = {
    id_resgate?: SortOrder
    id_campanha?: SortOrder
    id_user?: SortOrder
    id_user_realizou?: SortOrder
    data_cadastrou?: SortOrder
    qtde_resgatado?: SortOrder
  }

  export type ResgateMinOrderByAggregateInput = {
    id_resgate?: SortOrder
    id_campanha?: SortOrder
    id_user?: SortOrder
    id_user_realizou?: SortOrder
    data_cadastrou?: SortOrder
    qtde_resgatado?: SortOrder
  }

  export type ResgateSumOrderByAggregateInput = {
    id_resgate?: SortOrder
    id_campanha?: SortOrder
    id_user?: SortOrder
    id_user_realizou?: SortOrder
    qtde_resgatado?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type empresaCountOrderByAggregateInput = {
    id_empresa?: SortOrder
    id_user?: SortOrder
    nome_empresa?: SortOrder
    cnpj?: SortOrder
    data_cadastrou?: SortOrder
    ativo?: SortOrder
    uid?: SortOrder
    apikey?: SortOrder
  }

  export type empresaAvgOrderByAggregateInput = {
    id_empresa?: SortOrder
    id_user?: SortOrder
    ativo?: SortOrder
  }

  export type empresaMaxOrderByAggregateInput = {
    id_empresa?: SortOrder
    id_user?: SortOrder
    nome_empresa?: SortOrder
    cnpj?: SortOrder
    data_cadastrou?: SortOrder
    ativo?: SortOrder
    uid?: SortOrder
    apikey?: SortOrder
  }

  export type empresaMinOrderByAggregateInput = {
    id_empresa?: SortOrder
    id_user?: SortOrder
    nome_empresa?: SortOrder
    cnpj?: SortOrder
    data_cadastrou?: SortOrder
    ativo?: SortOrder
    uid?: SortOrder
    apikey?: SortOrder
  }

  export type empresaSumOrderByAggregateInput = {
    id_empresa?: SortOrder
    id_user?: SortOrder
    ativo?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type campanha_formularioCountOrderByAggregateInput = {
    id_campanha_formulario?: SortOrder
    token?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type campanha_formularioAvgOrderByAggregateInput = {
    id_campanha_formulario?: SortOrder
  }

  export type campanha_formularioMaxOrderByAggregateInput = {
    id_campanha_formulario?: SortOrder
    token?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type campanha_formularioMinOrderByAggregateInput = {
    id_campanha_formulario?: SortOrder
    token?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    celular?: SortOrder
    data_cadastrou?: SortOrder
  }

  export type campanha_formularioSumOrderByAggregateInput = {
    id_campanha_formulario?: SortOrder
  }

  export type campanhaCountOrderByAggregateInput = {
    id_campanha?: SortOrder
    id_empresa?: SortOrder
    envia_msg?: SortOrder
    recompensa?: SortOrder
    nome_campanha?: SortOrder
    data_inicio?: SortOrder
    data_fim?: SortOrder
    ativo?: SortOrder
    qtde_servico?: SortOrder
    descricao?: SortOrder
    id_user?: SortOrder
    gera_token?: SortOrder
    nro_campanha_cliente?: SortOrder
    qtde_token?: SortOrder
    qtde_pontos?: SortOrder
    id_campanha_msg?: SortOrder
    mensagem_cliente?: SortOrder
    uid?: SortOrder
  }

  export type campanhaAvgOrderByAggregateInput = {
    id_campanha?: SortOrder
    id_empresa?: SortOrder
    envia_msg?: SortOrder
    ativo?: SortOrder
    qtde_servico?: SortOrder
    id_user?: SortOrder
    gera_token?: SortOrder
    qtde_token?: SortOrder
    qtde_pontos?: SortOrder
    id_campanha_msg?: SortOrder
  }

  export type campanhaMaxOrderByAggregateInput = {
    id_campanha?: SortOrder
    id_empresa?: SortOrder
    envia_msg?: SortOrder
    recompensa?: SortOrder
    nome_campanha?: SortOrder
    data_inicio?: SortOrder
    data_fim?: SortOrder
    ativo?: SortOrder
    qtde_servico?: SortOrder
    descricao?: SortOrder
    id_user?: SortOrder
    gera_token?: SortOrder
    nro_campanha_cliente?: SortOrder
    qtde_token?: SortOrder
    qtde_pontos?: SortOrder
    id_campanha_msg?: SortOrder
    mensagem_cliente?: SortOrder
    uid?: SortOrder
  }

  export type campanhaMinOrderByAggregateInput = {
    id_campanha?: SortOrder
    id_empresa?: SortOrder
    envia_msg?: SortOrder
    recompensa?: SortOrder
    nome_campanha?: SortOrder
    data_inicio?: SortOrder
    data_fim?: SortOrder
    ativo?: SortOrder
    qtde_servico?: SortOrder
    descricao?: SortOrder
    id_user?: SortOrder
    gera_token?: SortOrder
    nro_campanha_cliente?: SortOrder
    qtde_token?: SortOrder
    qtde_pontos?: SortOrder
    id_campanha_msg?: SortOrder
    mensagem_cliente?: SortOrder
    uid?: SortOrder
  }

  export type campanhaSumOrderByAggregateInput = {
    id_campanha?: SortOrder
    id_empresa?: SortOrder
    envia_msg?: SortOrder
    ativo?: SortOrder
    qtde_servico?: SortOrder
    id_user?: SortOrder
    gera_token?: SortOrder
    qtde_token?: SortOrder
    qtde_pontos?: SortOrder
    id_campanha_msg?: SortOrder
  }

  export type carimboCountOrderByAggregateInput = {
    id_carimbo?: SortOrder
    id_user_carimbou?: SortOrder
    id_user?: SortOrder
    id_campanha?: SortOrder
    data_carimbo?: SortOrder
    qtde_carimbo?: SortOrder
    id_resgate?: SortOrder
  }

  export type carimboAvgOrderByAggregateInput = {
    id_carimbo?: SortOrder
    id_user_carimbou?: SortOrder
    id_user?: SortOrder
    id_campanha?: SortOrder
    qtde_carimbo?: SortOrder
    id_resgate?: SortOrder
  }

  export type carimboMaxOrderByAggregateInput = {
    id_carimbo?: SortOrder
    id_user_carimbou?: SortOrder
    id_user?: SortOrder
    id_campanha?: SortOrder
    data_carimbo?: SortOrder
    qtde_carimbo?: SortOrder
    id_resgate?: SortOrder
  }

  export type carimboMinOrderByAggregateInput = {
    id_carimbo?: SortOrder
    id_user_carimbou?: SortOrder
    id_user?: SortOrder
    id_campanha?: SortOrder
    data_carimbo?: SortOrder
    qtde_carimbo?: SortOrder
    id_resgate?: SortOrder
  }

  export type carimboSumOrderByAggregateInput = {
    id_carimbo?: SortOrder
    id_user_carimbou?: SortOrder
    id_user?: SortOrder
    id_campanha?: SortOrder
    qtde_carimbo?: SortOrder
    id_resgate?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
    category_id?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
    category_id?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
    category_id?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    status?: SortOrder
    draft?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    table?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    status?: SortOrder
    draft?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    table?: SortOrder
    status?: SortOrder
    draft?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    table?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    update_at?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type produtoCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<produtoCreateWithoutCategoriaInput, produtoUncheckedCreateWithoutCategoriaInput> | produtoCreateWithoutCategoriaInput[] | produtoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: produtoCreateOrConnectWithoutCategoriaInput | produtoCreateOrConnectWithoutCategoriaInput[]
    createMany?: produtoCreateManyCategoriaInputEnvelope
    connect?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
  }

  export type produtoUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<produtoCreateWithoutCategoriaInput, produtoUncheckedCreateWithoutCategoriaInput> | produtoCreateWithoutCategoriaInput[] | produtoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: produtoCreateOrConnectWithoutCategoriaInput | produtoCreateOrConnectWithoutCategoriaInput[]
    createMany?: produtoCreateManyCategoriaInputEnvelope
    connect?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
  }

  export type produtoUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<produtoCreateWithoutCategoriaInput, produtoUncheckedCreateWithoutCategoriaInput> | produtoCreateWithoutCategoriaInput[] | produtoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: produtoCreateOrConnectWithoutCategoriaInput | produtoCreateOrConnectWithoutCategoriaInput[]
    upsert?: produtoUpsertWithWhereUniqueWithoutCategoriaInput | produtoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: produtoCreateManyCategoriaInputEnvelope
    set?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
    disconnect?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
    delete?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
    connect?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
    update?: produtoUpdateWithWhereUniqueWithoutCategoriaInput | produtoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: produtoUpdateManyWithWhereWithoutCategoriaInput | produtoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: produtoScalarWhereInput | produtoScalarWhereInput[]
  }

  export type produtoUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<produtoCreateWithoutCategoriaInput, produtoUncheckedCreateWithoutCategoriaInput> | produtoCreateWithoutCategoriaInput[] | produtoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: produtoCreateOrConnectWithoutCategoriaInput | produtoCreateOrConnectWithoutCategoriaInput[]
    upsert?: produtoUpsertWithWhereUniqueWithoutCategoriaInput | produtoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: produtoCreateManyCategoriaInputEnvelope
    set?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
    disconnect?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
    delete?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
    connect?: produtoWhereUniqueInput | produtoWhereUniqueInput[]
    update?: produtoUpdateWithWhereUniqueWithoutCategoriaInput | produtoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: produtoUpdateManyWithWhereWithoutCategoriaInput | produtoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: produtoScalarWhereInput | produtoScalarWhereInput[]
  }

  export type categoriaCreateNestedOneWithoutProdutosInput = {
    create?: XOR<categoriaCreateWithoutProdutosInput, categoriaUncheckedCreateWithoutProdutosInput>
    connectOrCreate?: categoriaCreateOrConnectWithoutProdutosInput
    connect?: categoriaWhereUniqueInput
  }

  export type categoriaUpdateOneRequiredWithoutProdutosNestedInput = {
    create?: XOR<categoriaCreateWithoutProdutosInput, categoriaUncheckedCreateWithoutProdutosInput>
    connectOrCreate?: categoriaCreateOrConnectWithoutProdutosInput
    upsert?: categoriaUpsertWithoutProdutosInput
    connect?: categoriaWhereUniqueInput
    update?: XOR<XOR<categoriaUpdateToOneWithWhereWithoutProdutosInput, categoriaUpdateWithoutProdutosInput>, categoriaUncheckedUpdateWithoutProdutosInput>
  }

  export type UserCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<UserCreateWithoutUsuarioInput, UserUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsuarioInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<UserCreateWithoutUsuarioInput, UserUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsuarioInput
    upsert?: UserUpsertWithoutUsuarioInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsuarioInput, UserUpdateWithoutUsuarioInput>, UserUncheckedUpdateWithoutUsuarioInput>
  }

  export type usuarioCreateNestedManyWithoutUserInput = {
    create?: XOR<usuarioCreateWithoutUserInput, usuarioUncheckedCreateWithoutUserInput> | usuarioCreateWithoutUserInput[] | usuarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutUserInput | usuarioCreateOrConnectWithoutUserInput[]
    createMany?: usuarioCreateManyUserInputEnvelope
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type usuarioUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<usuarioCreateWithoutUserInput, usuarioUncheckedCreateWithoutUserInput> | usuarioCreateWithoutUserInput[] | usuarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutUserInput | usuarioCreateOrConnectWithoutUserInput[]
    createMany?: usuarioCreateManyUserInputEnvelope
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type usuarioUpdateManyWithoutUserNestedInput = {
    create?: XOR<usuarioCreateWithoutUserInput, usuarioUncheckedCreateWithoutUserInput> | usuarioCreateWithoutUserInput[] | usuarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutUserInput | usuarioCreateOrConnectWithoutUserInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutUserInput | usuarioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: usuarioCreateManyUserInputEnvelope
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutUserInput | usuarioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutUserInput | usuarioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type usuarioUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<usuarioCreateWithoutUserInput, usuarioUncheckedCreateWithoutUserInput> | usuarioCreateWithoutUserInput[] | usuarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutUserInput | usuarioCreateOrConnectWithoutUserInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutUserInput | usuarioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: usuarioCreateManyUserInputEnvelope
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutUserInput | usuarioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutUserInput | usuarioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ItemCreateNestedManyWithoutProductInput = {
    create?: XOR<ItemCreateWithoutProductInput, ItemUncheckedCreateWithoutProductInput> | ItemCreateWithoutProductInput[] | ItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutProductInput | ItemCreateOrConnectWithoutProductInput[]
    createMany?: ItemCreateManyProductInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ItemCreateWithoutProductInput, ItemUncheckedCreateWithoutProductInput> | ItemCreateWithoutProductInput[] | ItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutProductInput | ItemCreateOrConnectWithoutProductInput[]
    createMany?: ItemCreateManyProductInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<ItemCreateWithoutProductInput, ItemUncheckedCreateWithoutProductInput> | ItemCreateWithoutProductInput[] | ItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutProductInput | ItemCreateOrConnectWithoutProductInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutProductInput | ItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ItemCreateManyProductInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutProductInput | ItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutProductInput | ItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ItemCreateWithoutProductInput, ItemUncheckedCreateWithoutProductInput> | ItemCreateWithoutProductInput[] | ItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutProductInput | ItemCreateOrConnectWithoutProductInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutProductInput | ItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ItemCreateManyProductInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutProductInput | ItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutProductInput | ItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<ItemCreateWithoutOrderInput, ItemUncheckedCreateWithoutOrderInput> | ItemCreateWithoutOrderInput[] | ItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutOrderInput | ItemCreateOrConnectWithoutOrderInput[]
    createMany?: ItemCreateManyOrderInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ItemCreateWithoutOrderInput, ItemUncheckedCreateWithoutOrderInput> | ItemCreateWithoutOrderInput[] | ItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutOrderInput | ItemCreateOrConnectWithoutOrderInput[]
    createMany?: ItemCreateManyOrderInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ItemCreateWithoutOrderInput, ItemUncheckedCreateWithoutOrderInput> | ItemCreateWithoutOrderInput[] | ItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutOrderInput | ItemCreateOrConnectWithoutOrderInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutOrderInput | ItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ItemCreateManyOrderInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutOrderInput | ItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutOrderInput | ItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ItemCreateWithoutOrderInput, ItemUncheckedCreateWithoutOrderInput> | ItemCreateWithoutOrderInput[] | ItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutOrderInput | ItemCreateOrConnectWithoutOrderInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutOrderInput | ItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ItemCreateManyOrderInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutOrderInput | ItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutOrderInput | ItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutItemsInput = {
    create?: XOR<ProductCreateWithoutItemsInput, ProductUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ProductCreateWithoutItemsInput, ProductUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutItemsInput
    upsert?: ProductUpsertWithoutItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutItemsInput, ProductUpdateWithoutItemsInput>, ProductUncheckedUpdateWithoutItemsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type produtoCreateWithoutCategoriaInput = {
    id_empresa: number
    nome_produto: string
    valor: number
    ativo: number
    data_cadastrou?: Date | string | null
    descricao: string
  }

  export type produtoUncheckedCreateWithoutCategoriaInput = {
    id_produto?: number
    id_empresa: number
    nome_produto: string
    valor: number
    ativo: number
    data_cadastrou?: Date | string | null
    descricao: string
  }

  export type produtoCreateOrConnectWithoutCategoriaInput = {
    where: produtoWhereUniqueInput
    create: XOR<produtoCreateWithoutCategoriaInput, produtoUncheckedCreateWithoutCategoriaInput>
  }

  export type produtoCreateManyCategoriaInputEnvelope = {
    data: produtoCreateManyCategoriaInput | produtoCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type produtoUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: produtoWhereUniqueInput
    update: XOR<produtoUpdateWithoutCategoriaInput, produtoUncheckedUpdateWithoutCategoriaInput>
    create: XOR<produtoCreateWithoutCategoriaInput, produtoUncheckedCreateWithoutCategoriaInput>
  }

  export type produtoUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: produtoWhereUniqueInput
    data: XOR<produtoUpdateWithoutCategoriaInput, produtoUncheckedUpdateWithoutCategoriaInput>
  }

  export type produtoUpdateManyWithWhereWithoutCategoriaInput = {
    where: produtoScalarWhereInput
    data: XOR<produtoUpdateManyMutationInput, produtoUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type produtoScalarWhereInput = {
    AND?: produtoScalarWhereInput | produtoScalarWhereInput[]
    OR?: produtoScalarWhereInput[]
    NOT?: produtoScalarWhereInput | produtoScalarWhereInput[]
    id_produto?: IntFilter<"produto"> | number
    id_empresa?: IntFilter<"produto"> | number
    id_categoria?: IntFilter<"produto"> | number
    nome_produto?: StringFilter<"produto"> | string
    valor?: FloatFilter<"produto"> | number
    ativo?: IntFilter<"produto"> | number
    data_cadastrou?: DateTimeNullableFilter<"produto"> | Date | string | null
    descricao?: StringFilter<"produto"> | string
  }

  export type categoriaCreateWithoutProdutosInput = {
    id_empresa: number
    nome_categoria: string
    ativo: number
    data_cadastrou?: Date | string | null
    data_update?: Date | string | null
    icon?: string | null
  }

  export type categoriaUncheckedCreateWithoutProdutosInput = {
    id_categoria?: number
    id_empresa: number
    nome_categoria: string
    ativo: number
    data_cadastrou?: Date | string | null
    data_update?: Date | string | null
    icon?: string | null
  }

  export type categoriaCreateOrConnectWithoutProdutosInput = {
    where: categoriaWhereUniqueInput
    create: XOR<categoriaCreateWithoutProdutosInput, categoriaUncheckedCreateWithoutProdutosInput>
  }

  export type categoriaUpsertWithoutProdutosInput = {
    update: XOR<categoriaUpdateWithoutProdutosInput, categoriaUncheckedUpdateWithoutProdutosInput>
    create: XOR<categoriaCreateWithoutProdutosInput, categoriaUncheckedCreateWithoutProdutosInput>
    where?: categoriaWhereInput
  }

  export type categoriaUpdateToOneWithWhereWithoutProdutosInput = {
    where?: categoriaWhereInput
    data: XOR<categoriaUpdateWithoutProdutosInput, categoriaUncheckedUpdateWithoutProdutosInput>
  }

  export type categoriaUpdateWithoutProdutosInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_categoria?: StringFieldUpdateOperationsInput | string
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriaUncheckedUpdateWithoutProdutosInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_categoria?: StringFieldUpdateOperationsInput | string
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    data_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutUsuarioInput = {
    name: string
    email?: string | null
    password: string
    cpf?: string | null
    role?: number | null
    created_at?: Date | string | null
    update_at?: Date | string | null
    ativo?: number
    uid_user?: string | null
  }

  export type UserUncheckedCreateWithoutUsuarioInput = {
    id?: number
    name: string
    email?: string | null
    password: string
    cpf?: string | null
    role?: number | null
    created_at?: Date | string | null
    update_at?: Date | string | null
    ativo?: number
    uid_user?: string | null
  }

  export type UserCreateOrConnectWithoutUsuarioInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsuarioInput, UserUncheckedCreateWithoutUsuarioInput>
  }

  export type UserUpsertWithoutUsuarioInput = {
    update: XOR<UserUpdateWithoutUsuarioInput, UserUncheckedUpdateWithoutUsuarioInput>
    create: XOR<UserCreateWithoutUsuarioInput, UserUncheckedCreateWithoutUsuarioInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsuarioInput, UserUncheckedUpdateWithoutUsuarioInput>
  }

  export type UserUpdateWithoutUsuarioInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: IntFieldUpdateOperationsInput | number
    uid_user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: IntFieldUpdateOperationsInput | number
    uid_user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioCreateWithoutUserInput = {
    cpf: string
    nome: string
    endereco: string
    bairro: string
    tipo: string
    cidade: string
    postalcode: string
    celular: string
    data_cadastrou?: Date | string | null
    ativo?: number | null
    numero: string
    data_nascimento?: Date | string | null
    email?: string | null
    telefone?: string | null
  }

  export type usuarioUncheckedCreateWithoutUserInput = {
    id_usuario?: number
    cpf: string
    nome: string
    endereco: string
    bairro: string
    tipo: string
    cidade: string
    postalcode: string
    celular: string
    data_cadastrou?: Date | string | null
    ativo?: number | null
    numero: string
    data_nascimento?: Date | string | null
    email?: string | null
    telefone?: string | null
  }

  export type usuarioCreateOrConnectWithoutUserInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutUserInput, usuarioUncheckedCreateWithoutUserInput>
  }

  export type usuarioCreateManyUserInputEnvelope = {
    data: usuarioCreateManyUserInput | usuarioCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type usuarioUpsertWithWhereUniqueWithoutUserInput = {
    where: usuarioWhereUniqueInput
    update: XOR<usuarioUpdateWithoutUserInput, usuarioUncheckedUpdateWithoutUserInput>
    create: XOR<usuarioCreateWithoutUserInput, usuarioUncheckedCreateWithoutUserInput>
  }

  export type usuarioUpdateWithWhereUniqueWithoutUserInput = {
    where: usuarioWhereUniqueInput
    data: XOR<usuarioUpdateWithoutUserInput, usuarioUncheckedUpdateWithoutUserInput>
  }

  export type usuarioUpdateManyWithWhereWithoutUserInput = {
    where: usuarioScalarWhereInput
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyWithoutUserInput>
  }

  export type usuarioScalarWhereInput = {
    AND?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
    OR?: usuarioScalarWhereInput[]
    NOT?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
    id_usuario?: IntFilter<"usuario"> | number
    id_user?: IntFilter<"usuario"> | number
    cpf?: StringFilter<"usuario"> | string
    nome?: StringFilter<"usuario"> | string
    endereco?: StringFilter<"usuario"> | string
    bairro?: StringFilter<"usuario"> | string
    tipo?: StringFilter<"usuario"> | string
    cidade?: StringFilter<"usuario"> | string
    postalcode?: StringFilter<"usuario"> | string
    celular?: StringFilter<"usuario"> | string
    data_cadastrou?: DateTimeNullableFilter<"usuario"> | Date | string | null
    ativo?: IntNullableFilter<"usuario"> | number | null
    numero?: StringFilter<"usuario"> | string
    data_nascimento?: DateTimeNullableFilter<"usuario"> | Date | string | null
    email?: StringNullableFilter<"usuario"> | string | null
    telefone?: StringNullableFilter<"usuario"> | string | null
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    name: string
    price: string
    description: string
    banner: string
    created_at?: Date | string | null
    update_at?: Date | string | null
    items?: ItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    price: string
    description: string
    banner: string
    created_at?: Date | string | null
    update_at?: Date | string | null
    items?: ItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    price?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    banner?: StringFilter<"Product"> | string
    created_at?: DateTimeNullableFilter<"Product"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Product"> | Date | string | null
    category_id?: StringFilter<"Product"> | string
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    created_at?: Date | string | null
    update_at?: Date | string | null
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    created_at?: Date | string | null
    update_at?: Date | string | null
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ItemCreateWithoutProductInput = {
    id?: string
    amount: number
    created_at?: Date | string | null
    update_at?: Date | string | null
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutProductInput = {
    id?: string
    amount: number
    created_at?: Date | string | null
    update_at?: Date | string | null
    order_id: string
  }

  export type ItemCreateOrConnectWithoutProductInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutProductInput, ItemUncheckedCreateWithoutProductInput>
  }

  export type ItemCreateManyProductInputEnvelope = {
    data: ItemCreateManyProductInput | ItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemUpsertWithWhereUniqueWithoutProductInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutProductInput, ItemUncheckedUpdateWithoutProductInput>
    create: XOR<ItemCreateWithoutProductInput, ItemUncheckedCreateWithoutProductInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutProductInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutProductInput, ItemUncheckedUpdateWithoutProductInput>
  }

  export type ItemUpdateManyWithWhereWithoutProductInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: StringFilter<"Item"> | string
    amount?: IntFilter<"Item"> | number
    created_at?: DateTimeNullableFilter<"Item"> | Date | string | null
    update_at?: DateTimeNullableFilter<"Item"> | Date | string | null
    order_id?: StringFilter<"Item"> | string
    product_id?: StringFilter<"Item"> | string
  }

  export type ItemCreateWithoutOrderInput = {
    id?: string
    amount: number
    created_at?: Date | string | null
    update_at?: Date | string | null
    product: ProductCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutOrderInput = {
    id?: string
    amount: number
    created_at?: Date | string | null
    update_at?: Date | string | null
    product_id: string
  }

  export type ItemCreateOrConnectWithoutOrderInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutOrderInput, ItemUncheckedCreateWithoutOrderInput>
  }

  export type ItemCreateManyOrderInputEnvelope = {
    data: ItemCreateManyOrderInput | ItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutOrderInput, ItemUncheckedUpdateWithoutOrderInput>
    create: XOR<ItemCreateWithoutOrderInput, ItemUncheckedCreateWithoutOrderInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutOrderInput, ItemUncheckedUpdateWithoutOrderInput>
  }

  export type ItemUpdateManyWithWhereWithoutOrderInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    table: number
    status?: boolean
    draft?: boolean
    name?: string | null
    created_at?: Date | string | null
    update_at?: Date | string | null
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    table: number
    status?: boolean
    draft?: boolean
    name?: string | null
    created_at?: Date | string | null
    update_at?: Date | string | null
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutItemsInput = {
    id?: string
    name: string
    price: string
    description: string
    banner: string
    created_at?: Date | string | null
    update_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    price: string
    description: string
    banner: string
    created_at?: Date | string | null
    update_at?: Date | string | null
    category_id: string
  }

  export type ProductCreateOrConnectWithoutItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutItemsInput, ProductUncheckedCreateWithoutItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    draft?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    table?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    draft?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUpsertWithoutItemsInput = {
    update: XOR<ProductUpdateWithoutItemsInput, ProductUncheckedUpdateWithoutItemsInput>
    create: XOR<ProductCreateWithoutItemsInput, ProductUncheckedCreateWithoutItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutItemsInput, ProductUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_id?: StringFieldUpdateOperationsInput | string
  }

  export type produtoCreateManyCategoriaInput = {
    id_produto?: number
    id_empresa: number
    nome_produto: string
    valor: number
    ativo: number
    data_cadastrou?: Date | string | null
    descricao: string
  }

  export type produtoUpdateWithoutCategoriaInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_produto?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type produtoUncheckedUpdateWithoutCategoriaInput = {
    id_produto?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_produto?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type produtoUncheckedUpdateManyWithoutCategoriaInput = {
    id_produto?: IntFieldUpdateOperationsInput | number
    id_empresa?: IntFieldUpdateOperationsInput | number
    nome_produto?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    ativo?: IntFieldUpdateOperationsInput | number
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type usuarioCreateManyUserInput = {
    id_usuario?: number
    cpf: string
    nome: string
    endereco: string
    bairro: string
    tipo: string
    cidade: string
    postalcode: string
    celular: string
    data_cadastrou?: Date | string | null
    ativo?: number | null
    numero: string
    data_nascimento?: Date | string | null
    email?: string | null
    telefone?: string | null
  }

  export type usuarioUpdateWithoutUserInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    postalcode?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    numero?: StringFieldUpdateOperationsInput | string
    data_nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioUncheckedUpdateWithoutUserInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    postalcode?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    numero?: StringFieldUpdateOperationsInput | string
    data_nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioUncheckedUpdateManyWithoutUserInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    postalcode?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    data_cadastrou?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableIntFieldUpdateOperationsInput | number | null
    numero?: StringFieldUpdateOperationsInput | string
    data_nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    name: string
    price: string
    description: string
    banner: string
    created_at?: Date | string | null
    update_at?: Date | string | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: ItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCreateManyProductInput = {
    id?: string
    amount: number
    created_at?: Date | string | null
    update_at?: Date | string | null
    order_id: string
  }

  export type ItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_id?: StringFieldUpdateOperationsInput | string
  }

  export type ItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_id?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateManyOrderInput = {
    id?: string
    amount: number
    created_at?: Date | string | null
    update_at?: Date | string | null
    product_id: string
  }

  export type ItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type ItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_id?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}